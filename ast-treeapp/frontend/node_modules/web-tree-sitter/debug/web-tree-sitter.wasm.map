{
  "version": 3,
  "sources": [
    "../lib/alloc.c",
    "../lib/get_changed_ranges.c",
    "../lib/length.h",
    "../lib/array.h",
    "../lib/point.h",
    "../lib/subtree.h",
    "../lib/subtree.c",
    "../lib/language.c",
    "../lib/wasm_store.c",
    "../lib/language.h",
    "../lib/lexer.c",
    "../lib/unicode.h",
    "../lib/node.c",
    "../lib/tree.c",
    "../lib/point.c",
    "../lib/parser.c",
    "../lib/stack.c",
    "../lib/reusable_node.h",
    "../lib/atomic.h",
    "../lib/query.c",
    "../lib/tree_cursor.c",
    "../lib/reduce_action.h",
    "../lib/tree_cursor.h",
    "../lib/tree-sitter.c"
  ],
  "sourcesContent": [
    "#include \"alloc.h\"\n#include \"tree_sitter/api.h\"\n#include <stdlib.h>\n\nstatic void *ts_malloc_default(size_t size) {\n  void *result = malloc(size);\n  if (size > 0 && !result) {\n    fprintf(stderr, \"tree-sitter failed to allocate %zu bytes\", size);\n    abort();\n  }\n  return result;\n}\n\nstatic void *ts_calloc_default(size_t count, size_t size) {\n  void *result = calloc(count, size);\n  if (count > 0 && !result) {\n    fprintf(stderr, \"tree-sitter failed to allocate %zu bytes\", count * size);\n    abort();\n  }\n  return result;\n}\n\nstatic void *ts_realloc_default(void *buffer, size_t size) {\n  void *result = realloc(buffer, size);\n  if (size > 0 && !result) {\n    fprintf(stderr, \"tree-sitter failed to reallocate %zu bytes\", size);\n    abort();\n  }\n  return result;\n}\n\n// Allow clients to override allocation functions dynamically\nTS_PUBLIC void *(*ts_current_malloc)(size_t) = ts_malloc_default;\nTS_PUBLIC void *(*ts_current_calloc)(size_t, size_t) = ts_calloc_default;\nTS_PUBLIC void *(*ts_current_realloc)(void *, size_t) = ts_realloc_default;\nTS_PUBLIC void (*ts_current_free)(void *) = free;\n\nvoid ts_set_allocator(\n  void *(*new_malloc)(size_t size),\n  void *(*new_calloc)(size_t count, size_t size),\n  void *(*new_realloc)(void *ptr, size_t size),\n  void (*new_free)(void *ptr)\n) {\n  ts_current_malloc = new_malloc ? new_malloc : ts_malloc_default;\n  ts_current_calloc = new_calloc ? new_calloc : ts_calloc_default;\n  ts_current_realloc = new_realloc ? new_realloc : ts_realloc_default;\n  ts_current_free = new_free ? new_free : free;\n}\n",
    "#include \"./get_changed_ranges.h\"\n#include \"./subtree.h\"\n#include \"./language.h\"\n#include \"./error_costs.h\"\n#include \"./tree_cursor.h\"\n#include \"./ts_assert.h\"\n\n// #define DEBUG_GET_CHANGED_RANGES\n\nstatic void ts_range_array_add(\n  TSRangeArray *self,\n  Length start,\n  Length end\n) {\n  if (self->size > 0) {\n    TSRange *last_range = array_back(self);\n    if (start.bytes <= last_range->end_byte) {\n      last_range->end_byte = end.bytes;\n      last_range->end_point = end.extent;\n      return;\n    }\n  }\n\n  if (start.bytes < end.bytes) {\n    TSRange range = { start.extent, end.extent, start.bytes, end.bytes };\n    array_push(self, range);\n  }\n}\n\nbool ts_range_array_intersects(\n  const TSRangeArray *self,\n  unsigned start_index,\n  uint32_t start_byte,\n  uint32_t end_byte\n) {\n  for (unsigned i = start_index; i < self->size; i++) {\n    TSRange *range = array_get(self, i);\n    if (range->end_byte > start_byte) {\n      if (range->start_byte >= end_byte) break;\n      return true;\n    }\n  }\n  return false;\n}\n\nvoid ts_range_array_get_changed_ranges(\n  const TSRange *old_ranges, unsigned old_range_count,\n  const TSRange *new_ranges, unsigned new_range_count,\n  TSRangeArray *differences\n) {\n  unsigned new_index = 0;\n  unsigned old_index = 0;\n  Length current_position = length_zero();\n  bool in_old_range = false;\n  bool in_new_range = false;\n\n  while (old_index < old_range_count || new_index < new_range_count) {\n    const TSRange *old_range = &old_ranges[old_index];\n    const TSRange *new_range = &new_ranges[new_index];\n\n    Length next_old_position;\n    if (in_old_range) {\n      next_old_position = (Length) {old_range->end_byte, old_range->end_point};\n    } else if (old_index < old_range_count) {\n      next_old_position = (Length) {old_range->start_byte, old_range->start_point};\n    } else {\n      next_old_position = LENGTH_MAX;\n    }\n\n    Length next_new_position;\n    if (in_new_range) {\n      next_new_position = (Length) {new_range->end_byte, new_range->end_point};\n    } else if (new_index < new_range_count) {\n      next_new_position = (Length) {new_range->start_byte, new_range->start_point};\n    } else {\n      next_new_position = LENGTH_MAX;\n    }\n\n    if (next_old_position.bytes < next_new_position.bytes) {\n      if (in_old_range != in_new_range) {\n        ts_range_array_add(differences, current_position, next_old_position);\n      }\n      if (in_old_range) old_index++;\n      current_position = next_old_position;\n      in_old_range = !in_old_range;\n    } else if (next_new_position.bytes < next_old_position.bytes) {\n      if (in_old_range != in_new_range) {\n        ts_range_array_add(differences, current_position, next_new_position);\n      }\n      if (in_new_range) new_index++;\n      current_position = next_new_position;\n      in_new_range = !in_new_range;\n    } else {\n      if (in_old_range != in_new_range) {\n        ts_range_array_add(differences, current_position, next_new_position);\n      }\n      if (in_old_range) old_index++;\n      if (in_new_range) new_index++;\n      in_old_range = !in_old_range;\n      in_new_range = !in_new_range;\n      current_position = next_new_position;\n    }\n  }\n}\n\nvoid ts_range_edit(TSRange *range, const TSInputEdit *edit) {\n  if (range->end_byte >= edit->old_end_byte) {\n    if (range->end_byte != UINT32_MAX) {\n      range->end_byte = edit->new_end_byte + (range->end_byte - edit->old_end_byte);\n      range->end_point = point_add(\n        edit->new_end_point,\n        point_sub(range->end_point, edit->old_end_point)\n      );\n      if (range->end_byte < edit->new_end_byte) {\n        range->end_byte = UINT32_MAX;\n        range->end_point = POINT_MAX;\n      }\n    }\n  } else if (range->end_byte > edit->start_byte) {\n    range->end_byte = edit->start_byte;\n    range->end_point = edit->start_point;\n  }\n\n  if (range->start_byte >= edit->old_end_byte) {\n    range->start_byte = edit->new_end_byte + (range->start_byte - edit->old_end_byte);\n    range->start_point = point_add(\n      edit->new_end_point,\n      point_sub(range->start_point, edit->old_end_point)\n    );\n    if (range->start_byte < edit->new_end_byte) {\n      range->start_byte = UINT32_MAX;\n      range->start_point = POINT_MAX;\n    }\n  } else if (range->start_byte > edit->start_byte) {\n    range->start_byte = edit->start_byte;\n    range->start_point = edit->start_point;\n  }\n}\n\ntypedef struct {\n  TreeCursor cursor;\n  const TSLanguage *language;\n  unsigned visible_depth;\n  bool in_padding;\n  Subtree prev_external_token;\n} Iterator;\n\nstatic Iterator iterator_new(\n  TreeCursor *cursor,\n  const Subtree *tree,\n  const TSLanguage *language\n) {\n  array_clear(&cursor->stack);\n  array_push(&cursor->stack, ((TreeCursorEntry) {\n    .subtree = tree,\n    .position = length_zero(),\n    .child_index = 0,\n    .structural_child_index = 0,\n  }));\n  return (Iterator) {\n    .cursor = *cursor,\n    .language = language,\n    .visible_depth = 1,\n    .in_padding = false,\n    .prev_external_token = NULL_SUBTREE,\n  };\n}\n\nstatic bool iterator_done(Iterator *self) {\n  return self->cursor.stack.size == 0;\n}\n\nstatic Length iterator_start_position(Iterator *self) {\n  TreeCursorEntry entry = *array_back(&self->cursor.stack);\n  if (self->in_padding) {\n    return entry.position;\n  } else {\n    return length_add(entry.position, ts_subtree_padding(*entry.subtree));\n  }\n}\n\nstatic Length iterator_end_position(Iterator *self) {\n  TreeCursorEntry entry = *array_back(&self->cursor.stack);\n  Length result = length_add(entry.position, ts_subtree_padding(*entry.subtree));\n  if (self->in_padding) {\n    return result;\n  } else {\n    return length_add(result, ts_subtree_size(*entry.subtree));\n  }\n}\n\nstatic bool iterator_tree_is_visible(const Iterator *self) {\n  TreeCursorEntry entry = *array_back(&self->cursor.stack);\n  if (ts_subtree_visible(*entry.subtree)) return true;\n  if (self->cursor.stack.size > 1) {\n    Subtree parent = *array_get(&self->cursor.stack, self->cursor.stack.size - 2)->subtree;\n    return ts_language_alias_at(\n      self->language,\n      parent.ptr->production_id,\n      entry.structural_child_index\n    ) != 0;\n  }\n  return false;\n}\n\nstatic void iterator_get_visible_state(\n  const Iterator *self,\n  Subtree *tree,\n  TSSymbol *alias_symbol,\n  uint32_t *start_byte\n) {\n  uint32_t i = self->cursor.stack.size - 1;\n\n  if (self->in_padding) {\n    if (i == 0) return;\n    i--;\n  }\n\n  for (; i + 1 > 0; i--) {\n    TreeCursorEntry entry = *array_get(&self->cursor.stack, i);\n\n    if (i > 0) {\n      const Subtree *parent = array_get(&self->cursor.stack, i - 1)->subtree;\n      *alias_symbol = ts_language_alias_at(\n        self->language,\n        parent->ptr->production_id,\n        entry.structural_child_index\n      );\n    }\n\n    if (ts_subtree_visible(*entry.subtree) || *alias_symbol) {\n      *tree = *entry.subtree;\n      *start_byte = entry.position.bytes;\n      break;\n    }\n  }\n}\n\nstatic void iterator_ascend(Iterator *self) {\n  if (iterator_done(self)) return;\n  if (iterator_tree_is_visible(self) && !self->in_padding) self->visible_depth--;\n  if (array_back(&self->cursor.stack)->child_index > 0) self->in_padding = false;\n  self->cursor.stack.size--;\n}\n\nstatic bool iterator_descend(Iterator *self, uint32_t goal_position) {\n  if (self->in_padding) return false;\n\n  bool did_descend = false;\n  do {\n    did_descend = false;\n    TreeCursorEntry entry = *array_back(&self->cursor.stack);\n    Length position = entry.position;\n    uint32_t structural_child_index = 0;\n    for (uint32_t i = 0, n = ts_subtree_child_count(*entry.subtree); i < n; i++) {\n      const Subtree *child = &ts_subtree_children(*entry.subtree)[i];\n      Length child_left = length_add(position, ts_subtree_padding(*child));\n      Length child_right = length_add(child_left, ts_subtree_size(*child));\n\n      if (child_right.bytes > goal_position) {\n        array_push(&self->cursor.stack, ((TreeCursorEntry) {\n          .subtree = child,\n          .position = position,\n          .child_index = i,\n          .structural_child_index = structural_child_index,\n        }));\n\n        if (iterator_tree_is_visible(self)) {\n          if (child_left.bytes > goal_position) {\n            self->in_padding = true;\n          } else {\n            self->visible_depth++;\n          }\n          return true;\n        }\n\n        did_descend = true;\n        break;\n      }\n\n      position = child_right;\n      if (!ts_subtree_extra(*child)) structural_child_index++;\n      Subtree last_external_token = ts_subtree_last_external_token(*child);\n      if (last_external_token.ptr) {\n        self->prev_external_token = last_external_token;\n      }\n    }\n  } while (did_descend);\n\n  return false;\n}\n\nstatic void iterator_advance(Iterator *self) {\n  if (self->in_padding) {\n    self->in_padding = false;\n    if (iterator_tree_is_visible(self)) {\n      self->visible_depth++;\n    } else {\n      iterator_descend(self, 0);\n    }\n    return;\n  }\n\n  for (;;) {\n    if (iterator_tree_is_visible(self)) self->visible_depth--;\n    TreeCursorEntry entry = array_pop(&self->cursor.stack);\n    if (iterator_done(self)) return;\n\n    const Subtree *parent = array_back(&self->cursor.stack)->subtree;\n    uint32_t child_index = entry.child_index + 1;\n    Subtree last_external_token = ts_subtree_last_external_token(*entry.subtree);\n    if (last_external_token.ptr) {\n      self->prev_external_token = last_external_token;\n    }\n    if (ts_subtree_child_count(*parent) > child_index) {\n      Length position = length_add(entry.position, ts_subtree_total_size(*entry.subtree));\n      uint32_t structural_child_index = entry.structural_child_index;\n      if (!ts_subtree_extra(*entry.subtree)) structural_child_index++;\n      const Subtree *next_child = &ts_subtree_children(*parent)[child_index];\n\n      array_push(&self->cursor.stack, ((TreeCursorEntry) {\n        .subtree = next_child,\n        .position = position,\n        .child_index = child_index,\n        .structural_child_index = structural_child_index,\n      }));\n\n      if (iterator_tree_is_visible(self)) {\n        if (ts_subtree_padding(*next_child).bytes > 0) {\n          self->in_padding = true;\n        } else {\n          self->visible_depth++;\n        }\n      } else {\n        iterator_descend(self, 0);\n      }\n      break;\n    }\n  }\n}\n\ntypedef enum {\n  IteratorDiffers,\n  IteratorMayDiffer,\n  IteratorMatches,\n} IteratorComparison;\n\nstatic IteratorComparison iterator_compare(\n  const Iterator *old_iter,\n  const Iterator *new_iter\n) {\n  Subtree old_tree = NULL_SUBTREE;\n  Subtree new_tree = NULL_SUBTREE;\n  uint32_t old_start = 0;\n  uint32_t new_start = 0;\n  TSSymbol old_alias_symbol = 0;\n  TSSymbol new_alias_symbol = 0;\n  iterator_get_visible_state(old_iter, &old_tree, &old_alias_symbol, &old_start);\n  iterator_get_visible_state(new_iter, &new_tree, &new_alias_symbol, &new_start);\n  TSSymbol old_symbol = ts_subtree_symbol(old_tree);\n  TSSymbol new_symbol = ts_subtree_symbol(new_tree);\n\n  if (!old_tree.ptr && !new_tree.ptr) return IteratorMatches;\n  if (!old_tree.ptr || !new_tree.ptr) return IteratorDiffers;\n  if (old_alias_symbol != new_alias_symbol || old_symbol != new_symbol) return IteratorDiffers;\n\n  uint32_t old_size = ts_subtree_size(old_tree).bytes;\n  uint32_t new_size = ts_subtree_size(new_tree).bytes;\n  TSStateId old_state = ts_subtree_parse_state(old_tree);\n  TSStateId new_state = ts_subtree_parse_state(new_tree);\n  bool old_has_external_tokens = ts_subtree_has_external_tokens(old_tree);\n  bool new_has_external_tokens = ts_subtree_has_external_tokens(new_tree);\n  uint32_t old_error_cost = ts_subtree_error_cost(old_tree);\n  uint32_t new_error_cost = ts_subtree_error_cost(new_tree);\n\n  if (\n    old_start != new_start ||\n    old_symbol == ts_builtin_sym_error ||\n    old_size != new_size ||\n    old_state == TS_TREE_STATE_NONE ||\n    new_state == TS_TREE_STATE_NONE ||\n    ((old_state == ERROR_STATE) != (new_state == ERROR_STATE)) ||\n    old_error_cost != new_error_cost ||\n    old_has_external_tokens != new_has_external_tokens ||\n    ts_subtree_has_changes(old_tree) ||\n    (\n      old_has_external_tokens &&\n      !ts_subtree_external_scanner_state_eq(old_iter->prev_external_token, new_iter->prev_external_token)\n    )\n  ) {\n    return IteratorMayDiffer;\n  }\n\n  return IteratorMatches;\n}\n\n#ifdef DEBUG_GET_CHANGED_RANGES\nstatic inline void iterator_print_state(Iterator *self) {\n  TreeCursorEntry entry = *array_back(&self->cursor.stack);\n  TSPoint start = iterator_start_position(self).extent;\n  TSPoint end = iterator_end_position(self).extent;\n  const char *name = ts_language_symbol_name(self->language, ts_subtree_symbol(*entry.subtree));\n  printf(\n    \"(%-25s %s\\t depth:%u [%u, %u] - [%u, %u])\",\n    name, self->in_padding ? \"(p)\" : \"   \",\n    self->visible_depth,\n    start.row, start.column,\n    end.row, end.column\n  );\n}\n#endif\n\nunsigned ts_subtree_get_changed_ranges(\n  const Subtree *old_tree, const Subtree *new_tree,\n  TreeCursor *cursor1, TreeCursor *cursor2,\n  const TSLanguage *language,\n  const TSRangeArray *included_range_differences,\n  TSRange **ranges\n) {\n  TSRangeArray results = array_new();\n\n  Iterator old_iter = iterator_new(cursor1, old_tree, language);\n  Iterator new_iter = iterator_new(cursor2, new_tree, language);\n\n  unsigned included_range_difference_index = 0;\n\n  Length position = iterator_start_position(&old_iter);\n  Length next_position = iterator_start_position(&new_iter);\n  if (position.bytes < next_position.bytes) {\n    ts_range_array_add(&results, position, next_position);\n    position = next_position;\n  } else if (position.bytes > next_position.bytes) {\n    ts_range_array_add(&results, next_position, position);\n    next_position = position;\n  }\n\n  do {\n    #ifdef DEBUG_GET_CHANGED_RANGES\n    printf(\"At [%-2u, %-2u] Compare \", position.extent.row, position.extent.column);\n    iterator_print_state(&old_iter);\n    printf(\"\\tvs\\t\");\n    iterator_print_state(&new_iter);\n    puts(\"\");\n    #endif\n\n    // Compare the old and new subtrees.\n    IteratorComparison comparison = iterator_compare(&old_iter, &new_iter);\n\n    // Even if the two subtrees appear to be identical, they could differ\n    // internally if they contain a range of text that was previously\n    // excluded from the parse, and is now included, or vice-versa.\n    if (comparison == IteratorMatches && ts_range_array_intersects(\n      included_range_differences,\n      included_range_difference_index,\n      position.bytes,\n      iterator_end_position(&old_iter).bytes\n    )) {\n      comparison = IteratorMayDiffer;\n    }\n\n    bool is_changed = false;\n    switch (comparison) {\n      // If the subtrees are definitely identical, move to the end\n      // of both subtrees.\n      case IteratorMatches:\n        next_position = iterator_end_position(&old_iter);\n        break;\n\n      // If the subtrees might differ internally, descend into both\n      // subtrees, finding the first child that spans the current position.\n      case IteratorMayDiffer:\n        if (iterator_descend(&old_iter, position.bytes)) {\n          if (!iterator_descend(&new_iter, position.bytes)) {\n            is_changed = true;\n            next_position = iterator_end_position(&old_iter);\n          }\n        } else if (iterator_descend(&new_iter, position.bytes)) {\n          is_changed = true;\n          next_position = iterator_end_position(&new_iter);\n        } else {\n          next_position = length_min(\n            iterator_end_position(&old_iter),\n            iterator_end_position(&new_iter)\n          );\n        }\n        break;\n\n      // If the subtrees are different, record a change and then move\n      // to the end of both subtrees.\n      case IteratorDiffers:\n        is_changed = true;\n        next_position = length_min(\n          iterator_end_position(&old_iter),\n          iterator_end_position(&new_iter)\n        );\n        break;\n    }\n\n    // Ensure that both iterators are caught up to the current position.\n    while (\n      !iterator_done(&old_iter) &&\n      iterator_end_position(&old_iter).bytes <= next_position.bytes\n    ) iterator_advance(&old_iter);\n    while (\n      !iterator_done(&new_iter) &&\n      iterator_end_position(&new_iter).bytes <= next_position.bytes\n    ) iterator_advance(&new_iter);\n\n    // Ensure that both iterators are at the same depth in the tree.\n    while (old_iter.visible_depth > new_iter.visible_depth) {\n      iterator_ascend(&old_iter);\n    }\n    while (new_iter.visible_depth > old_iter.visible_depth) {\n      iterator_ascend(&new_iter);\n    }\n\n    if (is_changed) {\n      #ifdef DEBUG_GET_CHANGED_RANGES\n      printf(\n        \"  change: [[%u, %u] - [%u, %u]]\\n\",\n        position.extent.row + 1, position.extent.column,\n        next_position.extent.row + 1, next_position.extent.column\n      );\n      #endif\n\n      ts_range_array_add(&results, position, next_position);\n    }\n\n    position = next_position;\n\n    // Keep track of the current position in the included range differences\n    // array in order to avoid scanning the entire array on each iteration.\n    while (included_range_difference_index < included_range_differences->size) {\n      const TSRange *range = array_get(included_range_differences,\n        included_range_difference_index\n      );\n      if (range->end_byte <= position.bytes) {\n        included_range_difference_index++;\n      } else {\n        break;\n      }\n    }\n  } while (!iterator_done(&old_iter) && !iterator_done(&new_iter));\n\n  Length old_size = ts_subtree_total_size(*old_tree);\n  Length new_size = ts_subtree_total_size(*new_tree);\n  if (old_size.bytes < new_size.bytes) {\n    ts_range_array_add(&results, old_size, new_size);\n  } else if (new_size.bytes < old_size.bytes) {\n    ts_range_array_add(&results, new_size, old_size);\n  }\n\n  *cursor1 = old_iter.cursor;\n  *cursor2 = new_iter.cursor;\n  *ranges = results.contents;\n  return results.size;\n}\n",
    "#ifndef TREE_SITTER_LENGTH_H_\n#define TREE_SITTER_LENGTH_H_\n\n#include <stdlib.h>\n#include <stdbool.h>\n#include \"./point.h\"\n#include \"tree_sitter/api.h\"\n\ntypedef struct {\n  uint32_t bytes;\n  TSPoint extent;\n} Length;\n\nstatic const Length LENGTH_UNDEFINED = {0, {0, 1}};\nstatic const Length LENGTH_MAX = {UINT32_MAX, {UINT32_MAX, UINT32_MAX}};\n\nstatic inline bool length_is_undefined(Length length) {\n  return length.bytes == 0 && length.extent.column != 0;\n}\n\nstatic inline Length length_min(Length len1, Length len2) {\n  return (len1.bytes < len2.bytes) ? len1 : len2;\n}\n\nstatic inline Length length_add(Length len1, Length len2) {\n  Length result;\n  result.bytes = len1.bytes + len2.bytes;\n  result.extent = point_add(len1.extent, len2.extent);\n  return result;\n}\n\nstatic inline Length length_sub(Length len1, Length len2) {\n  Length result;\n  result.bytes = (len1.bytes >= len2.bytes) ? len1.bytes - len2.bytes : 0;\n  result.extent = point_sub(len1.extent, len2.extent);\n  return result;\n}\n\nstatic inline Length length_zero(void) {\n  Length result = {0, {0, 0}};\n  return result;\n}\n\nstatic inline Length length_saturating_sub(Length len1, Length len2) {\n  if (len1.bytes > len2.bytes) {\n    return length_sub(len1, len2);\n  } else {\n    return length_zero();\n  }\n}\n\n#endif\n",
    "#ifndef TREE_SITTER_ARRAY_H_\n#define TREE_SITTER_ARRAY_H_\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include \"./alloc.h\"\n#include \"./ts_assert.h\"\n\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#ifdef _MSC_VER\n#pragma warning(push)\n#pragma warning(disable : 4101)\n#elif defined(__GNUC__) || defined(__clang__)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wunused-variable\"\n#endif\n\n#define Array(T)       \\\n  struct {             \\\n    T *contents;       \\\n    uint32_t size;     \\\n    uint32_t capacity; \\\n  }\n\n/// Initialize an array.\n#define array_init(self) \\\n  ((self)->size = 0, (self)->capacity = 0, (self)->contents = NULL)\n\n/// Create an empty array.\n#define array_new() \\\n  { NULL, 0, 0 }\n\n/// Get a pointer to the element at a given `index` in the array.\n#define array_get(self, _index) \\\n  (ts_assert((uint32_t)(_index) < (self)->size), &(self)->contents[_index])\n\n/// Get a pointer to the first element in the array.\n#define array_front(self) array_get(self, 0)\n\n/// Get a pointer to the last element in the array.\n#define array_back(self) array_get(self, (self)->size - 1)\n\n/// Clear the array, setting its size to zero. Note that this does not free any\n/// memory allocated for the array's contents.\n#define array_clear(self) ((self)->size = 0)\n\n/// Reserve `new_capacity` elements of space in the array. If `new_capacity` is\n/// less than the array's current capacity, this function has no effect.\n#define array_reserve(self, new_capacity) \\\n  _array__reserve((Array *)(self), array_elem_size(self), new_capacity)\n\n/// Free any memory allocated for this array. Note that this does not free any\n/// memory allocated for the array's contents.\n#define array_delete(self) _array__delete((Array *)(self))\n\n/// Push a new `element` onto the end of the array.\n#define array_push(self, element)                            \\\n  (_array__grow((Array *)(self), 1, array_elem_size(self)), \\\n   (self)->contents[(self)->size++] = (element))\n\n/// Increase the array's size by `count` elements.\n/// New elements are zero-initialized.\n#define array_grow_by(self, count) \\\n  do { \\\n    if ((count) == 0) break; \\\n    _array__grow((Array *)(self), count, array_elem_size(self)); \\\n    memset((self)->contents + (self)->size, 0, (count) * array_elem_size(self)); \\\n    (self)->size += (count); \\\n  } while (0)\n\n/// Append all elements from one array to the end of another.\n#define array_push_all(self, other)                                       \\\n  array_extend((self), (other)->size, (other)->contents)\n\n/// Append `count` elements to the end of the array, reading their values from the\n/// `contents` pointer.\n#define array_extend(self, count, contents)                    \\\n  _array__splice(                                               \\\n    (Array *)(self), array_elem_size(self), (self)->size, \\\n    0, count,  contents                                        \\\n  )\n\n/// Remove `old_count` elements from the array starting at the given `index`. At\n/// the same index, insert `new_count` new elements, reading their values from the\n/// `new_contents` pointer.\n#define array_splice(self, _index, old_count, new_count, new_contents)  \\\n  _array__splice(                                                       \\\n    (Array *)(self), array_elem_size(self), _index,                \\\n    old_count, new_count, new_contents                                 \\\n  )\n\n/// Insert one `element` into the array at the given `index`.\n#define array_insert(self, _index, element) \\\n  _array__splice((Array *)(self), array_elem_size(self), _index, 0, 1, &(element))\n\n/// Remove one element from the array at the given `index`.\n#define array_erase(self, _index) \\\n  _array__erase((Array *)(self), array_elem_size(self), _index)\n\n/// Pop the last element off the array, returning the element by value.\n#define array_pop(self) ((self)->contents[--(self)->size])\n\n/// Assign the contents of one array to another, reallocating if necessary.\n#define array_assign(self, other) \\\n  _array__assign((Array *)(self), (const Array *)(other), array_elem_size(self))\n\n/// Swap one array with another\n#define array_swap(self, other) \\\n  _array__swap((Array *)(self), (Array *)(other))\n\n/// Get the size of the array contents\n#define array_elem_size(self) (sizeof *(self)->contents)\n\n/// Search a sorted array for a given `needle` value, using the given `compare`\n/// callback to determine the order.\n///\n/// If an existing element is found to be equal to `needle`, then the `index`\n/// out-parameter is set to the existing value's index, and the `exists`\n/// out-parameter is set to true. Otherwise, `index` is set to an index where\n/// `needle` should be inserted in order to preserve the sorting, and `exists`\n/// is set to false.\n#define array_search_sorted_with(self, compare, needle, _index, _exists) \\\n  _array__search_sorted(self, 0, compare, , needle, _index, _exists)\n\n/// Search a sorted array for a given `needle` value, using integer comparisons\n/// of a given struct field (specified with a leading dot) to determine the order.\n///\n/// See also `array_search_sorted_with`.\n#define array_search_sorted_by(self, field, needle, _index, _exists) \\\n  _array__search_sorted(self, 0, _compare_int, field, needle, _index, _exists)\n\n/// Insert a given `value` into a sorted array, using the given `compare`\n/// callback to determine the order.\n#define array_insert_sorted_with(self, compare, value) \\\n  do { \\\n    unsigned _index, _exists; \\\n    array_search_sorted_with(self, compare, &(value), &_index, &_exists); \\\n    if (!_exists) array_insert(self, _index, value); \\\n  } while (0)\n\n/// Insert a given `value` into a sorted array, using integer comparisons of\n/// a given struct field (specified with a leading dot) to determine the order.\n///\n/// See also `array_search_sorted_by`.\n#define array_insert_sorted_by(self, field, value) \\\n  do { \\\n    unsigned _index, _exists; \\\n    array_search_sorted_by(self, field, (value) field, &_index, &_exists); \\\n    if (!_exists) array_insert(self, _index, value); \\\n  } while (0)\n\n// Private\n\ntypedef Array(void) Array;\n\n/// This is not what you're looking for, see `array_delete`.\nstatic inline void _array__delete(Array *self) {\n  if (self->contents) {\n    ts_free(self->contents);\n    self->contents = NULL;\n    self->size = 0;\n    self->capacity = 0;\n  }\n}\n\n/// This is not what you're looking for, see `array_erase`.\nstatic inline void _array__erase(Array *self, size_t element_size,\n                                uint32_t index) {\n  ts_assert(index < self->size);\n  char *contents = (char *)self->contents;\n  memmove(contents + index * element_size, contents + (index + 1) * element_size,\n          (self->size - index - 1) * element_size);\n  self->size--;\n}\n\n/// This is not what you're looking for, see `array_reserve`.\nstatic inline void _array__reserve(Array *self, size_t element_size, uint32_t new_capacity) {\n  if (new_capacity > self->capacity) {\n    if (self->contents) {\n      self->contents = ts_realloc(self->contents, new_capacity * element_size);\n    } else {\n      self->contents = ts_malloc(new_capacity * element_size);\n    }\n    self->capacity = new_capacity;\n  }\n}\n\n/// This is not what you're looking for, see `array_assign`.\nstatic inline void _array__assign(Array *self, const Array *other, size_t element_size) {\n  _array__reserve(self, element_size, other->size);\n  self->size = other->size;\n  memcpy(self->contents, other->contents, self->size * element_size);\n}\n\n/// This is not what you're looking for, see `array_swap`.\nstatic inline void _array__swap(Array *self, Array *other) {\n  Array swap = *other;\n  *other = *self;\n  *self = swap;\n}\n\n/// This is not what you're looking for, see `array_push` or `array_grow_by`.\nstatic inline void _array__grow(Array *self, uint32_t count, size_t element_size) {\n  uint32_t new_size = self->size + count;\n  if (new_size > self->capacity) {\n    uint32_t new_capacity = self->capacity * 2;\n    if (new_capacity < 8) new_capacity = 8;\n    if (new_capacity < new_size) new_capacity = new_size;\n    _array__reserve(self, element_size, new_capacity);\n  }\n}\n\n/// This is not what you're looking for, see `array_splice`.\nstatic inline void _array__splice(Array *self, size_t element_size,\n                                 uint32_t index, uint32_t old_count,\n                                 uint32_t new_count, const void *elements) {\n  uint32_t new_size = self->size + new_count - old_count;\n  uint32_t old_end = index + old_count;\n  uint32_t new_end = index + new_count;\n  ts_assert(old_end <= self->size);\n\n  _array__reserve(self, element_size, new_size);\n\n  char *contents = (char *)self->contents;\n  if (self->size > old_end) {\n    memmove(\n      contents + new_end * element_size,\n      contents + old_end * element_size,\n      (self->size - old_end) * element_size\n    );\n  }\n  if (new_count > 0) {\n    if (elements) {\n      memcpy(\n        (contents + index * element_size),\n        elements,\n        new_count * element_size\n      );\n    } else {\n      memset(\n        (contents + index * element_size),\n        0,\n        new_count * element_size\n      );\n    }\n  }\n  self->size += new_count - old_count;\n}\n\n/// A binary search routine, based on Rust's `std::slice::binary_search_by`.\n/// This is not what you're looking for, see `array_search_sorted_with` or `array_search_sorted_by`.\n#define _array__search_sorted(self, start, compare, suffix, needle, _index, _exists) \\\n  do { \\\n    *(_index) = start; \\\n    *(_exists) = false; \\\n    uint32_t size = (self)->size - *(_index); \\\n    if (size == 0) break; \\\n    int comparison; \\\n    while (size > 1) { \\\n      uint32_t half_size = size / 2; \\\n      uint32_t mid_index = *(_index) + half_size; \\\n      comparison = compare(&((self)->contents[mid_index] suffix), (needle)); \\\n      if (comparison <= 0) *(_index) = mid_index; \\\n      size -= half_size; \\\n    } \\\n    comparison = compare(&((self)->contents[*(_index)] suffix), (needle)); \\\n    if (comparison == 0) *(_exists) = true; \\\n    else if (comparison < 0) *(_index) += 1; \\\n  } while (0)\n\n/// Helper macro for the `_sorted_by` routines below. This takes the left (existing)\n/// parameter by reference in order to work with the generic sorting function above.\n#define _compare_int(a, b) ((int)*(a) - (int)(b))\n\n#ifdef _MSC_VER\n#pragma warning(pop)\n#elif defined(__GNUC__) || defined(__clang__)\n#pragma GCC diagnostic pop\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif  // TREE_SITTER_ARRAY_H_\n",
    "#ifndef TREE_SITTER_POINT_H_\n#define TREE_SITTER_POINT_H_\n\n#include \"tree_sitter/api.h\"\n\n#define POINT_ZERO ((TSPoint) {0, 0})\n#define POINT_MAX ((TSPoint) {UINT32_MAX, UINT32_MAX})\n\nstatic inline TSPoint point__new(unsigned row, unsigned column) {\n  TSPoint result = {row, column};\n  return result;\n}\n\nstatic inline TSPoint point_add(TSPoint a, TSPoint b) {\n  if (b.row > 0)\n    return point__new(a.row + b.row, b.column);\n  else\n    return point__new(a.row, a.column + b.column);\n}\n\nstatic inline TSPoint point_sub(TSPoint a, TSPoint b) {\n  if (a.row > b.row)\n    return point__new(a.row - b.row, a.column);\n  else\n    return point__new(0, (a.column >= b.column) ? a.column - b.column : 0);\n}\n\nstatic inline bool point_lte(TSPoint a, TSPoint b) {\n  return (a.row < b.row) || (a.row == b.row && a.column <= b.column);\n}\n\nstatic inline bool point_lt(TSPoint a, TSPoint b) {\n  return (a.row < b.row) || (a.row == b.row && a.column < b.column);\n}\n\nstatic inline bool point_gt(TSPoint a, TSPoint b) {\n  return (a.row > b.row) || (a.row == b.row && a.column > b.column);\n}\n\nstatic inline bool point_gte(TSPoint a, TSPoint b) {\n  return (a.row > b.row) || (a.row == b.row && a.column >= b.column);\n}\n\nstatic inline bool point_eq(TSPoint a, TSPoint b) {\n  return a.row == b.row && a.column == b.column;\n}\n\n#endif\n",
    "#ifndef TREE_SITTER_SUBTREE_H_\n#define TREE_SITTER_SUBTREE_H_\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <limits.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include \"./length.h\"\n#include \"./array.h\"\n#include \"./error_costs.h\"\n#include \"./host.h\"\n#include \"tree_sitter/api.h\"\n#include \"./parser.h\"\n\n#define TS_TREE_STATE_NONE USHRT_MAX\n#define NULL_SUBTREE ((Subtree) {.ptr = NULL})\n\n// The serialized state of an external scanner.\n//\n// Every time an external token subtree is created after a call to an\n// external scanner, the scanner's `serialize` function is called to\n// retrieve a serialized copy of its state. The bytes are then copied\n// onto the subtree itself so that the scanner's state can later be\n// restored using its `deserialize` function.\n//\n// Small byte arrays are stored inline, and long ones are allocated\n// separately on the heap.\ntypedef struct {\n  union {\n    char *long_data;\n    char short_data[24];\n  };\n  uint32_t length;\n} ExternalScannerState;\n\n// A compact representation of a subtree.\n//\n// This representation is used for small leaf nodes that are not\n// errors, and were not created by an external scanner.\n//\n// The idea behind the layout of this struct is that the `is_inline`\n// bit will fall exactly into the same location as the least significant\n// bit of the pointer in `Subtree` or `MutableSubtree`, respectively.\n// Because of alignment, for any valid pointer this will be 0, giving\n// us the opportunity to make use of this bit to signify whether to use\n// the pointer or the inline struct.\ntypedef struct SubtreeInlineData SubtreeInlineData;\n\n#define SUBTREE_BITS    \\\n  bool visible : 1;     \\\n  bool named : 1;       \\\n  bool extra : 1;       \\\n  bool has_changes : 1; \\\n  bool is_missing : 1;  \\\n  bool is_keyword : 1;\n\n#define SUBTREE_SIZE           \\\n  uint8_t padding_columns;     \\\n  uint8_t padding_rows : 4;    \\\n  uint8_t lookahead_bytes : 4; \\\n  uint8_t padding_bytes;       \\\n  uint8_t size_bytes;\n\n#if TS_BIG_ENDIAN\n#if TS_PTR_SIZE == 32\n\nstruct SubtreeInlineData {\n  uint16_t parse_state;\n  uint8_t symbol;\n  SUBTREE_BITS\n  bool unused : 1;\n  bool is_inline : 1;\n  SUBTREE_SIZE\n};\n\n#else\n\nstruct SubtreeInlineData {\n  SUBTREE_SIZE\n  uint16_t parse_state;\n  uint8_t symbol;\n  SUBTREE_BITS\n  bool unused : 1;\n  bool is_inline : 1;\n};\n\n#endif\n#else\n\nstruct SubtreeInlineData {\n  bool is_inline : 1;\n  SUBTREE_BITS\n  uint8_t symbol;\n  uint16_t parse_state;\n  SUBTREE_SIZE\n};\n\n#endif\n\n#undef SUBTREE_BITS\n#undef SUBTREE_SIZE\n\n// A heap-allocated representation of a subtree.\n//\n// This representation is used for parent nodes, external tokens,\n// errors, and other leaf nodes whose data is too large to fit into\n// the inline representation.\ntypedef struct {\n  volatile uint32_t ref_count;\n  Length padding;\n  Length size;\n  uint32_t lookahead_bytes;\n  uint32_t error_cost;\n  uint32_t child_count;\n  TSSymbol symbol;\n  TSStateId parse_state;\n\n  bool visible : 1;\n  bool named : 1;\n  bool extra : 1;\n  bool fragile_left : 1;\n  bool fragile_right : 1;\n  bool has_changes : 1;\n  bool has_external_tokens : 1;\n  bool has_external_scanner_state_change : 1;\n  bool depends_on_column: 1;\n  bool is_missing : 1;\n  bool is_keyword : 1;\n\n  union {\n    // Non-terminal subtrees (`child_count > 0`)\n    struct {\n      uint32_t visible_child_count;\n      uint32_t named_child_count;\n      uint32_t visible_descendant_count;\n      int32_t dynamic_precedence;\n      uint16_t repeat_depth;\n      uint16_t production_id;\n      struct {\n        TSSymbol symbol;\n        TSStateId parse_state;\n      } first_leaf;\n    };\n\n    // External terminal subtrees (`child_count == 0 && has_external_tokens`)\n    ExternalScannerState external_scanner_state;\n\n    // Error terminal subtrees (`child_count == 0 && symbol == ts_builtin_sym_error`)\n    int32_t lookahead_char;\n  };\n} SubtreeHeapData;\n\n// The fundamental building block of a syntax tree.\ntypedef union {\n  SubtreeInlineData data;\n  const SubtreeHeapData *ptr;\n} Subtree;\n\n// Like Subtree, but mutable.\ntypedef union {\n  SubtreeInlineData data;\n  SubtreeHeapData *ptr;\n} MutableSubtree;\n\ntypedef Array(Subtree) SubtreeArray;\ntypedef Array(MutableSubtree) MutableSubtreeArray;\n\ntypedef struct {\n  MutableSubtreeArray free_trees;\n  MutableSubtreeArray tree_stack;\n} SubtreePool;\n\nvoid ts_external_scanner_state_init(ExternalScannerState *self, const char *data, unsigned length);\nconst char *ts_external_scanner_state_data(const ExternalScannerState *self);\nbool ts_external_scanner_state_eq(const ExternalScannerState *self, const char *buffer, unsigned length);\nvoid ts_external_scanner_state_delete(ExternalScannerState *self);\n\nvoid ts_subtree_array_copy(SubtreeArray self, SubtreeArray *dest);\nvoid ts_subtree_array_clear(SubtreePool *pool, SubtreeArray *self);\nvoid ts_subtree_array_delete(SubtreePool *pool, SubtreeArray *self);\nvoid ts_subtree_array_remove_trailing_extras(SubtreeArray *self, SubtreeArray *destination);\nvoid ts_subtree_array_reverse(SubtreeArray *self);\n\nSubtreePool ts_subtree_pool_new(uint32_t capacity);\nvoid ts_subtree_pool_delete(SubtreePool *self);\n\nSubtree ts_subtree_new_leaf(\n  SubtreePool *pool, TSSymbol symbol, Length padding, Length size,\n  uint32_t lookahead_bytes, TSStateId parse_state,\n  bool has_external_tokens, bool depends_on_column,\n  bool is_keyword, const TSLanguage *language\n);\nSubtree ts_subtree_new_error(\n  SubtreePool *pool, int32_t lookahead_char, Length padding, Length size,\n  uint32_t bytes_scanned, TSStateId parse_state, const TSLanguage *language\n);\nMutableSubtree ts_subtree_new_node(\n  TSSymbol symbol,\n  SubtreeArray *chiildren,\n  unsigned production_id,\n  const TSLanguage *language\n);\nSubtree ts_subtree_new_error_node(\n  SubtreeArray *children,\n  bool extra,\n  const TSLanguage * language\n);\nSubtree ts_subtree_new_missing_leaf(\n  SubtreePool *pool,\n  TSSymbol symbol,\n  Length padding,\n  uint32_t lookahead_bytes,\n  const TSLanguage *language\n);\nMutableSubtree ts_subtree_make_mut(SubtreePool *pool, Subtree self);\nvoid ts_subtree_retain(Subtree self);\nvoid ts_subtree_release(SubtreePool *pool, Subtree self);\nint ts_subtree_compare(Subtree left, Subtree right, SubtreePool *pool);\nvoid ts_subtree_set_symbol(MutableSubtree *self, TSSymbol symbol, const TSLanguage *language);\nvoid ts_subtree_compress(MutableSubtree self, unsigned count, const TSLanguage *language, MutableSubtreeArray *stack);\nvoid ts_subtree_summarize_children(MutableSubtree self, const TSLanguage *language);\nSubtree ts_subtree_edit(Subtree self, const TSInputEdit *edit, SubtreePool *pool);\nchar *ts_subtree_string(Subtree self, TSSymbol alias_symbol, bool alias_is_named, const TSLanguage *language, bool include_all);\nvoid ts_subtree_print_dot_graph(Subtree self, const TSLanguage *language, FILE *f);\nSubtree ts_subtree_last_external_token(Subtree tree);\nconst ExternalScannerState *ts_subtree_external_scanner_state(Subtree self);\nbool ts_subtree_external_scanner_state_eq(Subtree self, Subtree other);\n\n#define SUBTREE_GET(self, name) ((self).data.is_inline ? (self).data.name : (self).ptr->name)\n\nstatic inline TSSymbol ts_subtree_symbol(Subtree self) { return SUBTREE_GET(self, symbol); }\nstatic inline bool ts_subtree_visible(Subtree self) { return SUBTREE_GET(self, visible); }\nstatic inline bool ts_subtree_named(Subtree self) { return SUBTREE_GET(self, named); }\nstatic inline bool ts_subtree_extra(Subtree self) { return SUBTREE_GET(self, extra); }\nstatic inline bool ts_subtree_has_changes(Subtree self) { return SUBTREE_GET(self, has_changes); }\nstatic inline bool ts_subtree_missing(Subtree self) { return SUBTREE_GET(self, is_missing); }\nstatic inline bool ts_subtree_is_keyword(Subtree self) { return SUBTREE_GET(self, is_keyword); }\nstatic inline TSStateId ts_subtree_parse_state(Subtree self) { return SUBTREE_GET(self, parse_state); }\nstatic inline uint32_t ts_subtree_lookahead_bytes(Subtree self) { return SUBTREE_GET(self, lookahead_bytes); }\n\n#undef SUBTREE_GET\n\n// Get the size needed to store a heap-allocated subtree with the given\n// number of children.\nstatic inline size_t ts_subtree_alloc_size(uint32_t child_count) {\n  return child_count * sizeof(Subtree) + sizeof(SubtreeHeapData);\n}\n\n// Get a subtree's children, which are allocated immediately before the\n// tree's own heap data.\n#define ts_subtree_children(self) \\\n  ((self).data.is_inline ? NULL : (Subtree *)((self).ptr) - (self).ptr->child_count)\n\nstatic inline void ts_subtree_set_extra(MutableSubtree *self, bool is_extra) {\n  if (self->data.is_inline) {\n    self->data.extra = is_extra;\n  } else {\n    self->ptr->extra = is_extra;\n  }\n}\n\nstatic inline TSSymbol ts_subtree_leaf_symbol(Subtree self) {\n  if (self.data.is_inline) return self.data.symbol;\n  if (self.ptr->child_count == 0) return self.ptr->symbol;\n  return self.ptr->first_leaf.symbol;\n}\n\nstatic inline TSStateId ts_subtree_leaf_parse_state(Subtree self) {\n  if (self.data.is_inline) return self.data.parse_state;\n  if (self.ptr->child_count == 0) return self.ptr->parse_state;\n  return self.ptr->first_leaf.parse_state;\n}\n\nstatic inline Length ts_subtree_padding(Subtree self) {\n  if (self.data.is_inline) {\n    Length result = {self.data.padding_bytes, {self.data.padding_rows, self.data.padding_columns}};\n    return result;\n  } else {\n    return self.ptr->padding;\n  }\n}\n\nstatic inline Length ts_subtree_size(Subtree self) {\n  if (self.data.is_inline) {\n    Length result = {self.data.size_bytes, {0, self.data.size_bytes}};\n    return result;\n  } else {\n    return self.ptr->size;\n  }\n}\n\nstatic inline Length ts_subtree_total_size(Subtree self) {\n  return length_add(ts_subtree_padding(self), ts_subtree_size(self));\n}\n\nstatic inline uint32_t ts_subtree_total_bytes(Subtree self) {\n  return ts_subtree_total_size(self).bytes;\n}\n\nstatic inline uint32_t ts_subtree_child_count(Subtree self) {\n  return self.data.is_inline ? 0 : self.ptr->child_count;\n}\n\nstatic inline uint32_t ts_subtree_repeat_depth(Subtree self) {\n  return self.data.is_inline ? 0 : self.ptr->repeat_depth;\n}\n\nstatic inline uint32_t ts_subtree_is_repetition(Subtree self) {\n  return self.data.is_inline\n    ? 0\n    : !self.ptr->named && !self.ptr->visible && self.ptr->child_count != 0;\n}\n\nstatic inline uint32_t ts_subtree_visible_descendant_count(Subtree self) {\n  return (self.data.is_inline || self.ptr->child_count == 0)\n    ? 0\n    : self.ptr->visible_descendant_count;\n}\n\nstatic inline uint32_t ts_subtree_visible_child_count(Subtree self) {\n  if (ts_subtree_child_count(self) > 0) {\n    return self.ptr->visible_child_count;\n  } else {\n    return 0;\n  }\n}\n\nstatic inline uint32_t ts_subtree_error_cost(Subtree self) {\n  if (ts_subtree_missing(self)) {\n    return ERROR_COST_PER_MISSING_TREE + ERROR_COST_PER_RECOVERY;\n  } else {\n    return self.data.is_inline ? 0 : self.ptr->error_cost;\n  }\n}\n\nstatic inline int32_t ts_subtree_dynamic_precedence(Subtree self) {\n  return (self.data.is_inline || self.ptr->child_count == 0) ? 0 : self.ptr->dynamic_precedence;\n}\n\nstatic inline uint16_t ts_subtree_production_id(Subtree self) {\n  if (ts_subtree_child_count(self) > 0) {\n    return self.ptr->production_id;\n  } else {\n    return 0;\n  }\n}\n\nstatic inline bool ts_subtree_fragile_left(Subtree self) {\n  return self.data.is_inline ? false : self.ptr->fragile_left;\n}\n\nstatic inline bool ts_subtree_fragile_right(Subtree self) {\n  return self.data.is_inline ? false : self.ptr->fragile_right;\n}\n\nstatic inline bool ts_subtree_has_external_tokens(Subtree self) {\n  return self.data.is_inline ? false : self.ptr->has_external_tokens;\n}\n\nstatic inline bool ts_subtree_has_external_scanner_state_change(Subtree self) {\n  return self.data.is_inline ? false : self.ptr->has_external_scanner_state_change;\n}\n\nstatic inline bool ts_subtree_depends_on_column(Subtree self) {\n  return self.data.is_inline ? false : self.ptr->depends_on_column;\n}\n\nstatic inline bool ts_subtree_is_fragile(Subtree self) {\n  return self.data.is_inline ? false : (self.ptr->fragile_left || self.ptr->fragile_right);\n}\n\nstatic inline bool ts_subtree_is_error(Subtree self) {\n  return ts_subtree_symbol(self) == ts_builtin_sym_error;\n}\n\nstatic inline bool ts_subtree_is_eof(Subtree self) {\n  return ts_subtree_symbol(self) == ts_builtin_sym_end;\n}\n\nstatic inline Subtree ts_subtree_from_mut(MutableSubtree self) {\n  Subtree result;\n  result.data = self.data;\n  return result;\n}\n\nstatic inline MutableSubtree ts_subtree_to_mut_unsafe(Subtree self) {\n  MutableSubtree result;\n  result.data = self.data;\n  return result;\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif  // TREE_SITTER_SUBTREE_H_\n",
    "#include <ctype.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n#include <stdio.h>\n#include \"./alloc.h\"\n#include \"./array.h\"\n#include \"./atomic.h\"\n#include \"./subtree.h\"\n#include \"./length.h\"\n#include \"./language.h\"\n#include \"./error_costs.h\"\n#include \"./ts_assert.h\"\n#include <stddef.h>\n\ntypedef struct {\n  Length start;\n  Length old_end;\n  Length new_end;\n} Edit;\n\n#define TS_MAX_INLINE_TREE_LENGTH UINT8_MAX\n#define TS_MAX_TREE_POOL_SIZE 32\n\n// ExternalScannerState\n\nvoid ts_external_scanner_state_init(ExternalScannerState *self, const char *data, unsigned length) {\n  self->length = length;\n  if (length > sizeof(self->short_data)) {\n    self->long_data = ts_malloc(length);\n    memcpy(self->long_data, data, length);\n  } else {\n    memcpy(self->short_data, data, length);\n  }\n}\n\nExternalScannerState ts_external_scanner_state_copy(const ExternalScannerState *self) {\n  ExternalScannerState result = *self;\n  if (self->length > sizeof(self->short_data)) {\n    result.long_data = ts_malloc(self->length);\n    memcpy(result.long_data, self->long_data, self->length);\n  }\n  return result;\n}\n\nvoid ts_external_scanner_state_delete(ExternalScannerState *self) {\n  if (self->length > sizeof(self->short_data)) {\n    ts_free(self->long_data);\n  }\n}\n\nconst char *ts_external_scanner_state_data(const ExternalScannerState *self) {\n  if (self->length > sizeof(self->short_data)) {\n    return self->long_data;\n  } else {\n    return self->short_data;\n  }\n}\n\nbool ts_external_scanner_state_eq(const ExternalScannerState *self, const char *buffer, unsigned length) {\n  return\n    self->length == length &&\n    memcmp(ts_external_scanner_state_data(self), buffer, length) == 0;\n}\n\n// SubtreeArray\n\nvoid ts_subtree_array_copy(SubtreeArray self, SubtreeArray *dest) {\n  dest->size = self.size;\n  dest->capacity = self.capacity;\n  dest->contents = self.contents;\n  if (self.capacity > 0) {\n    dest->contents = ts_calloc(self.capacity, sizeof(Subtree));\n    memcpy(dest->contents, self.contents, self.size * sizeof(Subtree));\n    for (uint32_t i = 0; i < self.size; i++) {\n      ts_subtree_retain(*array_get(dest, i));\n    }\n  }\n}\n\nvoid ts_subtree_array_clear(SubtreePool *pool, SubtreeArray *self) {\n  for (uint32_t i = 0; i < self->size; i++) {\n    ts_subtree_release(pool, *array_get(self, i));\n  }\n  array_clear(self);\n}\n\nvoid ts_subtree_array_delete(SubtreePool *pool, SubtreeArray *self) {\n  ts_subtree_array_clear(pool, self);\n  array_delete(self);\n}\n\nvoid ts_subtree_array_remove_trailing_extras(\n  SubtreeArray *self,\n  SubtreeArray *destination\n) {\n  array_clear(destination);\n  while (self->size > 0) {\n    Subtree last = *array_get(self, self->size - 1);\n    if (ts_subtree_extra(last)) {\n      self->size--;\n      array_push(destination, last);\n    } else {\n      break;\n    }\n  }\n  ts_subtree_array_reverse(destination);\n}\n\nvoid ts_subtree_array_reverse(SubtreeArray *self) {\n  for (uint32_t i = 0, limit = self->size / 2; i < limit; i++) {\n    size_t reverse_index = self->size - 1 - i;\n    Subtree swap = *array_get(self, i);\n    *array_get(self, i) = *array_get(self, reverse_index);\n    *array_get(self, reverse_index) = swap;\n  }\n}\n\n// SubtreePool\n\nSubtreePool ts_subtree_pool_new(uint32_t capacity) {\n  SubtreePool self = {array_new(), array_new()};\n  array_reserve(&self.free_trees, capacity);\n  return self;\n}\n\nvoid ts_subtree_pool_delete(SubtreePool *self) {\n  if (self->free_trees.contents) {\n    for (unsigned i = 0; i < self->free_trees.size; i++) {\n      ts_free(array_get(&self->free_trees, i)->ptr);\n    }\n    array_delete(&self->free_trees);\n  }\n  if (self->tree_stack.contents) array_delete(&self->tree_stack);\n}\n\nstatic SubtreeHeapData *ts_subtree_pool_allocate(SubtreePool *self) {\n  if (self->free_trees.size > 0) {\n    return array_pop(&self->free_trees).ptr;\n  } else {\n    return ts_malloc(sizeof(SubtreeHeapData));\n  }\n}\n\nstatic void ts_subtree_pool_free(SubtreePool *self, SubtreeHeapData *tree) {\n  if (self->free_trees.capacity > 0 && self->free_trees.size + 1 <= TS_MAX_TREE_POOL_SIZE) {\n    array_push(&self->free_trees, (MutableSubtree) {.ptr = tree});\n  } else {\n    ts_free(tree);\n  }\n}\n\n// Subtree\n\nstatic inline bool ts_subtree_can_inline(Length padding, Length size, uint32_t lookahead_bytes) {\n  return\n    padding.bytes < TS_MAX_INLINE_TREE_LENGTH &&\n    padding.extent.row < 16 &&\n    padding.extent.column < TS_MAX_INLINE_TREE_LENGTH &&\n    size.bytes < TS_MAX_INLINE_TREE_LENGTH &&\n    size.extent.row == 0 &&\n    size.extent.column < TS_MAX_INLINE_TREE_LENGTH &&\n    lookahead_bytes < 16;\n}\n\nSubtree ts_subtree_new_leaf(\n  SubtreePool *pool, TSSymbol symbol, Length padding, Length size,\n  uint32_t lookahead_bytes, TSStateId parse_state,\n  bool has_external_tokens, bool depends_on_column,\n  bool is_keyword, const TSLanguage *language\n) {\n  TSSymbolMetadata metadata = ts_language_symbol_metadata(language, symbol);\n  bool extra = symbol == ts_builtin_sym_end;\n\n  bool is_inline = (\n    symbol <= UINT8_MAX &&\n    !has_external_tokens &&\n    ts_subtree_can_inline(padding, size, lookahead_bytes)\n  );\n\n  if (is_inline) {\n    return (Subtree) {{\n      .parse_state = parse_state,\n      .symbol = symbol,\n      .padding_bytes = padding.bytes,\n      .padding_rows = padding.extent.row,\n      .padding_columns = padding.extent.column,\n      .size_bytes = size.bytes,\n      .lookahead_bytes = lookahead_bytes,\n      .visible = metadata.visible,\n      .named = metadata.named,\n      .extra = extra,\n      .has_changes = false,\n      .is_missing = false,\n      .is_keyword = is_keyword,\n      .is_inline = true,\n    }};\n  } else {\n    SubtreeHeapData *data = ts_subtree_pool_allocate(pool);\n    *data = (SubtreeHeapData) {\n      .ref_count = 1,\n      .padding = padding,\n      .size = size,\n      .lookahead_bytes = lookahead_bytes,\n      .error_cost = 0,\n      .child_count = 0,\n      .symbol = symbol,\n      .parse_state = parse_state,\n      .visible = metadata.visible,\n      .named = metadata.named,\n      .extra = extra,\n      .fragile_left = false,\n      .fragile_right = false,\n      .has_changes = false,\n      .has_external_tokens = has_external_tokens,\n      .has_external_scanner_state_change = false,\n      .depends_on_column = depends_on_column,\n      .is_missing = false,\n      .is_keyword = is_keyword,\n      {{.first_leaf = {.symbol = 0, .parse_state = 0}}}\n    };\n    return (Subtree) {.ptr = data};\n  }\n}\n\nvoid ts_subtree_set_symbol(\n  MutableSubtree *self,\n  TSSymbol symbol,\n  const TSLanguage *language\n) {\n  TSSymbolMetadata metadata = ts_language_symbol_metadata(language, symbol);\n  if (self->data.is_inline) {\n    ts_assert(symbol < UINT8_MAX);\n    self->data.symbol = symbol;\n    self->data.named = metadata.named;\n    self->data.visible = metadata.visible;\n  } else {\n    self->ptr->symbol = symbol;\n    self->ptr->named = metadata.named;\n    self->ptr->visible = metadata.visible;\n  }\n}\n\nSubtree ts_subtree_new_error(\n  SubtreePool *pool, int32_t lookahead_char, Length padding, Length size,\n  uint32_t bytes_scanned, TSStateId parse_state, const TSLanguage *language\n) {\n  Subtree result = ts_subtree_new_leaf(\n    pool, ts_builtin_sym_error, padding, size, bytes_scanned,\n    parse_state, false, false, false, language\n  );\n  SubtreeHeapData *data = (SubtreeHeapData *)result.ptr;\n  data->fragile_left = true;\n  data->fragile_right = true;\n  data->lookahead_char = lookahead_char;\n  return result;\n}\n\n// Clone a subtree.\nMutableSubtree ts_subtree_clone(Subtree self) {\n  size_t alloc_size = ts_subtree_alloc_size(self.ptr->child_count);\n  Subtree *new_children = ts_malloc(alloc_size);\n  Subtree *old_children = ts_subtree_children(self);\n  memcpy(new_children, old_children, alloc_size);\n  SubtreeHeapData *result = (SubtreeHeapData *)&new_children[self.ptr->child_count];\n  if (self.ptr->child_count > 0) {\n    for (uint32_t i = 0; i < self.ptr->child_count; i++) {\n      ts_subtree_retain(new_children[i]);\n    }\n  } else if (self.ptr->has_external_tokens) {\n    result->external_scanner_state = ts_external_scanner_state_copy(\n      &self.ptr->external_scanner_state\n    );\n  }\n  result->ref_count = 1;\n  return (MutableSubtree) {.ptr = result};\n}\n\n// Get mutable version of a subtree.\n//\n// This takes ownership of the subtree. If the subtree has only one owner,\n// this will directly convert it into a mutable version. Otherwise, it will\n// perform a copy.\nMutableSubtree ts_subtree_make_mut(SubtreePool *pool, Subtree self) {\n  if (self.data.is_inline) return (MutableSubtree) {self.data};\n  if (self.ptr->ref_count == 1) return ts_subtree_to_mut_unsafe(self);\n  MutableSubtree result = ts_subtree_clone(self);\n  ts_subtree_release(pool, self);\n  return result;\n}\n\nvoid ts_subtree_compress(\n  MutableSubtree self,\n  unsigned count,\n  const TSLanguage *language,\n  MutableSubtreeArray *stack\n) {\n  unsigned initial_stack_size = stack->size;\n\n  MutableSubtree tree = self;\n  TSSymbol symbol = tree.ptr->symbol;\n  for (unsigned i = 0; i < count; i++) {\n    if (tree.ptr->ref_count > 1 || tree.ptr->child_count < 2) break;\n\n    MutableSubtree child = ts_subtree_to_mut_unsafe(ts_subtree_children(tree)[0]);\n    if (\n      child.data.is_inline ||\n      child.ptr->child_count < 2 ||\n      child.ptr->ref_count > 1 ||\n      child.ptr->symbol != symbol\n    ) break;\n\n    MutableSubtree grandchild = ts_subtree_to_mut_unsafe(ts_subtree_children(child)[0]);\n    if (\n      grandchild.data.is_inline ||\n      grandchild.ptr->child_count < 2 ||\n      grandchild.ptr->ref_count > 1 ||\n      grandchild.ptr->symbol != symbol\n    ) break;\n\n    ts_subtree_children(tree)[0] = ts_subtree_from_mut(grandchild);\n    ts_subtree_children(child)[0] = ts_subtree_children(grandchild)[grandchild.ptr->child_count - 1];\n    ts_subtree_children(grandchild)[grandchild.ptr->child_count - 1] = ts_subtree_from_mut(child);\n    array_push(stack, tree);\n    tree = grandchild;\n  }\n\n  while (stack->size > initial_stack_size) {\n    tree = array_pop(stack);\n    MutableSubtree child = ts_subtree_to_mut_unsafe(ts_subtree_children(tree)[0]);\n    MutableSubtree grandchild = ts_subtree_to_mut_unsafe(ts_subtree_children(child)[child.ptr->child_count - 1]);\n    ts_subtree_summarize_children(grandchild, language);\n    ts_subtree_summarize_children(child, language);\n    ts_subtree_summarize_children(tree, language);\n  }\n}\n\n// Assign all of the node's properties that depend on its children.\nvoid ts_subtree_summarize_children(\n  MutableSubtree self,\n  const TSLanguage *language\n) {\n  ts_assert(!self.data.is_inline);\n\n  self.ptr->named_child_count = 0;\n  self.ptr->visible_child_count = 0;\n  self.ptr->error_cost = 0;\n  self.ptr->repeat_depth = 0;\n  self.ptr->visible_descendant_count = 0;\n  self.ptr->has_external_tokens = false;\n  self.ptr->depends_on_column = false;\n  self.ptr->has_external_scanner_state_change = false;\n  self.ptr->dynamic_precedence = 0;\n\n  uint32_t structural_index = 0;\n  const TSSymbol *alias_sequence = ts_language_alias_sequence(language, self.ptr->production_id);\n  uint32_t lookahead_end_byte = 0;\n\n  const Subtree *children = ts_subtree_children(self);\n  for (uint32_t i = 0; i < self.ptr->child_count; i++) {\n    Subtree child = children[i];\n\n    if (\n      self.ptr->size.extent.row == 0 &&\n      ts_subtree_depends_on_column(child)\n    ) {\n      self.ptr->depends_on_column = true;\n    }\n\n    if (ts_subtree_has_external_scanner_state_change(child)) {\n      self.ptr->has_external_scanner_state_change = true;\n    }\n\n    if (i == 0) {\n      self.ptr->padding = ts_subtree_padding(child);\n      self.ptr->size = ts_subtree_size(child);\n    } else {\n      self.ptr->size = length_add(self.ptr->size, ts_subtree_total_size(child));\n    }\n\n    uint32_t child_lookahead_end_byte =\n      self.ptr->padding.bytes +\n      self.ptr->size.bytes +\n      ts_subtree_lookahead_bytes(child);\n    if (child_lookahead_end_byte > lookahead_end_byte) {\n      lookahead_end_byte = child_lookahead_end_byte;\n    }\n\n    if (ts_subtree_symbol(child) != ts_builtin_sym_error_repeat) {\n      self.ptr->error_cost += ts_subtree_error_cost(child);\n    }\n\n    uint32_t grandchild_count = ts_subtree_child_count(child);\n    if (\n      self.ptr->symbol == ts_builtin_sym_error ||\n      self.ptr->symbol == ts_builtin_sym_error_repeat\n    ) {\n      if (!ts_subtree_extra(child) && !(ts_subtree_is_error(child) && grandchild_count == 0)) {\n        if (ts_subtree_visible(child)) {\n          self.ptr->error_cost += ERROR_COST_PER_SKIPPED_TREE;\n        } else if (grandchild_count > 0) {\n          self.ptr->error_cost += ERROR_COST_PER_SKIPPED_TREE * child.ptr->visible_child_count;\n        }\n      }\n    }\n\n    self.ptr->dynamic_precedence += ts_subtree_dynamic_precedence(child);\n    self.ptr->visible_descendant_count += ts_subtree_visible_descendant_count(child);\n\n    if (\n      !ts_subtree_extra(child) &&\n      ts_subtree_symbol(child) != 0 &&\n      alias_sequence &&\n      alias_sequence[structural_index] != 0\n    ) {\n      self.ptr->visible_descendant_count++;\n      self.ptr->visible_child_count++;\n      if (ts_language_symbol_metadata(language, alias_sequence[structural_index]).named) {\n        self.ptr->named_child_count++;\n      }\n    } else if (ts_subtree_visible(child)) {\n      self.ptr->visible_descendant_count++;\n      self.ptr->visible_child_count++;\n      if (ts_subtree_named(child)) self.ptr->named_child_count++;\n    } else if (grandchild_count > 0) {\n      self.ptr->visible_child_count += child.ptr->visible_child_count;\n      self.ptr->named_child_count += child.ptr->named_child_count;\n    }\n\n    if (ts_subtree_has_external_tokens(child)) self.ptr->has_external_tokens = true;\n\n    if (ts_subtree_is_error(child)) {\n      self.ptr->fragile_left = self.ptr->fragile_right = true;\n      self.ptr->parse_state = TS_TREE_STATE_NONE;\n    }\n\n    if (!ts_subtree_extra(child)) structural_index++;\n  }\n\n  self.ptr->lookahead_bytes = lookahead_end_byte - self.ptr->size.bytes - self.ptr->padding.bytes;\n\n  if (\n    self.ptr->symbol == ts_builtin_sym_error ||\n    self.ptr->symbol == ts_builtin_sym_error_repeat\n  ) {\n    self.ptr->error_cost +=\n      ERROR_COST_PER_RECOVERY +\n      ERROR_COST_PER_SKIPPED_CHAR * self.ptr->size.bytes +\n      ERROR_COST_PER_SKIPPED_LINE * self.ptr->size.extent.row;\n  }\n\n  if (self.ptr->child_count > 0) {\n    Subtree first_child = children[0];\n    Subtree last_child = children[self.ptr->child_count - 1];\n\n    self.ptr->first_leaf.symbol = ts_subtree_leaf_symbol(first_child);\n    self.ptr->first_leaf.parse_state = ts_subtree_leaf_parse_state(first_child);\n\n    if (ts_subtree_fragile_left(first_child)) self.ptr->fragile_left = true;\n    if (ts_subtree_fragile_right(last_child)) self.ptr->fragile_right = true;\n\n    if (\n      self.ptr->child_count >= 2 &&\n      !self.ptr->visible &&\n      !self.ptr->named &&\n      ts_subtree_symbol(first_child) == self.ptr->symbol\n    ) {\n      if (ts_subtree_repeat_depth(first_child) > ts_subtree_repeat_depth(last_child)) {\n        self.ptr->repeat_depth = ts_subtree_repeat_depth(first_child) + 1;\n      } else {\n        self.ptr->repeat_depth = ts_subtree_repeat_depth(last_child) + 1;\n      }\n    }\n  }\n}\n\n// Create a new parent node with the given children.\n//\n// This takes ownership of the children array.\nMutableSubtree ts_subtree_new_node(\n  TSSymbol symbol,\n  SubtreeArray *children,\n  unsigned production_id,\n  const TSLanguage *language\n) {\n  TSSymbolMetadata metadata = ts_language_symbol_metadata(language, symbol);\n  bool fragile = symbol == ts_builtin_sym_error || symbol == ts_builtin_sym_error_repeat;\n\n  // Allocate the node's data at the end of the array of children.\n  size_t new_byte_size = ts_subtree_alloc_size(children->size);\n  if (children->capacity * sizeof(Subtree) < new_byte_size) {\n    children->contents = ts_realloc(children->contents, new_byte_size);\n    children->capacity = (uint32_t)(new_byte_size / sizeof(Subtree));\n  }\n  SubtreeHeapData *data = (SubtreeHeapData *)&children->contents[children->size];\n\n  *data = (SubtreeHeapData) {\n    .ref_count = 1,\n    .symbol = symbol,\n    .child_count = children->size,\n    .visible = metadata.visible,\n    .named = metadata.named,\n    .has_changes = false,\n    .has_external_scanner_state_change = false,\n    .fragile_left = fragile,\n    .fragile_right = fragile,\n    .is_keyword = false,\n    {{\n      .visible_descendant_count = 0,\n      .production_id = production_id,\n      .first_leaf = {.symbol = 0, .parse_state = 0},\n    }}\n  };\n  MutableSubtree result = {.ptr = data};\n  ts_subtree_summarize_children(result, language);\n  return result;\n}\n\n// Create a new error node containing the given children.\n//\n// This node is treated as 'extra'. Its children are prevented from having\n// having any effect on the parse state.\nSubtree ts_subtree_new_error_node(\n  SubtreeArray *children,\n  bool extra,\n  const TSLanguage *language\n) {\n  MutableSubtree result = ts_subtree_new_node(\n    ts_builtin_sym_error, children, 0, language\n  );\n  result.ptr->extra = extra;\n  return ts_subtree_from_mut(result);\n}\n\n// Create a new 'missing leaf' node.\n//\n// This node is treated as 'extra'. Its children are prevented from having\n// having any effect on the parse state.\nSubtree ts_subtree_new_missing_leaf(\n  SubtreePool *pool,\n  TSSymbol symbol,\n  Length padding,\n  uint32_t lookahead_bytes,\n  const TSLanguage *language\n) {\n  Subtree result = ts_subtree_new_leaf(\n    pool, symbol, padding, length_zero(), lookahead_bytes,\n    0, false, false, false, language\n  );\n  if (result.data.is_inline) {\n    result.data.is_missing = true;\n  } else {\n    ((SubtreeHeapData *)result.ptr)->is_missing = true;\n  }\n  return result;\n}\n\nvoid ts_subtree_retain(Subtree self) {\n  if (self.data.is_inline) return;\n  ts_assert(self.ptr->ref_count > 0);\n  atomic_inc((volatile uint32_t *)&self.ptr->ref_count);\n  ts_assert(self.ptr->ref_count != 0);\n}\n\nvoid ts_subtree_release(SubtreePool *pool, Subtree self) {\n  if (self.data.is_inline) return;\n  array_clear(&pool->tree_stack);\n\n  ts_assert(self.ptr->ref_count > 0);\n  if (atomic_dec((volatile uint32_t *)&self.ptr->ref_count) == 0) {\n    array_push(&pool->tree_stack, ts_subtree_to_mut_unsafe(self));\n  }\n\n  while (pool->tree_stack.size > 0) {\n    MutableSubtree tree = array_pop(&pool->tree_stack);\n    if (tree.ptr->child_count > 0) {\n      Subtree *children = ts_subtree_children(tree);\n      for (uint32_t i = 0; i < tree.ptr->child_count; i++) {\n        Subtree child = children[i];\n        if (child.data.is_inline) continue;\n        ts_assert(child.ptr->ref_count > 0);\n        if (atomic_dec((volatile uint32_t *)&child.ptr->ref_count) == 0) {\n          array_push(&pool->tree_stack, ts_subtree_to_mut_unsafe(child));\n        }\n      }\n      ts_free(children);\n    } else {\n      if (tree.ptr->has_external_tokens) {\n        ts_external_scanner_state_delete(&tree.ptr->external_scanner_state);\n      }\n      ts_subtree_pool_free(pool, tree.ptr);\n    }\n  }\n}\n\nint ts_subtree_compare(Subtree left, Subtree right, SubtreePool *pool) {\n  array_push(&pool->tree_stack, ts_subtree_to_mut_unsafe(left));\n  array_push(&pool->tree_stack, ts_subtree_to_mut_unsafe(right));\n\n  while (pool->tree_stack.size > 0) {\n    right = ts_subtree_from_mut(array_pop(&pool->tree_stack));\n    left = ts_subtree_from_mut(array_pop(&pool->tree_stack));\n\n    int result = 0;\n    if (ts_subtree_symbol(left) < ts_subtree_symbol(right)) result = -1;\n    else if (ts_subtree_symbol(right) < ts_subtree_symbol(left)) result = 1;\n    else if (ts_subtree_child_count(left) < ts_subtree_child_count(right)) result = -1;\n    else if (ts_subtree_child_count(right) < ts_subtree_child_count(left)) result = 1;\n    if (result != 0) {\n      array_clear(&pool->tree_stack);\n      return result;\n    }\n\n    for (uint32_t i = ts_subtree_child_count(left); i > 0; i--) {\n      Subtree left_child = ts_subtree_children(left)[i - 1];\n      Subtree right_child = ts_subtree_children(right)[i - 1];\n      array_push(&pool->tree_stack, ts_subtree_to_mut_unsafe(left_child));\n      array_push(&pool->tree_stack, ts_subtree_to_mut_unsafe(right_child));\n    }\n  }\n\n  return 0;\n}\n\nstatic inline void ts_subtree_set_has_changes(MutableSubtree *self) {\n  if (self->data.is_inline) {\n    self->data.has_changes = true;\n  } else {\n    self->ptr->has_changes = true;\n  }\n}\n\nSubtree ts_subtree_edit(Subtree self, const TSInputEdit *input_edit, SubtreePool *pool) {\n  typedef struct {\n    Subtree *tree;\n    Edit edit;\n  } EditEntry;\n\n  Array(EditEntry) stack = array_new();\n  array_push(&stack, ((EditEntry) {\n    .tree = &self,\n    .edit = (Edit) {\n      .start = {input_edit->start_byte, input_edit->start_point},\n      .old_end = {input_edit->old_end_byte, input_edit->old_end_point},\n      .new_end = {input_edit->new_end_byte, input_edit->new_end_point},\n    },\n  }));\n\n  while (stack.size) {\n    EditEntry entry = array_pop(&stack);\n    Edit edit = entry.edit;\n    bool is_noop = edit.old_end.bytes == edit.start.bytes && edit.new_end.bytes == edit.start.bytes;\n    bool is_pure_insertion = edit.old_end.bytes == edit.start.bytes;\n    bool parent_depends_on_column = ts_subtree_depends_on_column(*entry.tree);\n    bool column_shifted = edit.new_end.extent.column != edit.old_end.extent.column;\n\n    Length size = ts_subtree_size(*entry.tree);\n    Length padding = ts_subtree_padding(*entry.tree);\n    Length total_size = length_add(padding, size);\n    uint32_t lookahead_bytes = ts_subtree_lookahead_bytes(*entry.tree);\n    uint32_t end_byte = total_size.bytes + lookahead_bytes;\n    if (edit.start.bytes > end_byte || (is_noop && edit.start.bytes == end_byte)) continue;\n\n    // If the edit is entirely within the space before this subtree, then shift this\n    // subtree over according to the edit without changing its size.\n    if (edit.old_end.bytes <= padding.bytes) {\n      padding = length_add(edit.new_end, length_sub(padding, edit.old_end));\n    }\n\n    // If the edit starts in the space before this subtree and extends into this subtree,\n    // shrink the subtree's content to compensate for the change in the space before it.\n    else if (edit.start.bytes < padding.bytes) {\n      size = length_saturating_sub(size, length_sub(edit.old_end, padding));\n      padding = edit.new_end;\n    }\n\n    // If the edit is within this subtree, resize the subtree to reflect the edit.\n    else if (\n      edit.start.bytes < total_size.bytes ||\n      (edit.start.bytes == total_size.bytes && is_pure_insertion)\n    ) {\n      size = length_add(\n        length_sub(edit.new_end, padding),\n        length_saturating_sub(total_size, edit.old_end)\n      );\n    }\n\n    MutableSubtree result = ts_subtree_make_mut(pool, *entry.tree);\n\n    if (result.data.is_inline) {\n      if (ts_subtree_can_inline(padding, size, lookahead_bytes)) {\n        result.data.padding_bytes = padding.bytes;\n        result.data.padding_rows = padding.extent.row;\n        result.data.padding_columns = padding.extent.column;\n        result.data.size_bytes = size.bytes;\n      } else {\n        SubtreeHeapData *data = ts_subtree_pool_allocate(pool);\n        data->ref_count = 1;\n        data->padding = padding;\n        data->size = size;\n        data->lookahead_bytes = lookahead_bytes;\n        data->error_cost = 0;\n        data->child_count = 0;\n        data->symbol = result.data.symbol;\n        data->parse_state = result.data.parse_state;\n        data->visible = result.data.visible;\n        data->named = result.data.named;\n        data->extra = result.data.extra;\n        data->fragile_left = false;\n        data->fragile_right = false;\n        data->has_changes = false;\n        data->has_external_tokens = false;\n        data->depends_on_column = false;\n        data->is_missing = result.data.is_missing;\n        data->is_keyword = result.data.is_keyword;\n        result.ptr = data;\n      }\n    } else {\n      result.ptr->padding = padding;\n      result.ptr->size = size;\n    }\n\n    ts_subtree_set_has_changes(&result);\n    *entry.tree = ts_subtree_from_mut(result);\n\n    Length child_left, child_right = length_zero();\n    for (uint32_t i = 0, n = ts_subtree_child_count(*entry.tree); i < n; i++) {\n      Subtree *child = &ts_subtree_children(*entry.tree)[i];\n      Length child_size = ts_subtree_total_size(*child);\n      child_left = child_right;\n      child_right = length_add(child_left, child_size);\n\n      // If this child ends before the edit, it is not affected.\n      if (child_right.bytes + ts_subtree_lookahead_bytes(*child) < edit.start.bytes) continue;\n\n      // Keep editing child nodes until a node is reached that starts after the edit.\n      // Also, if this node's validity depends on its column position, then continue\n      // invalidating child nodes until reaching a line break.\n      if ((\n        (child_left.bytes > edit.old_end.bytes) ||\n        (child_left.bytes == edit.old_end.bytes && child_size.bytes > 0 && i > 0)\n      ) && (\n        !parent_depends_on_column ||\n        child_left.extent.row > padding.extent.row\n      ) && (\n        !ts_subtree_depends_on_column(*child) ||\n        !column_shifted ||\n        child_left.extent.row > edit.old_end.extent.row\n      )) {\n        break;\n      }\n\n      // Transform edit into the child's coordinate space.\n      Edit child_edit = {\n        .start = length_saturating_sub(edit.start, child_left),\n        .old_end = length_saturating_sub(edit.old_end, child_left),\n        .new_end = length_saturating_sub(edit.new_end, child_left),\n      };\n\n      // Interpret all inserted text as applying to the *first* child that touches the edit.\n      // Subsequent children are only never have any text inserted into them; they are only\n      // shrunk to compensate for the edit.\n      if (\n        child_right.bytes > edit.start.bytes ||\n        (child_right.bytes == edit.start.bytes && is_pure_insertion)\n      ) {\n        edit.new_end = edit.start;\n      }\n\n      // Children that occur before the edit are not reshaped by the edit.\n      else {\n        child_edit.old_end = child_edit.start;\n        child_edit.new_end = child_edit.start;\n      }\n\n      // Queue processing of this child's subtree.\n      array_push(&stack, ((EditEntry) {\n        .tree = child,\n        .edit = child_edit,\n      }));\n    }\n  }\n\n  array_delete(&stack);\n  return self;\n}\n\nSubtree ts_subtree_last_external_token(Subtree tree) {\n  if (!ts_subtree_has_external_tokens(tree)) return NULL_SUBTREE;\n  while (tree.ptr->child_count > 0) {\n    for (uint32_t i = tree.ptr->child_count - 1; i + 1 > 0; i--) {\n      Subtree child = ts_subtree_children(tree)[i];\n      if (ts_subtree_has_external_tokens(child)) {\n        tree = child;\n        break;\n      }\n    }\n  }\n  return tree;\n}\n\nstatic size_t ts_subtree__write_char_to_string(char *str, size_t n, int32_t chr) {\n  if (chr == -1)\n    return snprintf(str, n, \"INVALID\");\n  else if (chr == '\\0')\n    return snprintf(str, n, \"'\\\\0'\");\n  else if (chr == '\\n')\n    return snprintf(str, n, \"'\\\\n'\");\n  else if (chr == '\\t')\n    return snprintf(str, n, \"'\\\\t'\");\n  else if (chr == '\\r')\n    return snprintf(str, n, \"'\\\\r'\");\n  else if (0 < chr && chr < 128 && isprint(chr))\n    return snprintf(str, n, \"'%c'\", chr);\n  else\n    return snprintf(str, n, \"%d\", chr);\n}\n\nstatic const char *const ROOT_FIELD = \"__ROOT__\";\n\nstatic size_t ts_subtree__write_to_string(\n  Subtree self, char *string, size_t limit,\n  const TSLanguage *language, bool include_all,\n  TSSymbol alias_symbol, bool alias_is_named, const char *field_name\n) {\n  if (!self.ptr) return snprintf(string, limit, \"(NULL)\");\n\n  char *cursor = string;\n  char **writer = (limit > 1) ? &cursor : &string;\n  bool is_root = field_name == ROOT_FIELD;\n  bool is_visible =\n    include_all ||\n    ts_subtree_missing(self) ||\n    (\n      alias_symbol\n        ? alias_is_named\n        : ts_subtree_visible(self) && ts_subtree_named(self)\n    );\n\n  if (is_visible) {\n    if (!is_root) {\n      cursor += snprintf(*writer, limit, \" \");\n      if (field_name) {\n        cursor += snprintf(*writer, limit, \"%s: \", field_name);\n      }\n    }\n\n    if (ts_subtree_is_error(self) && ts_subtree_child_count(self) == 0 && self.ptr->size.bytes > 0) {\n      cursor += snprintf(*writer, limit, \"(UNEXPECTED \");\n      cursor += ts_subtree__write_char_to_string(*writer, limit, self.ptr->lookahead_char);\n    } else {\n      TSSymbol symbol = alias_symbol ? alias_symbol : ts_subtree_symbol(self);\n      const char *symbol_name = ts_language_symbol_name(language, symbol);\n      if (ts_subtree_missing(self)) {\n        cursor += snprintf(*writer, limit, \"(MISSING \");\n        if (alias_is_named || ts_subtree_named(self)) {\n          cursor += snprintf(*writer, limit, \"%s\", symbol_name);\n        } else {\n          cursor += snprintf(*writer, limit, \"\\\"%s\\\"\", symbol_name);\n        }\n      } else {\n        cursor += snprintf(*writer, limit, \"(%s\", symbol_name);\n      }\n    }\n  } else if (is_root) {\n    TSSymbol symbol = alias_symbol ? alias_symbol : ts_subtree_symbol(self);\n    const char *symbol_name = ts_language_symbol_name(language, symbol);\n    if (ts_subtree_child_count(self) > 0) {\n      cursor += snprintf(*writer, limit, \"(%s\", symbol_name);\n    } else if (ts_subtree_named(self)) {\n      cursor += snprintf(*writer, limit, \"(%s)\", symbol_name);\n    } else {\n      cursor += snprintf(*writer, limit, \"(\\\"%s\\\")\", symbol_name);\n    }\n  }\n\n  if (ts_subtree_child_count(self)) {\n    const TSSymbol *alias_sequence = ts_language_alias_sequence(language, self.ptr->production_id);\n    const TSFieldMapEntry *field_map, *field_map_end;\n    ts_language_field_map(\n      language,\n      self.ptr->production_id,\n      &field_map,\n      &field_map_end\n    );\n\n    uint32_t structural_child_index = 0;\n    for (uint32_t i = 0; i < self.ptr->child_count; i++) {\n      Subtree child = ts_subtree_children(self)[i];\n      if (ts_subtree_extra(child)) {\n        cursor += ts_subtree__write_to_string(\n          child, *writer, limit,\n          language, include_all,\n          0, false, NULL\n        );\n      } else {\n        TSSymbol subtree_alias_symbol = alias_sequence\n          ? alias_sequence[structural_child_index]\n          : 0;\n        bool subtree_alias_is_named = subtree_alias_symbol\n          ? ts_language_symbol_metadata(language, subtree_alias_symbol).named\n          : false;\n\n        const char *child_field_name = is_visible ? NULL : field_name;\n        for (const TSFieldMapEntry *map = field_map; map < field_map_end; map++) {\n          if (!map->inherited && map->child_index == structural_child_index) {\n            child_field_name = language->field_names[map->field_id];\n            break;\n          }\n        }\n\n        cursor += ts_subtree__write_to_string(\n          child, *writer, limit,\n          language, include_all,\n          subtree_alias_symbol, subtree_alias_is_named, child_field_name\n        );\n        structural_child_index++;\n      }\n    }\n  }\n\n  if (is_visible) cursor += snprintf(*writer, limit, \")\");\n\n  return cursor - string;\n}\n\nchar *ts_subtree_string(\n  Subtree self,\n  TSSymbol alias_symbol,\n  bool alias_is_named,\n  const TSLanguage *language,\n  bool include_all\n) {\n  char scratch_string[1];\n  size_t size = ts_subtree__write_to_string(\n    self, scratch_string, 1,\n    language, include_all,\n    alias_symbol, alias_is_named, ROOT_FIELD\n  ) + 1;\n  char *result = ts_malloc(size * sizeof(char));\n  ts_subtree__write_to_string(\n    self, result, size,\n    language, include_all,\n    alias_symbol, alias_is_named, ROOT_FIELD\n  );\n  return result;\n}\n\nvoid ts_subtree__print_dot_graph(const Subtree *self, uint32_t start_offset,\n                                 const TSLanguage *language, TSSymbol alias_symbol,\n                                 FILE *f) {\n  TSSymbol subtree_symbol = ts_subtree_symbol(*self);\n  TSSymbol symbol = alias_symbol ? alias_symbol : subtree_symbol;\n  uint32_t end_offset = start_offset + ts_subtree_total_bytes(*self);\n  fprintf(f, \"tree_%p [label=\\\"\", (void *)self);\n  ts_language_write_symbol_as_dot_string(language, f, symbol);\n  fprintf(f, \"\\\"\");\n\n  if (ts_subtree_child_count(*self) == 0) fprintf(f, \", shape=plaintext\");\n  if (ts_subtree_extra(*self)) fprintf(f, \", fontcolor=gray\");\n  if (ts_subtree_has_changes(*self)) fprintf(f, \", color=green, penwidth=2\");\n\n  fprintf(f, \", tooltip=\\\"\"\n    \"range: %u - %u\\n\"\n    \"state: %d\\n\"\n    \"error-cost: %u\\n\"\n    \"has-changes: %u\\n\"\n    \"depends-on-column: %u\\n\"\n    \"descendant-count: %u\\n\"\n    \"repeat-depth: %u\\n\"\n    \"lookahead-bytes: %u\",\n    start_offset, end_offset,\n    ts_subtree_parse_state(*self),\n    ts_subtree_error_cost(*self),\n    ts_subtree_has_changes(*self),\n    ts_subtree_depends_on_column(*self),\n    ts_subtree_visible_descendant_count(*self),\n    ts_subtree_repeat_depth(*self),\n    ts_subtree_lookahead_bytes(*self)\n  );\n\n  if (ts_subtree_is_error(*self) && ts_subtree_child_count(*self) == 0 && self->ptr->lookahead_char != 0) {\n    fprintf(f, \"\\ncharacter: '%c'\", self->ptr->lookahead_char);\n  }\n\n  fprintf(f, \"\\\"]\\n\");\n\n  uint32_t child_start_offset = start_offset;\n  uint32_t child_info_offset =\n    language->max_alias_sequence_length *\n    ts_subtree_production_id(*self);\n  for (uint32_t i = 0, n = ts_subtree_child_count(*self); i < n; i++) {\n    const Subtree *child = &ts_subtree_children(*self)[i];\n    TSSymbol subtree_alias_symbol = 0;\n    if (!ts_subtree_extra(*child) && child_info_offset) {\n      subtree_alias_symbol = language->alias_sequences[child_info_offset];\n      child_info_offset++;\n    }\n    ts_subtree__print_dot_graph(child, child_start_offset, language, subtree_alias_symbol, f);\n    fprintf(f, \"tree_%p -> tree_%p [tooltip=%u]\\n\", (void *)self, (void *)child, i);\n    child_start_offset += ts_subtree_total_bytes(*child);\n  }\n}\n\nvoid ts_subtree_print_dot_graph(Subtree self, const TSLanguage *language, FILE *f) {\n  fprintf(f, \"digraph tree {\\n\");\n  fprintf(f, \"edge [arrowhead=none]\\n\");\n  ts_subtree__print_dot_graph(&self, 0, language, 0, f);\n  fprintf(f, \"}\\n\");\n}\n\nconst ExternalScannerState *ts_subtree_external_scanner_state(Subtree self) {\n  static const ExternalScannerState empty_state = {{.short_data = {0}}, .length = 0};\n  if (\n    self.ptr &&\n    !self.data.is_inline &&\n    self.ptr->has_external_tokens &&\n    self.ptr->child_count == 0\n  ) {\n    return &self.ptr->external_scanner_state;\n  } else {\n    return &empty_state;\n  }\n}\n\nbool ts_subtree_external_scanner_state_eq(Subtree self, Subtree other) {\n  const ExternalScannerState *state_self = ts_subtree_external_scanner_state(self);\n  const ExternalScannerState *state_other = ts_subtree_external_scanner_state(other);\n  return ts_external_scanner_state_eq(\n    state_self,\n    ts_external_scanner_state_data(state_other),\n    state_other->length\n  );\n}\n",
    "#include \"./language.h\"\n#include \"./wasm_store.h\"\n#include \"tree_sitter/api.h\"\n#include <string.h>\n\nconst TSLanguage *ts_language_copy(const TSLanguage *self) {\n  if (self && ts_language_is_wasm(self)) {\n    ts_wasm_language_retain(self);\n  }\n  return self;\n}\n\nvoid ts_language_delete(const TSLanguage *self) {\n  if (self && ts_language_is_wasm(self)) {\n    ts_wasm_language_release(self);\n  }\n}\n\nuint32_t ts_language_symbol_count(const TSLanguage *self) {\n  return self->symbol_count + self->alias_count;\n}\n\nuint32_t ts_language_state_count(const TSLanguage *self) {\n  return self->state_count;\n}\n\nconst TSSymbol *ts_language_supertypes(const TSLanguage *self, uint32_t *length) {\n  if (self->abi_version >= LANGUAGE_VERSION_WITH_RESERVED_WORDS) {\n    *length = self->supertype_count;\n    return self->supertype_symbols;\n  } else {\n    *length = 0;\n    return NULL;\n  }\n}\n\nconst TSSymbol *ts_language_subtypes(\n  const TSLanguage *self,\n  TSSymbol supertype,\n  uint32_t *length\n) {\n  if (self->abi_version < LANGUAGE_VERSION_WITH_RESERVED_WORDS || !ts_language_symbol_metadata(self, supertype).supertype) {\n    *length = 0;\n    return NULL;\n  }\n\n  TSMapSlice slice = self->supertype_map_slices[supertype];\n  *length = slice.length;\n  return &self->supertype_map_entries[slice.index];\n}\n\nuint32_t ts_language_abi_version(const TSLanguage *self) {\n  return self->abi_version;\n}\n\nconst TSLanguageMetadata *ts_language_metadata(const TSLanguage *self) {\n    return self->abi_version >= LANGUAGE_VERSION_WITH_RESERVED_WORDS ? &self->metadata : NULL;\n}\n\nconst char *ts_language_name(const TSLanguage *self) {\n  return self->abi_version >= LANGUAGE_VERSION_WITH_RESERVED_WORDS ? self->name : NULL;\n}\n\nuint32_t ts_language_field_count(const TSLanguage *self) {\n  return self->field_count;\n}\n\nvoid ts_language_table_entry(\n  const TSLanguage *self,\n  TSStateId state,\n  TSSymbol symbol,\n  TableEntry *result\n) {\n  if (symbol == ts_builtin_sym_error || symbol == ts_builtin_sym_error_repeat) {\n    result->action_count = 0;\n    result->is_reusable = false;\n    result->actions = NULL;\n  } else {\n    ts_assert(symbol < self->token_count);\n    uint32_t action_index = ts_language_lookup(self, state, symbol);\n    const TSParseActionEntry *entry = &self->parse_actions[action_index];\n    result->action_count = entry->entry.count;\n    result->is_reusable = entry->entry.reusable;\n    result->actions = (const TSParseAction *)(entry + 1);\n  }\n}\n\nTSLexerMode ts_language_lex_mode_for_state(\n   const TSLanguage *self,\n   TSStateId state\n) {\n  if (self->abi_version < 15) {\n    TSLexMode mode = ((const TSLexMode *)self->lex_modes)[state];\n    return (TSLexerMode) {\n      .lex_state = mode.lex_state,\n      .external_lex_state = mode.external_lex_state,\n      .reserved_word_set_id = 0,\n    };\n  } else {\n    return self->lex_modes[state];\n  }\n}\n\nbool ts_language_is_reserved_word(\n  const TSLanguage *self,\n  TSStateId state,\n  TSSymbol symbol\n) {\n  TSLexerMode lex_mode = ts_language_lex_mode_for_state(self, state);\n  if (lex_mode.reserved_word_set_id > 0) {\n    unsigned start = lex_mode.reserved_word_set_id * self->max_reserved_word_set_size;\n    unsigned end = start + self->max_reserved_word_set_size;\n    for (unsigned i = start; i < end; i++) {\n      if (self->reserved_words[i] == symbol) return true;\n      if (self->reserved_words[i] == 0) break;\n    }\n  }\n  return false;\n}\n\nTSSymbolMetadata ts_language_symbol_metadata(\n  const TSLanguage *self,\n  TSSymbol symbol\n) {\n  if (symbol == ts_builtin_sym_error)  {\n    return (TSSymbolMetadata) {.visible = true, .named = true};\n  } else if (symbol == ts_builtin_sym_error_repeat) {\n    return (TSSymbolMetadata) {.visible = false, .named = false};\n  } else {\n    return self->symbol_metadata[symbol];\n  }\n}\n\nTSSymbol ts_language_public_symbol(\n  const TSLanguage *self,\n  TSSymbol symbol\n) {\n  if (symbol == ts_builtin_sym_error) return symbol;\n  return self->public_symbol_map[symbol];\n}\n\nTSStateId ts_language_next_state(\n  const TSLanguage *self,\n  TSStateId state,\n  TSSymbol symbol\n) {\n  if (symbol == ts_builtin_sym_error || symbol == ts_builtin_sym_error_repeat) {\n    return 0;\n  } else if (symbol < self->token_count) {\n    uint32_t count;\n    const TSParseAction *actions = ts_language_actions(self, state, symbol, &count);\n    if (count > 0) {\n      TSParseAction action = actions[count - 1];\n      if (action.type == TSParseActionTypeShift) {\n        return action.shift.extra ? state : action.shift.state;\n      }\n    }\n    return 0;\n  } else {\n    return ts_language_lookup(self, state, symbol);\n  }\n}\n\nconst char *ts_language_symbol_name(\n  const TSLanguage *self,\n  TSSymbol symbol\n) {\n  if (symbol == ts_builtin_sym_error) {\n    return \"ERROR\";\n  } else if (symbol == ts_builtin_sym_error_repeat) {\n    return \"_ERROR\";\n  } else if (symbol < ts_language_symbol_count(self)) {\n    return self->symbol_names[symbol];\n  } else {\n    return NULL;\n  }\n}\n\nTSSymbol ts_language_symbol_for_name(\n  const TSLanguage *self,\n  const char *string,\n  uint32_t length,\n  bool is_named\n) {\n  if (is_named && !strncmp(string, \"ERROR\", length)) return ts_builtin_sym_error;\n  uint16_t count = (uint16_t)ts_language_symbol_count(self);\n  for (TSSymbol i = 0; i < count; i++) {\n    TSSymbolMetadata metadata = ts_language_symbol_metadata(self, i);\n    if ((!metadata.visible && !metadata.supertype) || metadata.named != is_named) continue;\n    const char *symbol_name = self->symbol_names[i];\n    if (!strncmp(symbol_name, string, length) && !symbol_name[length]) {\n      return self->public_symbol_map[i];\n    }\n  }\n  return 0;\n}\n\nTSSymbolType ts_language_symbol_type(\n  const TSLanguage *self,\n  TSSymbol symbol\n) {\n  TSSymbolMetadata metadata = ts_language_symbol_metadata(self, symbol);\n  if (metadata.named && metadata.visible) {\n    return TSSymbolTypeRegular;\n  } else if (metadata.visible) {\n    return TSSymbolTypeAnonymous;\n  } else if (metadata.supertype) {\n    return TSSymbolTypeSupertype;\n  } else {\n    return TSSymbolTypeAuxiliary;\n  }\n}\n\nconst char *ts_language_field_name_for_id(\n  const TSLanguage *self,\n  TSFieldId id\n) {\n  uint32_t count = ts_language_field_count(self);\n  if (count && id <= count) {\n    return self->field_names[id];\n  } else {\n    return NULL;\n  }\n}\n\nTSFieldId ts_language_field_id_for_name(\n  const TSLanguage *self,\n  const char *name,\n  uint32_t name_length\n) {\n  uint16_t count = (uint16_t)ts_language_field_count(self);\n  for (TSSymbol i = 1; i < count + 1; i++) {\n    switch (strncmp(name, self->field_names[i], name_length)) {\n      case 0:\n        if (self->field_names[i][name_length] == 0) return i;\n        break;\n      case -1:\n        return 0;\n      default:\n        break;\n    }\n  }\n  return 0;\n}\n\nTSLookaheadIterator *ts_lookahead_iterator_new(const TSLanguage *self, TSStateId state) {\n  if (state >= self->state_count) return NULL;\n  LookaheadIterator *iterator = ts_malloc(sizeof(LookaheadIterator));\n  *iterator = ts_language_lookaheads(self, state);\n  return (TSLookaheadIterator *)iterator;\n}\n\nvoid ts_lookahead_iterator_delete(TSLookaheadIterator *self) {\n  ts_free(self);\n}\n\nbool ts_lookahead_iterator_reset_state(TSLookaheadIterator * self, TSStateId state) {\n  LookaheadIterator *iterator = (LookaheadIterator *)self;\n  if (state >= iterator->language->state_count) return false;\n  *iterator = ts_language_lookaheads(iterator->language, state);\n  return true;\n}\n\nconst TSLanguage *ts_lookahead_iterator_language(const TSLookaheadIterator *self) {\n  const LookaheadIterator *iterator = (const LookaheadIterator *)self;\n  return iterator->language;\n}\n\nbool ts_lookahead_iterator_reset(TSLookaheadIterator *self, const TSLanguage *language, TSStateId state) {\n  if (state >= language->state_count) return false;\n  LookaheadIterator *iterator = (LookaheadIterator *)self;\n  *iterator = ts_language_lookaheads(language, state);\n  return true;\n}\n\nbool ts_lookahead_iterator_next(TSLookaheadIterator *self) {\n  LookaheadIterator *iterator = (LookaheadIterator *)self;\n  return ts_lookahead_iterator__next(iterator);\n}\n\nTSSymbol ts_lookahead_iterator_current_symbol(const TSLookaheadIterator *self) {\n  const LookaheadIterator *iterator = (const LookaheadIterator *)self;\n  return iterator->symbol;\n}\n\nconst char *ts_lookahead_iterator_current_symbol_name(const TSLookaheadIterator *self) {\n  const LookaheadIterator *iterator = (const LookaheadIterator *)self;\n  return ts_language_symbol_name(iterator->language, iterator->symbol);\n}\n",
    "#include \"tree_sitter/api.h\"\n#include \"./parser.h\"\n#include <stdint.h>\n\n#ifdef TREE_SITTER_FEATURE_WASM\n\n#include \"./alloc.h\"\n#include \"./array.h\"\n#include \"./atomic.h\"\n#include \"./language.h\"\n#include \"./lexer.h\"\n#include \"./wasm/wasm-stdlib.h\"\n#include \"./wasm_store.h\"\n\n#include <string.h>\n#include <wasm.h>\n#include <wasmtime.h>\n\n#ifdef _MSC_VER\n#pragma warning(push)\n#pragma warning(disable : 4100)\n#elif defined(__GNUC__) || defined(__clang__)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wunused-parameter\"\n#endif\n\n#define array_len(a) (sizeof(a) / sizeof(a[0]))\n\n// The following symbols from the C and C++ standard libraries are available\n// for external scanners to use.\nconst char *STDLIB_SYMBOLS[] = {\n  #include \"./stdlib-symbols.txt\"\n};\n\n// The contents of the `dylink.0` custom section of a Wasm module,\n// as specified by the current WebAssembly dynamic linking ABI proposal.\ntypedef struct {\n  uint32_t memory_size;\n  uint32_t memory_align;\n  uint32_t table_size;\n  uint32_t table_align;\n} WasmDylinkInfo;\n\n// WasmLanguageId - A pointer used to identify a language. This language id is\n// reference-counted, so that its ownership can be shared between the language\n// itself and the instances of the language that are held in Wasm stores.\ntypedef struct {\n  volatile uint32_t ref_count;\n  volatile uint32_t is_language_deleted;\n} WasmLanguageId;\n\n// LanguageWasmModule - Additional data associated with a Wasm-backed\n// `TSLanguage`. This data is read-only and does not reference a particular\n// Wasm store, so it can be shared by all users of a `TSLanguage`. A pointer to\n// this is stored on the language itself.\ntypedef struct {\n  volatile uint32_t ref_count;\n  WasmLanguageId *language_id;\n  wasmtime_module_t *module;\n  const char *name;\n  char *symbol_name_buffer;\n  char *field_name_buffer;\n  WasmDylinkInfo dylink_info;\n} LanguageWasmModule;\n\n// LanguageWasmInstance - Additional data associated with an instantiation of\n// a `TSLanguage` in a particular Wasm store. The Wasm store holds one of\n// these structs for each language that it has instantiated.\ntypedef struct {\n  WasmLanguageId *language_id;\n  wasmtime_instance_t instance;\n  int32_t external_states_address;\n  int32_t lex_main_fn_index;\n  int32_t lex_keyword_fn_index;\n  int32_t scanner_create_fn_index;\n  int32_t scanner_destroy_fn_index;\n  int32_t scanner_serialize_fn_index;\n  int32_t scanner_deserialize_fn_index;\n  int32_t scanner_scan_fn_index;\n} LanguageWasmInstance;\n\ntypedef struct {\n  uint32_t reset_heap;\n  uint32_t proc_exit;\n  uint32_t abort;\n  uint32_t assert_fail;\n  uint32_t notify_memory_growth;\n  uint32_t debug_message;\n  uint32_t at_exit;\n  uint32_t args_get;\n  uint32_t args_sizes_get;\n} BuiltinFunctionIndices;\n\n// TSWasmStore - A struct that allows a given `Parser` to use Wasm-backed\n// languages. This struct is mutable, and can only be used by one parser at a\n// time.\nstruct TSWasmStore {\n  wasm_engine_t *engine;\n  wasmtime_store_t *store;\n  wasmtime_table_t function_table;\n  wasmtime_memory_t memory;\n  TSLexer *current_lexer;\n  LanguageWasmInstance *current_instance;\n  Array(LanguageWasmInstance) language_instances;\n  uint32_t current_memory_offset;\n  uint32_t current_function_table_offset;\n  uint32_t *stdlib_fn_indices;\n  BuiltinFunctionIndices builtin_fn_indices;\n  wasmtime_global_t stack_pointer_global;\n  wasm_globaltype_t *const_i32_type;\n  bool has_error;\n  uint32_t lexer_address;\n};\n\ntypedef Array(char) StringData;\n\n// LanguageInWasmMemory - The memory layout of a `TSLanguage` when compiled to\n// wasm32. This is used to copy static language data out of the Wasm memory.\ntypedef struct {\n  uint32_t abi_version;\n  uint32_t symbol_count;\n  uint32_t alias_count;\n  uint32_t token_count;\n  uint32_t external_token_count;\n  uint32_t state_count;\n  uint32_t large_state_count;\n  uint32_t production_id_count;\n  uint32_t field_count;\n  uint16_t max_alias_sequence_length;\n  int32_t parse_table;\n  int32_t small_parse_table;\n  int32_t small_parse_table_map;\n  int32_t parse_actions;\n  int32_t symbol_names;\n  int32_t field_names;\n  int32_t field_map_slices;\n  int32_t field_map_entries;\n  int32_t symbol_metadata;\n  int32_t public_symbol_map;\n  int32_t alias_map;\n  int32_t alias_sequences;\n  int32_t lex_modes;\n  int32_t lex_fn;\n  int32_t keyword_lex_fn;\n  TSSymbol keyword_capture_token;\n  struct {\n    int32_t states;\n    int32_t symbol_map;\n    int32_t create;\n    int32_t destroy;\n    int32_t scan;\n    int32_t serialize;\n    int32_t deserialize;\n  } external_scanner;\n  int32_t primary_state_ids;\n  int32_t name;\n  int32_t reserved_words;\n  uint16_t max_reserved_word_set_size;\n  uint32_t supertype_count;\n  int32_t supertype_symbols;\n  int32_t supertype_map_slices;\n  int32_t supertype_map_entries;\n  TSLanguageMetadata metadata;\n} LanguageInWasmMemory;\n\n// LexerInWasmMemory - The memory layout of a `TSLexer` when compiled to wasm32.\n// This is used to copy mutable lexing state in and out of the Wasm memory.\ntypedef struct {\n  int32_t lookahead;\n  TSSymbol result_symbol;\n  int32_t advance;\n  int32_t mark_end;\n  int32_t get_column;\n  int32_t is_at_included_range_start;\n  int32_t eof;\n} LexerInWasmMemory;\n\n// Linear memory layout:\n// [ <-- stack | stdlib statics | lexer | language statics --> | serialization_buffer | heap --> ]\n#define MAX_MEMORY_SIZE (128 * 1024 * 1024 / MEMORY_PAGE_SIZE)\n\n/************************\n * WasmDylinkMemoryInfo\n ***********************/\n\nstatic uint8_t read_u8(const uint8_t **p) {\n  return *(*p)++;\n}\n\nstatic inline uint64_t read_uleb128(const uint8_t **p, const uint8_t *end) {\n  uint64_t value = 0;\n  unsigned shift = 0;\n  do {\n    if (*p == end)  return UINT64_MAX;\n    value += (uint64_t)(**p & 0x7f) << shift;\n    shift += 7;\n  } while (*((*p)++) >= 128);\n  return value;\n}\n\nstatic bool wasm_dylink_info__parse(\n  const uint8_t *bytes,\n  size_t length,\n  WasmDylinkInfo *info\n) {\n  const uint8_t WASM_MAGIC_NUMBER[4] = {0, 'a', 's', 'm'};\n  const uint8_t WASM_VERSION[4] = {1, 0, 0, 0};\n  const uint8_t WASM_CUSTOM_SECTION = 0x0;\n  const uint8_t WASM_DYLINK_MEM_INFO = 0x1;\n\n  const uint8_t *p = bytes;\n  const uint8_t *end = bytes + length;\n\n  if (length < 8) return false;\n  if (memcmp(p, WASM_MAGIC_NUMBER, 4) != 0) return false;\n  p += 4;\n  if (memcmp(p, WASM_VERSION, 4) != 0) return false;\n  p += 4;\n\n  while (p < end) {\n    uint8_t section_id = read_u8(&p);\n    uint32_t section_length = read_uleb128(&p, end);\n    const uint8_t *section_end = p + section_length;\n    if (section_end > end) return false;\n\n    if (section_id == WASM_CUSTOM_SECTION) {\n      uint32_t name_length = read_uleb128(&p, section_end);\n      const uint8_t *name_end = p + name_length;\n      if (name_end > section_end) return false;\n\n      if (name_length == 8 && memcmp(p, \"dylink.0\", 8) == 0) {\n        p = name_end;\n        while (p < section_end) {\n          uint8_t subsection_type = read_u8(&p);\n          uint32_t subsection_size = read_uleb128(&p, section_end);\n          const uint8_t *subsection_end = p + subsection_size;\n          if (subsection_end > section_end) return false;\n          if (subsection_type == WASM_DYLINK_MEM_INFO) {\n            info->memory_size = read_uleb128(&p, subsection_end);\n            info->memory_align = read_uleb128(&p, subsection_end);\n            info->table_size = read_uleb128(&p, subsection_end);\n            info->table_align = read_uleb128(&p, subsection_end);\n            return true;\n          }\n          p = subsection_end;\n        }\n      }\n    }\n    p = section_end;\n  }\n  return false;\n}\n\n/*******************************************\n * Native callbacks exposed to Wasm modules\n *******************************************/\n\n static wasm_trap_t *callback__abort(\n  void *env,\n  wasmtime_caller_t* caller,\n  wasmtime_val_raw_t *args_and_results,\n  size_t args_and_results_len\n) {\n  return wasmtime_trap_new(\"Wasm module called abort\", 24);\n}\n\nstatic wasm_trap_t *callback__debug_message(\n  void *env,\n  wasmtime_caller_t* caller,\n  wasmtime_val_raw_t *args_and_results,\n  size_t args_and_results_len\n) {\n  wasmtime_context_t *context = wasmtime_caller_context(caller);\n  TSWasmStore *store = env;\n  ts_assert(args_and_results_len == 2);\n  uint32_t string_address = args_and_results[0].i32;\n  uint32_t value = args_and_results[1].i32;\n  uint8_t *memory = wasmtime_memory_data(context, &store->memory);\n  printf(\"DEBUG: %s %u\\n\", &memory[string_address], value);\n  return NULL;\n}\n\nstatic wasm_trap_t *callback__noop(\n  void *env,\n  wasmtime_caller_t* caller,\n  wasmtime_val_raw_t *args_and_results,\n  size_t args_and_results_len\n) {\n  return NULL;\n}\n\nstatic wasm_trap_t *callback__lexer_advance(\n  void *env,\n  wasmtime_caller_t* caller,\n  wasmtime_val_raw_t *args_and_results,\n  size_t args_and_results_len\n) {\n  wasmtime_context_t *context = wasmtime_caller_context(caller);\n  ts_assert(args_and_results_len == 2);\n\n  TSWasmStore *store = env;\n  TSLexer *lexer = store->current_lexer;\n  bool skip = args_and_results[1].i32;\n  lexer->advance(lexer, skip);\n\n  uint8_t *memory = wasmtime_memory_data(context, &store->memory);\n  memcpy(&memory[store->lexer_address], &lexer->lookahead, sizeof(lexer->lookahead));\n  return NULL;\n}\n\nstatic wasm_trap_t *callback__lexer_mark_end(\n  void *env,\n  wasmtime_caller_t* caller,\n  wasmtime_val_raw_t *args_and_results,\n  size_t args_and_results_len\n) {\n  TSWasmStore *store = env;\n  TSLexer *lexer = store->current_lexer;\n  lexer->mark_end(lexer);\n  return NULL;\n}\n\nstatic wasm_trap_t *callback__lexer_get_column(\n  void *env,\n  wasmtime_caller_t* caller,\n  wasmtime_val_raw_t *args_and_results,\n  size_t args_and_results_len\n) {\n  TSWasmStore *store = env;\n  TSLexer *lexer = store->current_lexer;\n  uint32_t result = lexer->get_column(lexer);\n  args_and_results[0].i32 = result;\n  return NULL;\n}\n\nstatic wasm_trap_t *callback__lexer_is_at_included_range_start(\n  void *env,\n  wasmtime_caller_t* caller,\n  wasmtime_val_raw_t *args_and_results,\n  size_t args_and_results_len\n) {\n  TSWasmStore *store = env;\n  TSLexer *lexer = store->current_lexer;\n  bool result = lexer->is_at_included_range_start(lexer);\n  args_and_results[0].i32 = result;\n  return NULL;\n}\n\nstatic wasm_trap_t *callback__lexer_eof(\n  void *env,\n  wasmtime_caller_t* caller,\n  wasmtime_val_raw_t *args_and_results,\n  size_t args_and_results_len\n) {\n  TSWasmStore *store = env;\n  TSLexer *lexer = store->current_lexer;\n  bool result = lexer->eof(lexer);\n  args_and_results[0].i32 = result;\n  return NULL;\n}\n\ntypedef struct {\n  uint32_t *storage_location;\n  wasmtime_func_unchecked_callback_t callback;\n  wasm_functype_t *type;\n} FunctionDefinition;\n\nstatic void *copy(const void *data, size_t size) {\n  void *result = ts_malloc(size);\n  memcpy(result, data, size);\n  return result;\n}\n\nstatic void *copy_unsized_static_array(\n  const uint8_t *data,\n  int32_t start_address,\n  const int32_t all_addresses[],\n  size_t address_count\n) {\n  int32_t end_address = 0;\n  for (unsigned i = 0; i < address_count; i++) {\n    if (all_addresses[i] > start_address) {\n      if (!end_address || all_addresses[i] < end_address) {\n        end_address = all_addresses[i];\n      }\n    }\n  }\n\n  if (!end_address) return NULL;\n  size_t size = end_address - start_address;\n  void *result = ts_malloc(size);\n  memcpy(result, &data[start_address], size);\n  return result;\n}\n\nstatic void *copy_strings(\n  const uint8_t *data,\n  int32_t array_address,\n  size_t count,\n  StringData *string_data\n) {\n  const char **result = ts_malloc(count * sizeof(char *));\n  for (unsigned i = 0; i < count; i++) {\n    int32_t address;\n    memcpy(&address, &data[array_address + i * sizeof(address)], sizeof(address));\n    if (address == 0) {\n      result[i] = (const char *)-1;\n    } else {\n      const uint8_t *string = &data[address];\n      uint32_t len = strlen((const char *)string);\n      result[i] = (const char *)(uintptr_t)string_data->size;\n      array_extend(string_data, len + 1, string);\n    }\n  }\n  for (unsigned i = 0; i < count; i++) {\n    if (result[i] == (const char *)-1) {\n      result[i] = NULL;\n    } else {\n      result[i] = string_data->contents + (uintptr_t)result[i];\n    }\n  }\n  return result;\n}\n\nstatic void *copy_string(\n  const uint8_t *data,\n  int32_t address\n) {\n  const char *string = (const char *)&data[address];\n  size_t len = strlen(string);\n  char *result = ts_malloc(len + 1);\n  memcpy(result, string, len + 1);\n  return result;\n}\n\nstatic bool name_eq(const wasm_name_t *name, const char *string) {\n  return strncmp(string, name->data, name->size) == 0;\n}\n\nstatic inline wasm_functype_t* wasm_functype_new_4_0(\n  wasm_valtype_t* p1,\n  wasm_valtype_t* p2,\n  wasm_valtype_t* p3,\n  wasm_valtype_t* p4\n) {\n  wasm_valtype_t* ps[4] = {p1, p2, p3, p4};\n  wasm_valtype_vec_t params, results;\n  wasm_valtype_vec_new(&params, 4, ps);\n  wasm_valtype_vec_new_empty(&results);\n  return wasm_functype_new(&params, &results);\n}\n\n#define format(output, ...) \\\n  do { \\\n    size_t message_length = snprintf((char *)NULL, 0, __VA_ARGS__); \\\n    *output = ts_malloc(message_length + 1); \\\n    snprintf(*output, message_length + 1, __VA_ARGS__); \\\n  } while (0)\n\nWasmLanguageId *language_id_new(void) {\n  WasmLanguageId *self = ts_malloc(sizeof(WasmLanguageId));\n  self->is_language_deleted = false;\n  self->ref_count = 1;\n  return self;\n}\n\nWasmLanguageId *language_id_clone(WasmLanguageId *self) {\n  atomic_inc(&self->ref_count);\n  return self;\n}\n\nvoid language_id_delete(WasmLanguageId *self) {\n  if (atomic_dec(&self->ref_count) == 0) {\n    ts_free(self);\n  }\n}\n\nstatic wasmtime_extern_t get_builtin_extern(\n  wasmtime_table_t *table,\n  unsigned index\n) {\n  return (wasmtime_extern_t) {\n    .kind = WASMTIME_EXTERN_FUNC,\n    .of.func = (wasmtime_func_t) {\n      .store_id = table->store_id,\n      .__private = index\n    }\n  };\n}\n\nstatic bool ts_wasm_store__provide_builtin_import(\n  TSWasmStore *self,\n  const wasm_name_t *import_name,\n  wasmtime_extern_t *import\n) {\n  wasmtime_error_t *error = NULL;\n  wasmtime_context_t *context = wasmtime_store_context(self->store);\n\n  // Dynamic linking parameters\n  if (name_eq(import_name, \"__memory_base\")) {\n    wasmtime_val_t value = WASM_I32_VAL(self->current_memory_offset);\n    wasmtime_global_t global;\n    error = wasmtime_global_new(context, self->const_i32_type, &value, &global);\n    ts_assert(!error);\n    *import = (wasmtime_extern_t) {.kind = WASMTIME_EXTERN_GLOBAL, .of.global = global};\n  } else if (name_eq(import_name, \"__table_base\")) {\n    wasmtime_val_t value = WASM_I32_VAL(self->current_function_table_offset);\n    wasmtime_global_t global;\n    error = wasmtime_global_new(context, self->const_i32_type, &value, &global);\n    ts_assert(!error);\n    *import = (wasmtime_extern_t) {.kind = WASMTIME_EXTERN_GLOBAL, .of.global = global};\n  } else if (name_eq(import_name, \"__stack_pointer\")) {\n    *import = (wasmtime_extern_t) {.kind = WASMTIME_EXTERN_GLOBAL, .of.global = self->stack_pointer_global};\n  } else if (name_eq(import_name, \"__indirect_function_table\")) {\n    *import = (wasmtime_extern_t) {.kind = WASMTIME_EXTERN_TABLE, .of.table = self->function_table};\n  } else if (name_eq(import_name, \"memory\")) {\n    *import = (wasmtime_extern_t) {.kind = WASMTIME_EXTERN_MEMORY, .of.memory = self->memory};\n  }\n\n  // Builtin functions\n  else if (name_eq(import_name, \"__assert_fail\")) {\n    *import = get_builtin_extern(&self->function_table, self->builtin_fn_indices.assert_fail);\n  } else if (name_eq(import_name, \"__cxa_atexit\")) {\n    *import = get_builtin_extern(&self->function_table, self->builtin_fn_indices.at_exit);\n  } else if (name_eq(import_name, \"args_get\")) {\n    *import = get_builtin_extern(&self->function_table, self->builtin_fn_indices.args_get);\n  } else if (name_eq(import_name, \"args_sizes_get\")) {\n    *import = get_builtin_extern(&self->function_table, self->builtin_fn_indices.args_sizes_get);\n  } else if (name_eq(import_name, \"abort\")) {\n    *import = get_builtin_extern(&self->function_table, self->builtin_fn_indices.abort);\n  } else if (name_eq(import_name, \"proc_exit\")) {\n    *import = get_builtin_extern(&self->function_table, self->builtin_fn_indices.proc_exit);\n  } else if (name_eq(import_name, \"emscripten_notify_memory_growth\")) {\n    *import = get_builtin_extern(&self->function_table, self->builtin_fn_indices.notify_memory_growth);\n  } else if (name_eq(import_name, \"tree_sitter_debug_message\")) {\n    *import = get_builtin_extern(&self->function_table, self->builtin_fn_indices.debug_message);\n  } else {\n    return false;\n  }\n\n  return true;\n}\n\nstatic bool ts_wasm_store__call_module_initializer(\n  TSWasmStore *self,\n  const wasm_name_t *export_name,\n  wasmtime_extern_t *export,\n  wasm_trap_t **trap\n) {\n  if (\n    name_eq(export_name, \"_initialize\") ||\n    name_eq(export_name, \"__wasm_apply_data_relocs\") ||\n    name_eq(export_name, \"__wasm_call_ctors\")\n  ) {\n    wasmtime_context_t *context = wasmtime_store_context(self->store);\n    wasmtime_func_t initialization_func = export->of.func;\n    wasmtime_error_t *error = wasmtime_func_call(context, &initialization_func, NULL, 0, NULL, 0, trap);\n    ts_assert(!error);\n    return true;\n  } else {\n    return false;\n  }\n}\n\nTSWasmStore *ts_wasm_store_new(TSWasmEngine *engine, TSWasmError *wasm_error) {\n  TSWasmStore *self = ts_calloc(1, sizeof(TSWasmStore));\n  wasmtime_store_t *store = wasmtime_store_new(engine, self, NULL);\n  wasmtime_context_t *context = wasmtime_store_context(store);\n  wasmtime_error_t *error = NULL;\n  wasm_trap_t *trap = NULL;\n  wasm_message_t message = WASM_EMPTY_VEC;\n  wasm_exporttype_vec_t export_types = WASM_EMPTY_VEC;\n  wasm_importtype_vec_t import_types = WASM_EMPTY_VEC;\n  wasmtime_extern_t *imports = NULL;\n  wasmtime_module_t *stdlib_module = NULL;\n  wasm_memorytype_t *memory_type = NULL;\n  wasm_tabletype_t *table_type = NULL;\n\n  // Define functions called by scanners via function pointers on the lexer.\n  LexerInWasmMemory lexer = {\n    .lookahead = 0,\n    .result_symbol = 0,\n  };\n  FunctionDefinition lexer_definitions[] = {\n    {\n      (uint32_t *)&lexer.advance,\n      callback__lexer_advance,\n      wasm_functype_new_2_0(wasm_valtype_new_i32(), wasm_valtype_new_i32())\n    },\n    {\n      (uint32_t *)&lexer.mark_end,\n      callback__lexer_mark_end,\n      wasm_functype_new_1_0(wasm_valtype_new_i32())\n    },\n    {\n      (uint32_t *)&lexer.get_column,\n      callback__lexer_get_column,\n      wasm_functype_new_1_1(wasm_valtype_new_i32(), wasm_valtype_new_i32())\n    },\n    {\n      (uint32_t *)&lexer.is_at_included_range_start,\n      callback__lexer_is_at_included_range_start,\n      wasm_functype_new_1_1(wasm_valtype_new_i32(), wasm_valtype_new_i32())\n    },\n    {\n      (uint32_t *)&lexer.eof,\n      callback__lexer_eof,\n      wasm_functype_new_1_1(wasm_valtype_new_i32(), wasm_valtype_new_i32())\n    },\n  };\n\n  // Define builtin functions that can be imported by scanners.\n  BuiltinFunctionIndices builtin_fn_indices;\n  FunctionDefinition builtin_definitions[] = {\n    {\n      &builtin_fn_indices.proc_exit,\n      callback__abort,\n      wasm_functype_new_1_0(wasm_valtype_new_i32())\n    },\n    {\n      &builtin_fn_indices.abort,\n      callback__abort,\n      wasm_functype_new_0_0()\n    },\n    {\n      &builtin_fn_indices.assert_fail,\n      callback__abort,\n      wasm_functype_new_4_0(wasm_valtype_new_i32(), wasm_valtype_new_i32(), wasm_valtype_new_i32(), wasm_valtype_new_i32())\n    },\n    {\n      &builtin_fn_indices.notify_memory_growth,\n      callback__noop,\n      wasm_functype_new_1_0(wasm_valtype_new_i32())\n    },\n    {\n      &builtin_fn_indices.debug_message,\n      callback__debug_message,\n      wasm_functype_new_2_0(wasm_valtype_new_i32(), wasm_valtype_new_i32())\n    },\n    {\n      &builtin_fn_indices.at_exit,\n      callback__noop,\n      wasm_functype_new_3_1(wasm_valtype_new_i32(), wasm_valtype_new_i32(), wasm_valtype_new_i32(), wasm_valtype_new_i32())\n    },\n    {\n      &builtin_fn_indices.args_get,\n      callback__noop,\n      wasm_functype_new_2_1(wasm_valtype_new_i32(), wasm_valtype_new_i32(), wasm_valtype_new_i32())\n    },\n    {\n      &builtin_fn_indices.args_sizes_get,\n      callback__noop,\n      wasm_functype_new_2_1(wasm_valtype_new_i32(), wasm_valtype_new_i32(), wasm_valtype_new_i32())\n    },\n  };\n\n  // Create all of the Wasm functions.\n  unsigned builtin_definitions_len = array_len(builtin_definitions);\n  unsigned lexer_definitions_len = array_len(lexer_definitions);\n  for (unsigned i = 0; i < builtin_definitions_len; i++) {\n    FunctionDefinition *definition = &builtin_definitions[i];\n    wasmtime_func_t func;\n    wasmtime_func_new_unchecked(context, definition->type, definition->callback, self, NULL, &func);\n    *definition->storage_location = func.__private;\n    wasm_functype_delete(definition->type);\n  }\n  for (unsigned i = 0; i < lexer_definitions_len; i++) {\n    FunctionDefinition *definition = &lexer_definitions[i];\n    wasmtime_func_t func;\n    wasmtime_func_new_unchecked(context, definition->type, definition->callback, self, NULL, &func);\n    *definition->storage_location = func.__private;\n    wasm_functype_delete(definition->type);\n  }\n\n  // Compile the stdlib module.\n  error = wasmtime_module_new(engine, STDLIB_WASM, STDLIB_WASM_LEN, &stdlib_module);\n  if (error) {\n    wasmtime_error_message(error, &message);\n    wasm_error->kind = TSWasmErrorKindCompile;\n    format(\n      &wasm_error->message,\n      \"failed to compile Wasm stdlib: %.*s\",\n      (int)message.size, message.data\n    );\n    goto error;\n  }\n\n  // Retrieve the stdlib module's imports.\n  wasmtime_module_imports(stdlib_module, &import_types);\n\n  // Find the initial number of memory pages needed by the stdlib.\n  const wasm_memorytype_t *stdlib_memory_type = NULL;\n  for (unsigned i = 0; i < import_types.size; i++) {\n    wasm_importtype_t *import_type = import_types.data[i];\n    const wasm_name_t *import_name = wasm_importtype_name(import_type);\n    if (name_eq(import_name, \"memory\")) {\n      const wasm_externtype_t *type = wasm_importtype_type(import_type);\n      stdlib_memory_type = wasm_externtype_as_memorytype_const(type);\n    }\n  }\n  if (!stdlib_memory_type) {\n    wasm_error->kind = TSWasmErrorKindCompile;\n    format(\n      &wasm_error->message,\n      \"Wasm stdlib is missing the 'memory' import\"\n    );\n    goto error;\n  }\n\n  // Initialize store's memory\n  uint64_t initial_memory_pages = wasmtime_memorytype_minimum(stdlib_memory_type);\n  wasm_limits_t memory_limits = {.min = initial_memory_pages, .max = MAX_MEMORY_SIZE};\n  memory_type = wasm_memorytype_new(&memory_limits);\n  wasmtime_memory_t memory;\n  error = wasmtime_memory_new(context, memory_type, &memory);\n  if (error) {\n    wasmtime_error_message(error, &message);\n    wasm_error->kind = TSWasmErrorKindAllocate;\n    format(\n      &wasm_error->message,\n      \"failed to allocate Wasm memory: %.*s\",\n      (int)message.size, message.data\n    );\n    goto error;\n  }\n  wasm_memorytype_delete(memory_type);\n  memory_type = NULL;\n\n  // Initialize store's function table\n  wasm_limits_t table_limits = {.min = 1, .max = wasm_limits_max_default};\n  table_type = wasm_tabletype_new(wasm_valtype_new(WASM_FUNCREF), &table_limits);\n  wasmtime_val_t initializer = {.kind = WASMTIME_FUNCREF};\n  wasmtime_table_t function_table;\n  error = wasmtime_table_new(context, table_type, &initializer, &function_table);\n  if (error) {\n    wasmtime_error_message(error, &message);\n    wasm_error->kind = TSWasmErrorKindAllocate;\n    format(\n      &wasm_error->message,\n      \"failed to allocate Wasm table: %.*s\",\n      (int)message.size, message.data\n    );\n    goto error;\n  }\n  wasm_tabletype_delete(table_type);\n  table_type = NULL;\n\n  unsigned stdlib_symbols_len = array_len(STDLIB_SYMBOLS);\n\n  // Define globals for the stack and heap start addresses.\n  wasm_globaltype_t *const_i32_type = wasm_globaltype_new(wasm_valtype_new_i32(), WASM_CONST);\n  wasm_globaltype_t *var_i32_type = wasm_globaltype_new(wasm_valtype_new_i32(), WASM_VAR);\n\n  wasmtime_val_t stack_pointer_value = WASM_I32_VAL(0);\n  wasmtime_global_t stack_pointer_global;\n  error = wasmtime_global_new(context, var_i32_type, &stack_pointer_value, &stack_pointer_global);\n  wasm_globaltype_delete(var_i32_type);\n  ts_assert(!error);\n\n  *self = (TSWasmStore) {\n    .engine = wasmtime_engine_clone(engine),\n    .store = store,\n    .memory = memory,\n    .function_table = function_table,\n    .language_instances = array_new(),\n    .stdlib_fn_indices = ts_calloc(stdlib_symbols_len, sizeof(uint32_t)),\n    .builtin_fn_indices = builtin_fn_indices,\n    .stack_pointer_global = stack_pointer_global,\n    .current_memory_offset = 0,\n    .current_function_table_offset = 0,\n    .const_i32_type = const_i32_type,\n  };\n\n  // Set up the imports for the stdlib module.\n  imports = ts_calloc(import_types.size, sizeof(wasmtime_extern_t));\n  for (unsigned i = 0; i < import_types.size; i++) {\n    wasm_importtype_t *type = import_types.data[i];\n    const wasm_name_t *import_name = wasm_importtype_name(type);\n    if (!ts_wasm_store__provide_builtin_import(self, import_name, &imports[i])) {\n      wasm_error->kind = TSWasmErrorKindInstantiate;\n      format(\n        &wasm_error->message,\n        \"unexpected import in Wasm stdlib: %.*s\\n\",\n        (int)import_name->size, import_name->data\n      );\n      goto error;\n    }\n  }\n\n  // Instantiate the stdlib module.\n  wasmtime_instance_t instance;\n  error = wasmtime_instance_new(context, stdlib_module, imports, import_types.size, &instance, &trap);\n  ts_free(imports);\n  imports = NULL;\n  if (error) {\n    wasmtime_error_message(error, &message);\n    wasm_error->kind = TSWasmErrorKindInstantiate;\n    format(\n      &wasm_error->message,\n      \"failed to instantiate Wasm stdlib module: %.*s\",\n      (int)message.size, message.data\n    );\n    goto error;\n  }\n  if (trap) {\n    wasm_trap_message(trap, &message);\n    wasm_error->kind = TSWasmErrorKindInstantiate;\n    format(\n      &wasm_error->message,\n      \"trapped when instantiating Wasm stdlib module: %.*s\",\n      (int)message.size, message.data\n    );\n    goto error;\n  }\n  wasm_importtype_vec_delete(&import_types);\n\n  // Process the stdlib module's exports.\n  for (unsigned i = 0; i < stdlib_symbols_len; i++) {\n    self->stdlib_fn_indices[i] = UINT32_MAX;\n  }\n  wasmtime_module_exports(stdlib_module, &export_types);\n  for (unsigned i = 0; i < export_types.size; i++) {\n    wasm_exporttype_t *export_type = export_types.data[i];\n    const wasm_name_t *name = wasm_exporttype_name(export_type);\n\n    char *export_name;\n    size_t name_len;\n    wasmtime_extern_t export = {.kind = WASM_EXTERN_GLOBAL};\n    bool exists = wasmtime_instance_export_nth(context, &instance, i, &export_name, &name_len, &export);\n    ts_assert(exists);\n\n    if (export.kind == WASMTIME_EXTERN_GLOBAL) {\n      if (name_eq(name, \"__stack_pointer\")) {\n        self->stack_pointer_global = export.of.global;\n      }\n    }\n\n    if (export.kind == WASMTIME_EXTERN_FUNC) {\n      if (ts_wasm_store__call_module_initializer(self, name, &export, &trap)) {\n        if (trap) {\n          wasm_trap_message(trap, &message);\n          wasm_error->kind = TSWasmErrorKindInstantiate;\n          format(\n            &wasm_error->message,\n            \"trap when calling stdlib relocation function: %.*s\\n\",\n            (int)message.size, message.data\n          );\n          goto error;\n        }\n        continue;\n      }\n\n      if (name_eq(name, \"reset_heap\")) {\n        self->builtin_fn_indices.reset_heap = export.of.func.__private;\n        continue;\n      }\n\n      for (unsigned j = 0; j < stdlib_symbols_len; j++) {\n        if (name_eq(name, STDLIB_SYMBOLS[j])) {\n          self->stdlib_fn_indices[j] = export.of.func.__private;\n          break;\n        }\n      }\n    }\n  }\n\n  if (self->builtin_fn_indices.reset_heap == UINT32_MAX) {\n    wasm_error->kind = TSWasmErrorKindInstantiate;\n    format(\n      &wasm_error->message,\n      \"missing malloc reset function in Wasm stdlib\"\n    );\n    goto error;\n  }\n\n  for (unsigned i = 0; i < stdlib_symbols_len; i++) {\n    if (self->stdlib_fn_indices[i] == UINT32_MAX) {\n      wasm_error->kind = TSWasmErrorKindInstantiate;\n      format(\n        &wasm_error->message,\n        \"missing exported symbol in Wasm stdlib: %s\",\n        STDLIB_SYMBOLS[i]\n      );\n      goto error;\n    }\n  }\n\n  wasm_exporttype_vec_delete(&export_types);\n  wasmtime_module_delete(stdlib_module);\n\n  // Add all of the lexer callback functions to the function table. Store their function table\n  // indices on the in-memory lexer.\n  uint64_t table_index;\n  error = wasmtime_table_grow(context, &function_table, lexer_definitions_len, &initializer, &table_index);\n  if (error) {\n    wasmtime_error_message(error, &message);\n    wasm_error->kind = TSWasmErrorKindAllocate;\n    format(\n      &wasm_error->message,\n      \"failed to grow Wasm table to initial size: %.*s\",\n      (int)message.size, message.data\n    );\n    goto error;\n  }\n  for (unsigned i = 0; i < lexer_definitions_len; i++) {\n    FunctionDefinition *definition = &lexer_definitions[i];\n    wasmtime_func_t func = {function_table.store_id, *definition->storage_location};\n    wasmtime_val_t func_val = {.kind = WASMTIME_FUNCREF, .of.funcref = func};\n    error = wasmtime_table_set(context, &function_table, table_index, &func_val);\n    ts_assert(!error);\n    *(int32_t *)(definition->storage_location) = table_index;\n    table_index++;\n  }\n\n  self->current_function_table_offset = table_index;\n  self->lexer_address = initial_memory_pages * MEMORY_PAGE_SIZE;\n  self->current_memory_offset = self->lexer_address + sizeof(LexerInWasmMemory);\n\n  // Grow the memory enough to hold the builtin lexer and serialization buffer.\n  uint32_t new_pages_needed = (self->current_memory_offset - self->lexer_address - 1) / MEMORY_PAGE_SIZE + 1;\n  uint64_t prev_memory_size;\n  wasmtime_memory_grow(context, &memory, new_pages_needed, &prev_memory_size);\n\n  uint8_t *memory_data = wasmtime_memory_data(context, &memory);\n  memcpy(&memory_data[self->lexer_address], &lexer, sizeof(lexer));\n  return self;\n\nerror:\n  ts_free(self);\n  if (stdlib_module) wasmtime_module_delete(stdlib_module);\n  if (store) wasmtime_store_delete(store);\n  if (import_types.size) wasm_importtype_vec_delete(&import_types);\n  if (memory_type) wasm_memorytype_delete(memory_type);\n  if (table_type) wasm_tabletype_delete(table_type);\n  if (trap) wasm_trap_delete(trap);\n  if (error) wasmtime_error_delete(error);\n  if (message.size) wasm_byte_vec_delete(&message);\n  if (export_types.size) wasm_exporttype_vec_delete(&export_types);\n  if (imports) ts_free(imports);\n  return NULL;\n}\n\nvoid ts_wasm_store_delete(TSWasmStore *self) {\n  if (!self) return;\n  ts_free(self->stdlib_fn_indices);\n  wasm_globaltype_delete(self->const_i32_type);\n  wasmtime_store_delete(self->store);\n  wasm_engine_delete(self->engine);\n  for (unsigned i = 0; i < self->language_instances.size; i++) {\n    LanguageWasmInstance *instance = array_get(&self->language_instances, i);\n    language_id_delete(instance->language_id);\n  }\n  array_delete(&self->language_instances);\n  ts_free(self);\n}\n\nsize_t ts_wasm_store_language_count(const TSWasmStore *self) {\n  size_t result = 0;\n  for (unsigned i = 0; i < self->language_instances.size; i++) {\n    const WasmLanguageId *id = array_get(&self->language_instances, i)->language_id;\n    if (!id->is_language_deleted) {\n      result++;\n    }\n  }\n  return result;\n}\n\nstatic uint32_t ts_wasm_store__heap_address(TSWasmStore *self) {\n  return self->current_memory_offset + TREE_SITTER_SERIALIZATION_BUFFER_SIZE;\n}\n\nstatic uint32_t ts_wasm_store__serialization_buffer_address(TSWasmStore *self) {\n  return self->current_memory_offset;\n}\n\nstatic bool ts_wasm_store__instantiate(\n  TSWasmStore *self,\n  wasmtime_module_t *module,\n  const char *language_name,\n  const WasmDylinkInfo *dylink_info,\n  wasmtime_instance_t *result,\n  int32_t *language_address,\n  char **error_message\n) {\n  wasmtime_error_t *error = NULL;\n  wasm_trap_t *trap = NULL;\n  wasm_message_t message = WASM_EMPTY_VEC;\n  char *language_function_name = NULL;\n  wasmtime_extern_t *imports = NULL;\n  wasmtime_context_t *context = wasmtime_store_context(self->store);\n\n  // Grow the function table to make room for the new functions.\n  wasmtime_val_t initializer = {.kind = WASMTIME_FUNCREF};\n  uint64_t prev_table_size;\n  error = wasmtime_table_grow(context, &self->function_table, dylink_info->table_size, &initializer, &prev_table_size);\n  if (error) {\n    format(error_message, \"invalid function table size %u\", dylink_info->table_size);\n    goto error;\n  }\n\n  // Grow the memory to make room for the new data.\n  uint32_t needed_memory_size = ts_wasm_store__heap_address(self) + dylink_info->memory_size;\n  uint32_t current_memory_size = wasmtime_memory_data_size(context, &self->memory);\n  if (needed_memory_size > current_memory_size) {\n    uint32_t pages_to_grow = (\n      needed_memory_size - current_memory_size + MEMORY_PAGE_SIZE - 1) /\n      MEMORY_PAGE_SIZE;\n    uint64_t prev_memory_size;\n    error = wasmtime_memory_grow(context, &self->memory, pages_to_grow, &prev_memory_size);\n    if (error) {\n      format(error_message, \"invalid memory size %u\", dylink_info->memory_size);\n      goto error;\n    }\n  }\n\n  // Construct the language function name as string.\n  format(&language_function_name, \"tree_sitter_%s\", language_name);\n\n  const uint64_t store_id = self->function_table.store_id;\n\n  // Build the imports list for the module.\n  wasm_importtype_vec_t import_types = WASM_EMPTY_VEC;\n  wasmtime_module_imports(module, &import_types);\n  imports = ts_calloc(import_types.size, sizeof(wasmtime_extern_t));\n\n  for (unsigned i = 0; i < import_types.size; i++) {\n    const wasm_importtype_t *import_type = import_types.data[i];\n    const wasm_name_t *import_name = wasm_importtype_name(import_type);\n    if (import_name->size == 0) {\n      format(error_message, \"empty import name\");\n      goto error;\n    }\n\n    if (ts_wasm_store__provide_builtin_import(self, import_name, &imports[i])) {\n      continue;\n    }\n\n    bool defined_in_stdlib = false;\n    for (unsigned j = 0; j < array_len(STDLIB_SYMBOLS); j++) {\n      if (name_eq(import_name, STDLIB_SYMBOLS[j])) {\n        uint16_t address = self->stdlib_fn_indices[j];\n        imports[i] = (wasmtime_extern_t) {.kind = WASMTIME_EXTERN_FUNC, .of.func = {store_id, address}};\n        defined_in_stdlib = true;\n        break;\n      }\n    }\n\n    if (!defined_in_stdlib) {\n      format(\n        error_message,\n        \"invalid import '%.*s'\\n\",\n        (int)import_name->size, import_name->data\n      );\n      goto error;\n    }\n  }\n\n  wasmtime_instance_t instance;\n  error = wasmtime_instance_new(context, module, imports, import_types.size, &instance, &trap);\n  wasm_importtype_vec_delete(&import_types);\n  ts_free(imports);\n  imports = NULL;\n  if (error) {\n    wasmtime_error_message(error, &message);\n    format(\n      error_message,\n      \"error instantiating Wasm module: %.*s\\n\",\n      (int)message.size, message.data\n    );\n    goto error;\n  }\n  if (trap) {\n    wasm_trap_message(trap, &message);\n    format(\n      error_message,\n      \"trap when instantiating Wasm module: %.*s\\n\",\n      (int)message.size, message.data\n    );\n    goto error;\n  }\n\n  self->current_memory_offset += dylink_info->memory_size;\n  self->current_function_table_offset += dylink_info->table_size;\n\n  // Process the module's exports.\n  bool found_language = false;\n  wasmtime_extern_t language_extern;\n  wasm_exporttype_vec_t export_types = WASM_EMPTY_VEC;\n  wasmtime_module_exports(module, &export_types);\n  for (unsigned i = 0; i < export_types.size; i++) {\n    wasm_exporttype_t *export_type = export_types.data[i];\n    const wasm_name_t *name = wasm_exporttype_name(export_type);\n\n    size_t name_len;\n    char *export_name;\n    wasmtime_extern_t export = {.kind = WASM_EXTERN_GLOBAL};\n    bool exists = wasmtime_instance_export_nth(context, &instance, i, &export_name, &name_len, &export);\n    ts_assert(exists);\n\n    // If the module exports an initialization or data-relocation function, call it.\n    if (ts_wasm_store__call_module_initializer(self, name, &export, &trap)) {\n      if (trap) {\n        wasm_trap_message(trap, &message);\n        format(\n          error_message,\n          \"trap when calling data relocation function: %.*s\\n\",\n          (int)message.size, message.data\n        );\n        goto error;\n      }\n    }\n\n    // Find the main language function for the module.\n    else if (name_eq(name, language_function_name)) {\n      language_extern = export;\n      found_language = true;\n    }\n  }\n  wasm_exporttype_vec_delete(&export_types);\n\n  if (!found_language) {\n    format(\n      error_message,\n      \"module did not contain language function: %s\",\n      language_function_name\n    );\n    goto error;\n  }\n\n  // Invoke the language function to get the static address of the language object.\n  wasmtime_func_t language_func = language_extern.of.func;\n  wasmtime_val_t language_address_val;\n  error = wasmtime_func_call(context, &language_func, NULL, 0, &language_address_val, 1, &trap);\n  ts_assert(!error);\n  if (trap) {\n    wasm_trap_message(trap, &message);\n    format(\n      error_message,\n      \"trapped when calling language function: %s: %.*s\\n\",\n      language_function_name, (int)message.size, message.data\n    );\n    goto error;\n  }\n\n  if (language_address_val.kind != WASMTIME_I32) {\n    format(\n      error_message,\n      \"language function did not return an integer: %s\\n\",\n      language_function_name\n    );\n    goto error;\n  }\n\n  ts_free(language_function_name);\n  *result = instance;\n  *language_address = language_address_val.of.i32;\n  return true;\n\nerror:\n  if (language_function_name) ts_free(language_function_name);\n  if (message.size) wasm_byte_vec_delete(&message);\n  if (error) wasmtime_error_delete(error);\n  if (trap) wasm_trap_delete(trap);\n  if (imports) ts_free(imports);\n  return false;\n}\n\nstatic bool ts_wasm_store__sentinel_lex_fn(TSLexer *_lexer, TSStateId state) {\n  return false;\n}\n\nconst TSLanguage *ts_wasm_store_load_language(\n  TSWasmStore *self,\n  const char *language_name,\n  const char *wasm,\n  uint32_t wasm_len,\n  TSWasmError *wasm_error\n) {\n  WasmDylinkInfo dylink_info;\n  wasmtime_module_t *module = NULL;\n  wasmtime_error_t *error = NULL;\n  wasm_error->kind = TSWasmErrorKindNone;\n\n  if (!wasm_dylink_info__parse((const unsigned char *)wasm, wasm_len, &dylink_info)) {\n    wasm_error->kind = TSWasmErrorKindParse;\n    format(&wasm_error->message, \"failed to parse dylink section of Wasm module\");\n    goto error;\n  }\n\n  // Compile the Wasm code.\n  error = wasmtime_module_new(self->engine, (const uint8_t *)wasm, wasm_len, &module);\n  if (error) {\n    wasm_message_t message;\n    wasmtime_error_message(error, &message);\n    wasm_error->kind = TSWasmErrorKindCompile;\n    format(&wasm_error->message, \"error compiling Wasm module: %.*s\", (int)message.size, message.data);\n    wasm_byte_vec_delete(&message);\n    goto error;\n  }\n\n  // Instantiate the module in this store.\n  wasmtime_instance_t instance;\n  int32_t language_address;\n  if (!ts_wasm_store__instantiate(\n    self,\n    module,\n    language_name,\n    &dylink_info,\n    &instance,\n    &language_address,\n    &wasm_error->message\n  )) {\n    wasm_error->kind = TSWasmErrorKindInstantiate;\n    goto error;\n  }\n\n  // Copy all of the static data out of the language object in Wasm memory,\n  // constructing a native language object.\n  LanguageInWasmMemory wasm_language;\n  wasmtime_context_t *context = wasmtime_store_context(self->store);\n  const uint8_t *memory = wasmtime_memory_data(context, &self->memory);\n  memcpy(&wasm_language, &memory[language_address], sizeof(LanguageInWasmMemory));\n\n  bool has_supertypes =\n    wasm_language.abi_version > LANGUAGE_VERSION_WITH_RESERVED_WORDS &&\n    wasm_language.supertype_count > 0;\n\n  int32_t addresses[] = {\n    wasm_language.parse_table,\n    wasm_language.small_parse_table,\n    wasm_language.small_parse_table_map,\n    wasm_language.parse_actions,\n    wasm_language.symbol_names,\n    wasm_language.field_names,\n    wasm_language.field_map_slices,\n    wasm_language.field_map_entries,\n    wasm_language.symbol_metadata,\n    wasm_language.public_symbol_map,\n    wasm_language.alias_map,\n    wasm_language.alias_sequences,\n    wasm_language.lex_modes,\n    wasm_language.lex_fn,\n    wasm_language.keyword_lex_fn,\n    wasm_language.primary_state_ids,\n    wasm_language.name,\n    wasm_language.reserved_words,\n    has_supertypes ? wasm_language.supertype_symbols : 0,\n    has_supertypes ? wasm_language.supertype_map_entries : 0,\n    has_supertypes ? wasm_language.supertype_map_slices : 0,\n    wasm_language.external_token_count > 0 ? wasm_language.external_scanner.states : 0,\n    wasm_language.external_token_count > 0 ? wasm_language.external_scanner.symbol_map : 0,\n    wasm_language.external_token_count > 0 ? wasm_language.external_scanner.create : 0,\n    wasm_language.external_token_count > 0 ? wasm_language.external_scanner.destroy : 0,\n    wasm_language.external_token_count > 0 ? wasm_language.external_scanner.scan : 0,\n    wasm_language.external_token_count > 0 ? wasm_language.external_scanner.serialize : 0,\n    wasm_language.external_token_count > 0 ? wasm_language.external_scanner.deserialize : 0,\n    language_address,\n    self->current_memory_offset,\n  };\n  uint32_t address_count = array_len(addresses);\n\n  TSLanguage *language = ts_calloc(1, sizeof(TSLanguage));\n  StringData symbol_name_buffer = array_new();\n  StringData field_name_buffer = array_new();\n\n  *language = (TSLanguage) {\n    .abi_version = wasm_language.abi_version,\n    .symbol_count = wasm_language.symbol_count,\n    .alias_count = wasm_language.alias_count,\n    .token_count = wasm_language.token_count,\n    .external_token_count = wasm_language.external_token_count,\n    .state_count = wasm_language.state_count,\n    .large_state_count = wasm_language.large_state_count,\n    .production_id_count = wasm_language.production_id_count,\n    .field_count = wasm_language.field_count,\n    .supertype_count = wasm_language.supertype_count,\n    .max_alias_sequence_length = wasm_language.max_alias_sequence_length,\n    .keyword_capture_token = wasm_language.keyword_capture_token,\n    .metadata = wasm_language.metadata,\n    .parse_table = copy(\n      &memory[wasm_language.parse_table],\n      wasm_language.large_state_count * wasm_language.symbol_count * sizeof(uint16_t)\n    ),\n    .parse_actions = copy_unsized_static_array(\n      memory,\n      wasm_language.parse_actions,\n      addresses,\n      address_count\n    ),\n    .symbol_names = copy_strings(\n      memory,\n      wasm_language.symbol_names,\n      wasm_language.symbol_count + wasm_language.alias_count,\n      &symbol_name_buffer\n    ),\n    .symbol_metadata = copy(\n      &memory[wasm_language.symbol_metadata],\n      (wasm_language.symbol_count + wasm_language.alias_count) * sizeof(TSSymbolMetadata)\n    ),\n    .public_symbol_map = copy(\n      &memory[wasm_language.public_symbol_map],\n      (wasm_language.symbol_count + wasm_language.alias_count) * sizeof(TSSymbol)\n    ),\n    .lex_modes = copy(\n      &memory[wasm_language.lex_modes],\n      wasm_language.state_count * sizeof(TSLexerMode)\n    ),\n  };\n\n  if (language->field_count > 0 && language->production_id_count > 0) {\n    language->field_map_slices = copy(\n      &memory[wasm_language.field_map_slices],\n      wasm_language.production_id_count * sizeof(TSMapSlice)\n    );\n\n    // Determine the number of field map entries by finding the greatest index\n    // in any of the slices.\n    uint32_t field_map_entry_count = 0;\n    for (uint32_t i = 0; i < wasm_language.production_id_count; i++) {\n      TSMapSlice slice = language->field_map_slices[i];\n      uint32_t slice_end = slice.index + slice.length;\n      if (slice_end > field_map_entry_count) {\n        field_map_entry_count = slice_end;\n      }\n    }\n\n    language->field_map_entries = copy(\n      &memory[wasm_language.field_map_entries],\n      field_map_entry_count * sizeof(TSFieldMapEntry)\n    );\n    language->field_names = copy_strings(\n      memory,\n      wasm_language.field_names,\n      wasm_language.field_count + 1,\n      &field_name_buffer\n    );\n  }\n\n  if (has_supertypes) {\n    language->supertype_symbols = copy(\n      &memory[wasm_language.supertype_symbols],\n      wasm_language.supertype_count * sizeof(TSSymbol)\n    );\n\n    // Determine the number of supertype map slices by finding the greatest\n    // supertype ID.\n    int largest_supertype = 0;\n    for (unsigned i = 0; i < language->supertype_count; i++) {\n      TSSymbol supertype = language->supertype_symbols[i];\n      if (supertype > largest_supertype) {\n        largest_supertype = supertype;\n      }\n    }\n\n    language->supertype_map_slices = copy(\n      &memory[wasm_language.supertype_map_slices],\n      (largest_supertype + 1) * sizeof(TSMapSlice)\n    );\n\n    TSSymbol last_supertype = language->supertype_symbols[language->supertype_count - 1];\n    TSMapSlice last_slice = language->supertype_map_slices[last_supertype];\n    uint32_t supertype_map_entry_count = last_slice.index + last_slice.length;\n\n    language->supertype_map_entries = copy(\n      &memory[wasm_language.supertype_map_entries],\n      supertype_map_entry_count * sizeof(char *)\n    );\n  }\n\n  if (language->max_alias_sequence_length > 0 && language->production_id_count > 0) {\n    // The alias map contains symbols, alias counts, and aliases, terminated by a null symbol.\n    int32_t alias_map_size = 0;\n    for (;;) {\n      TSSymbol symbol;\n      memcpy(&symbol, &memory[wasm_language.alias_map + alias_map_size], sizeof(symbol));\n      alias_map_size += sizeof(TSSymbol);\n      if (symbol == 0) break;\n      uint16_t value_count;\n      memcpy(&value_count, &memory[wasm_language.alias_map + alias_map_size], sizeof(value_count));\n      alias_map_size += sizeof(uint16_t);\n      alias_map_size += value_count * sizeof(TSSymbol);\n    }\n    language->alias_map = copy(\n      &memory[wasm_language.alias_map],\n      alias_map_size\n    );\n    language->alias_sequences = copy(\n      &memory[wasm_language.alias_sequences],\n      wasm_language.production_id_count * wasm_language.max_alias_sequence_length * sizeof(TSSymbol)\n    );\n  }\n\n  if (language->state_count > language->large_state_count) {\n    uint32_t small_state_count = wasm_language.state_count - wasm_language.large_state_count;\n    language->small_parse_table_map = copy(\n      &memory[wasm_language.small_parse_table_map],\n      small_state_count * sizeof(uint32_t)\n    );\n    language->small_parse_table = copy_unsized_static_array(\n      memory,\n      wasm_language.small_parse_table,\n      addresses,\n      address_count\n    );\n  }\n\n  if (language->abi_version >= LANGUAGE_VERSION_WITH_PRIMARY_STATES) {\n    language->primary_state_ids = copy(\n      &memory[wasm_language.primary_state_ids],\n      wasm_language.state_count * sizeof(TSStateId)\n    );\n  }\n\n  if (language->abi_version >= LANGUAGE_VERSION_WITH_RESERVED_WORDS) {\n    language->name = copy_string(memory, wasm_language.name);\n    language->reserved_words = copy(\n        &memory[wasm_language.reserved_words],\n        wasm_language.max_reserved_word_set_size * sizeof(TSSymbol)\n    );\n    language->max_reserved_word_set_size = wasm_language.max_reserved_word_set_size;\n  }\n\n  if (language->external_token_count > 0) {\n    language->external_scanner.symbol_map = copy(\n      &memory[wasm_language.external_scanner.symbol_map],\n      wasm_language.external_token_count * sizeof(TSSymbol)\n    );\n    language->external_scanner.states = (void *)(uintptr_t)wasm_language.external_scanner.states;\n  }\n\n  unsigned name_len = strlen(language_name);\n  char *name = ts_malloc(name_len + 1);\n  memcpy(name, language_name, name_len);\n  name[name_len] = '\\0';\n\n  LanguageWasmModule *language_module = ts_malloc(sizeof(LanguageWasmModule));\n  *language_module = (LanguageWasmModule) {\n    .language_id = language_id_new(),\n    .module = module,\n    .name = name,\n    .symbol_name_buffer = symbol_name_buffer.contents,\n    .field_name_buffer = field_name_buffer.contents,\n    .dylink_info = dylink_info,\n    .ref_count = 1,\n  };\n\n  // The lex functions are not used for Wasm languages. Use those two fields\n  // to mark this language as Wasm-based and to store the language's\n  // Wasm-specific data.\n  language->lex_fn = ts_wasm_store__sentinel_lex_fn;\n  language->keyword_lex_fn = (bool (*)(TSLexer *, TSStateId))language_module;\n\n  // Clear out any instances of languages that have been deleted.\n  for (unsigned i = 0; i < self->language_instances.size; i++) {\n    WasmLanguageId *id = array_get(&self->language_instances, i)->language_id;\n    if (id->is_language_deleted) {\n      language_id_delete(id);\n      array_erase(&self->language_instances, i);\n      i--;\n    }\n  }\n\n  // Store this store's instance of this language module.\n  array_push(&self->language_instances, ((LanguageWasmInstance) {\n    .language_id = language_id_clone(language_module->language_id),\n    .instance = instance,\n    .external_states_address = wasm_language.external_scanner.states,\n    .lex_main_fn_index = wasm_language.lex_fn,\n    .lex_keyword_fn_index = wasm_language.keyword_lex_fn,\n    .scanner_create_fn_index = wasm_language.external_scanner.create,\n    .scanner_destroy_fn_index = wasm_language.external_scanner.destroy,\n    .scanner_serialize_fn_index = wasm_language.external_scanner.serialize,\n    .scanner_deserialize_fn_index = wasm_language.external_scanner.deserialize,\n    .scanner_scan_fn_index = wasm_language.external_scanner.scan,\n  }));\n\n  return language;\n\nerror:\n  if (module) wasmtime_module_delete(module);\n  return NULL;\n}\n\nbool ts_wasm_store_add_language(\n  TSWasmStore *self,\n  const TSLanguage *language,\n  uint32_t *index\n) {\n  wasmtime_context_t *context = wasmtime_store_context(self->store);\n  const LanguageWasmModule *language_module = (void *)language->keyword_lex_fn;\n\n  // Search for this store's instance of the language module. Also clear out any\n  // instances of languages that have been deleted.\n  bool exists = false;\n  for (unsigned i = 0; i < self->language_instances.size; i++) {\n    WasmLanguageId *id = array_get(&self->language_instances, i)->language_id;\n    if (id->is_language_deleted) {\n      language_id_delete(id);\n      array_erase(&self->language_instances, i);\n      i--;\n    } else if (id == language_module->language_id) {\n      exists = true;\n      *index = i;\n    }\n  }\n\n  // If the language module has not been instantiated in this store, then add\n  // it to this store.\n  if (!exists) {\n    *index = self->language_instances.size;\n    char *message;\n    wasmtime_instance_t instance;\n    int32_t language_address;\n    if (!ts_wasm_store__instantiate(\n      self,\n      language_module->module,\n      language_module->name,\n      &language_module->dylink_info,\n      &instance,\n      &language_address,\n      &message\n    )) {\n      ts_free(message);\n      return false;\n    }\n\n    LanguageInWasmMemory wasm_language;\n    const uint8_t *memory = wasmtime_memory_data(context, &self->memory);\n    memcpy(&wasm_language, &memory[language_address], sizeof(LanguageInWasmMemory));\n    array_push(&self->language_instances, ((LanguageWasmInstance) {\n      .language_id = language_id_clone(language_module->language_id),\n      .instance = instance,\n      .external_states_address = wasm_language.external_scanner.states,\n      .lex_main_fn_index = wasm_language.lex_fn,\n      .lex_keyword_fn_index = wasm_language.keyword_lex_fn,\n      .scanner_create_fn_index = wasm_language.external_scanner.create,\n      .scanner_destroy_fn_index = wasm_language.external_scanner.destroy,\n      .scanner_serialize_fn_index = wasm_language.external_scanner.serialize,\n      .scanner_deserialize_fn_index = wasm_language.external_scanner.deserialize,\n      .scanner_scan_fn_index = wasm_language.external_scanner.scan,\n    }));\n  }\n\n  return true;\n}\n\nvoid ts_wasm_store_reset_heap(TSWasmStore *self) {\n  wasmtime_context_t *context = wasmtime_store_context(self->store);\n  wasmtime_func_t func = {\n    self->function_table.store_id,\n    self->builtin_fn_indices.reset_heap\n  };\n  wasm_trap_t *trap = NULL;\n  wasmtime_val_t args[1] = {\n    {.of.i32 = ts_wasm_store__heap_address(self), .kind = WASMTIME_I32},\n  };\n\n  wasmtime_error_t *error = wasmtime_func_call(context, &func, args, 1, NULL, 0, &trap);\n  ts_assert(!error);\n  ts_assert(!trap);\n}\n\nbool ts_wasm_store_start(TSWasmStore *self, TSLexer *lexer, const TSLanguage *language) {\n  uint32_t instance_index;\n  if (!ts_wasm_store_add_language(self, language, &instance_index)) return false;\n  self->current_lexer = lexer;\n  self->current_instance = array_get(&self->language_instances, instance_index);\n  self->has_error = false;\n  ts_wasm_store_reset_heap(self);\n  return true;\n}\n\nvoid ts_wasm_store_reset(TSWasmStore *self) {\n  self->current_lexer = NULL;\n  self->current_instance = NULL;\n  self->has_error = false;\n  ts_wasm_store_reset_heap(self);\n}\n\nstatic void ts_wasm_store__call(\n  TSWasmStore *self,\n  int32_t function_index,\n  wasmtime_val_raw_t *args_and_results,\n  size_t args_and_results_len\n) {\n  wasmtime_context_t *context = wasmtime_store_context(self->store);\n  wasmtime_val_t value;\n  bool succeeded = wasmtime_table_get(context, &self->function_table, function_index, &value);\n  ts_assert(succeeded);\n  ts_assert(value.kind == WASMTIME_FUNCREF);\n  wasmtime_func_t func = value.of.funcref;\n\n  wasm_trap_t *trap = NULL;\n  wasmtime_error_t *error = wasmtime_func_call_unchecked(context, &func, args_and_results, args_and_results_len, &trap);\n  if (error) {\n    // wasm_message_t message;\n    // wasmtime_error_message(error, &message);\n    // fprintf(\n    //   stderr,\n    //   \"error in Wasm module: %.*s\\n\",\n    //   (int)message.size, message.data\n    // );\n    wasmtime_error_delete(error);\n    self->has_error = true;\n  } else if (trap) {\n    // wasm_message_t message;\n    // wasm_trap_message(trap, &message);\n    // fprintf(\n    //   stderr,\n    //   \"trap in Wasm module: %.*s\\n\",\n    //   (int)message.size, message.data\n    // );\n    wasm_trap_delete(trap);\n    self->has_error = true;\n  }\n}\n\n// The data fields of TSLexer, without the function pointers.\n//\n// This portion of the struct needs to be copied in and out\n// of Wasm memory before and after calling a scan function.\ntypedef struct {\n  int32_t lookahead;\n  TSSymbol result_symbol;\n} TSLexerDataPrefix;\n\nstatic bool ts_wasm_store__call_lex_function(TSWasmStore *self, unsigned function_index, TSStateId state) {\n  wasmtime_context_t *context = wasmtime_store_context(self->store);\n  uint8_t *memory_data = wasmtime_memory_data(context, &self->memory);\n  memcpy(\n    &memory_data[self->lexer_address],\n    self->current_lexer,\n    sizeof(TSLexerDataPrefix)\n  );\n\n  wasmtime_val_raw_t args[2] = {\n    {.i32 = self->lexer_address},\n    {.i32 = state},\n  };\n  ts_wasm_store__call(self, function_index, args, 2);\n  if (self->has_error) return false;\n  bool result = args[0].i32;\n\n  memcpy(\n    self->current_lexer,\n    &memory_data[self->lexer_address],\n    sizeof(TSLexerDataPrefix)\n  );\n  return result;\n}\n\nbool ts_wasm_store_call_lex_main(TSWasmStore *self, TSStateId state) {\n  return ts_wasm_store__call_lex_function(\n    self,\n    self->current_instance->lex_main_fn_index,\n    state\n  );\n}\n\nbool ts_wasm_store_call_lex_keyword(TSWasmStore *self, TSStateId state) {\n  return ts_wasm_store__call_lex_function(\n    self,\n    self->current_instance->lex_keyword_fn_index,\n    state\n  );\n}\n\nuint32_t ts_wasm_store_call_scanner_create(TSWasmStore *self) {\n  wasmtime_val_raw_t args[1] = {{.i32 = 0}};\n  ts_wasm_store__call(self, self->current_instance->scanner_create_fn_index, args, 1);\n  if (self->has_error) return 0;\n  return args[0].i32;\n}\n\nvoid ts_wasm_store_call_scanner_destroy(TSWasmStore *self, uint32_t scanner_address) {\n  if (self->current_instance) {\n    wasmtime_val_raw_t args[1] = {{.i32 = scanner_address}};\n    ts_wasm_store__call(self, self->current_instance->scanner_destroy_fn_index, args, 1);\n  }\n}\n\nbool ts_wasm_store_call_scanner_scan(\n  TSWasmStore *self,\n  uint32_t scanner_address,\n  uint32_t valid_tokens_ix\n) {\n  wasmtime_context_t *context = wasmtime_store_context(self->store);\n  uint8_t *memory_data = wasmtime_memory_data(context, &self->memory);\n\n  memcpy(\n    &memory_data[self->lexer_address],\n    self->current_lexer,\n    sizeof(TSLexerDataPrefix)\n  );\n\n  uint32_t valid_tokens_address =\n    self->current_instance->external_states_address +\n    (valid_tokens_ix * sizeof(bool));\n  wasmtime_val_raw_t args[3] = {\n    {.i32 = scanner_address},\n    {.i32 = self->lexer_address},\n    {.i32 = valid_tokens_address}\n  };\n  ts_wasm_store__call(self, self->current_instance->scanner_scan_fn_index, args, 3);\n  if (self->has_error) return false;\n\n  memcpy(\n    self->current_lexer,\n    &memory_data[self->lexer_address],\n    sizeof(TSLexerDataPrefix)\n  );\n  return args[0].i32;\n}\n\nuint32_t ts_wasm_store_call_scanner_serialize(\n  TSWasmStore *self,\n  uint32_t scanner_address,\n  char *buffer\n) {\n  wasmtime_context_t *context = wasmtime_store_context(self->store);\n  uint8_t *memory_data = wasmtime_memory_data(context, &self->memory);\n  uint32_t serialization_buffer_address = ts_wasm_store__serialization_buffer_address(self);\n\n  wasmtime_val_raw_t args[2] = {\n    {.i32 = scanner_address},\n    {.i32 = serialization_buffer_address},\n  };\n  ts_wasm_store__call(self, self->current_instance->scanner_serialize_fn_index, args, 2);\n  if (self->has_error) return 0;\n\n  uint32_t length = args[0].i32;\n  if (length > TREE_SITTER_SERIALIZATION_BUFFER_SIZE) {\n      self->has_error = true;\n      return 0;\n  }\n\n  if (length > 0) {\n    memcpy(\n      ((Lexer *)self->current_lexer)->debug_buffer,\n      &memory_data[serialization_buffer_address],\n      length\n    );\n  }\n  return length;\n}\n\nvoid ts_wasm_store_call_scanner_deserialize(\n  TSWasmStore *self,\n  uint32_t scanner_address,\n  const char *buffer,\n  unsigned length\n) {\n  wasmtime_context_t *context = wasmtime_store_context(self->store);\n  uint8_t *memory_data = wasmtime_memory_data(context, &self->memory);\n  uint32_t serialization_buffer_address = ts_wasm_store__serialization_buffer_address(self);\n\n  if (length > 0) {\n    memcpy(\n      &memory_data[serialization_buffer_address],\n      buffer,\n      length\n    );\n  }\n\n  wasmtime_val_raw_t args[3] = {\n    {.i32 = scanner_address},\n    {.i32 = serialization_buffer_address},\n    {.i32 = length},\n  };\n  ts_wasm_store__call(self, self->current_instance->scanner_deserialize_fn_index, args, 3);\n}\n\nbool ts_wasm_store_has_error(const TSWasmStore *self) {\n  return self->has_error;\n}\n\nbool ts_language_is_wasm(const TSLanguage *self) {\n  return self->lex_fn == ts_wasm_store__sentinel_lex_fn;\n}\n\nstatic inline LanguageWasmModule *ts_language__wasm_module(const TSLanguage *self) {\n  return (LanguageWasmModule *)self->keyword_lex_fn;\n}\n\nvoid ts_wasm_language_retain(const TSLanguage *self) {\n  LanguageWasmModule *module = ts_language__wasm_module(self);\n  ts_assert(module->ref_count > 0);\n  atomic_inc(&module->ref_count);\n}\n\nvoid ts_wasm_language_release(const TSLanguage *self) {\n  LanguageWasmModule *module = ts_language__wasm_module(self);\n  ts_assert(module->ref_count > 0);\n  if (atomic_dec(&module->ref_count) == 0) {\n    // Update the language id to reflect that the language is deleted. This allows any Wasm stores\n    // that hold Wasm instances for this language to delete those instances.\n    atomic_inc(&module->language_id->is_language_deleted);\n    language_id_delete(module->language_id);\n\n    ts_free((void *)module->field_name_buffer);\n    ts_free((void *)module->symbol_name_buffer);\n    ts_free((void *)module->name);\n    wasmtime_module_delete(module->module);\n    ts_free(module);\n\n    ts_free((void *)self->alias_map);\n    ts_free((void *)self->alias_sequences);\n    ts_free((void *)self->external_scanner.symbol_map);\n    ts_free((void *)self->field_map_entries);\n    ts_free((void *)self->field_map_slices);\n    ts_free((void *)self->supertype_symbols);\n    ts_free((void *)self->supertype_map_entries);\n    ts_free((void *)self->supertype_map_slices);\n    ts_free((void *)self->field_names);\n    ts_free((void *)self->lex_modes);\n    ts_free((void *)self->name);\n    ts_free((void *)self->reserved_words);\n    ts_free((void *)self->parse_actions);\n    ts_free((void *)self->parse_table);\n    ts_free((void *)self->primary_state_ids);\n    ts_free((void *)self->public_symbol_map);\n    ts_free((void *)self->small_parse_table);\n    ts_free((void *)self->small_parse_table_map);\n    ts_free((void *)self->symbol_metadata);\n    ts_free((void *)self->symbol_names);\n    ts_free((void *)self);\n  }\n}\n\n#ifdef _MSC_VER\n#pragma warning(pop)\n#elif defined(__GNUC__) || defined(__clang__)\n#pragma GCC diagnostic pop\n#endif\n\n#else\n\n// If the Wasm feature is not enabled, define dummy versions of all of the\n// Wasm-related functions.\n\nvoid ts_wasm_store_delete(TSWasmStore *self) {\n  (void)self;\n}\n\nbool ts_wasm_store_start(\n  TSWasmStore *self,\n  TSLexer *lexer,\n  const TSLanguage *language\n) {\n  (void)self;\n  (void)lexer;\n  (void)language;\n  return false;\n}\n\nvoid ts_wasm_store_reset(TSWasmStore *self) {\n  (void)self;\n}\n\nbool ts_wasm_store_call_lex_main(TSWasmStore *self, TSStateId state) {\n  (void)self;\n  (void)state;\n  return false;\n}\n\nbool ts_wasm_store_call_lex_keyword(TSWasmStore *self, TSStateId state) {\n  (void)self;\n  (void)state;\n  return false;\n}\n\nuint32_t ts_wasm_store_call_scanner_create(TSWasmStore *self) {\n  (void)self;\n  return 0;\n}\n\nvoid ts_wasm_store_call_scanner_destroy(\n  TSWasmStore *self,\n  uint32_t scanner_address\n) {\n  (void)self;\n  (void)scanner_address;\n}\n\nbool ts_wasm_store_call_scanner_scan(\n  TSWasmStore *self,\n  uint32_t scanner_address,\n  uint32_t valid_tokens_ix\n) {\n  (void)self;\n  (void)scanner_address;\n  (void)valid_tokens_ix;\n  return false;\n}\n\nuint32_t ts_wasm_store_call_scanner_serialize(\n  TSWasmStore *self,\n  uint32_t scanner_address,\n  char *buffer\n) {\n  (void)self;\n  (void)scanner_address;\n  (void)buffer;\n  return 0;\n}\n\nvoid ts_wasm_store_call_scanner_deserialize(\n  TSWasmStore *self,\n  uint32_t scanner_address,\n  const char *buffer,\n  unsigned length\n) {\n  (void)self;\n  (void)scanner_address;\n  (void)buffer;\n  (void)length;\n}\n\nbool ts_wasm_store_has_error(const TSWasmStore *self) {\n  (void)self;\n  return false;\n}\n\nbool ts_language_is_wasm(const TSLanguage *self) {\n  (void)self;\n  return false;\n}\n\nvoid ts_wasm_language_retain(const TSLanguage *self) {\n  (void)self;\n}\n\nvoid ts_wasm_language_release(const TSLanguage *self) {\n  (void)self;\n}\n\n#endif\n",
    "#ifndef TREE_SITTER_LANGUAGE_H_\n#define TREE_SITTER_LANGUAGE_H_\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include \"./subtree.h\"\n#include \"./parser.h\"\n\n#define ts_builtin_sym_error_repeat (ts_builtin_sym_error - 1)\n\n#define LANGUAGE_VERSION_WITH_RESERVED_WORDS 15\n#define LANGUAGE_VERSION_WITH_PRIMARY_STATES 14\n\ntypedef struct {\n  const TSParseAction *actions;\n  uint32_t action_count;\n  bool is_reusable;\n} TableEntry;\n\ntypedef struct {\n  const TSLanguage *language;\n  const uint16_t *data;\n  const uint16_t *group_end;\n  TSStateId state;\n  uint16_t table_value;\n  uint16_t section_index;\n  uint16_t group_count;\n  bool is_small_state;\n\n  const TSParseAction *actions;\n  TSSymbol symbol;\n  TSStateId next_state;\n  uint16_t action_count;\n} LookaheadIterator;\n\nvoid ts_language_table_entry(const TSLanguage *self, TSStateId state, TSSymbol symbol, TableEntry *result);\nTSLexerMode ts_language_lex_mode_for_state(const TSLanguage *self, TSStateId state);\nbool ts_language_is_reserved_word(const TSLanguage *self, TSStateId state, TSSymbol symbol);\nTSSymbolMetadata ts_language_symbol_metadata(const TSLanguage *self, TSSymbol symbol);\nTSSymbol ts_language_public_symbol(const TSLanguage *self, TSSymbol symbol);\n\nstatic inline const TSParseAction *ts_language_actions(\n  const TSLanguage *self,\n  TSStateId state,\n  TSSymbol symbol,\n  uint32_t *count\n) {\n  TableEntry entry;\n  ts_language_table_entry(self, state, symbol, &entry);\n  *count = entry.action_count;\n  return entry.actions;\n}\n\nstatic inline bool ts_language_has_reduce_action(\n  const TSLanguage *self,\n  TSStateId state,\n  TSSymbol symbol\n) {\n  TableEntry entry;\n  ts_language_table_entry(self, state, symbol, &entry);\n  return entry.action_count > 0 && entry.actions[0].type == TSParseActionTypeReduce;\n}\n\n// Lookup the table value for a given symbol and state.\n//\n// For non-terminal symbols, the table value represents a successor state.\n// For terminal symbols, it represents an index in the actions table.\n// For 'large' parse states, this is a direct lookup. For 'small' parse\n// states, this requires searching through the symbol groups to find\n// the given symbol.\nstatic inline uint16_t ts_language_lookup(\n  const TSLanguage *self,\n  TSStateId state,\n  TSSymbol symbol\n) {\n  if (state >= self->large_state_count) {\n    uint32_t index = self->small_parse_table_map[state - self->large_state_count];\n    const uint16_t *data = &self->small_parse_table[index];\n    uint16_t group_count = *(data++);\n    for (unsigned i = 0; i < group_count; i++) {\n      uint16_t section_value = *(data++);\n      uint16_t symbol_count = *(data++);\n      for (unsigned j = 0; j < symbol_count; j++) {\n        if (*(data++) == symbol) return section_value;\n      }\n    }\n    return 0;\n  } else {\n    return self->parse_table[state * self->symbol_count + symbol];\n  }\n}\n\nstatic inline bool ts_language_has_actions(\n  const TSLanguage *self,\n  TSStateId state,\n  TSSymbol symbol\n) {\n  return ts_language_lookup(self, state, symbol) != 0;\n}\n\n// Iterate over all of the symbols that are valid in the given state.\n//\n// For 'large' parse states, this just requires iterating through\n// all possible symbols and checking the parse table for each one.\n// For 'small' parse states, this exploits the structure of the\n// table to only visit the valid symbols.\nstatic inline LookaheadIterator ts_language_lookaheads(\n  const TSLanguage *self,\n  TSStateId state\n) {\n  bool is_small_state = state >= self->large_state_count;\n  const uint16_t *data;\n  const uint16_t *group_end = NULL;\n  uint16_t group_count = 0;\n  if (is_small_state) {\n    uint32_t index = self->small_parse_table_map[state - self->large_state_count];\n    data = &self->small_parse_table[index];\n    group_end = data + 1;\n    group_count = *data;\n  } else {\n    data = &self->parse_table[state * self->symbol_count] - 1;\n  }\n  return (LookaheadIterator) {\n    .language = self,\n    .data = data,\n    .group_end = group_end,\n    .group_count = group_count,\n    .is_small_state = is_small_state,\n    .symbol = UINT16_MAX,\n    .next_state = 0,\n  };\n}\n\nstatic inline bool ts_lookahead_iterator__next(LookaheadIterator *self) {\n  // For small parse states, valid symbols are listed explicitly,\n  // grouped by their value. There's no need to look up the actions\n  // again until moving to the next group.\n  if (self->is_small_state) {\n    self->data++;\n    if (self->data == self->group_end) {\n      if (self->group_count == 0) return false;\n      self->group_count--;\n      self->table_value = *(self->data++);\n      unsigned symbol_count = *(self->data++);\n      self->group_end = self->data + symbol_count;\n      self->symbol = *self->data;\n    } else {\n      self->symbol = *self->data;\n      return true;\n    }\n  }\n\n  // For large parse states, iterate through every symbol until one\n  // is found that has valid actions.\n  else {\n    do {\n      self->data++;\n      self->symbol++;\n      if (self->symbol >= self->language->symbol_count) return false;\n      self->table_value = *self->data;\n    } while (!self->table_value);\n  }\n\n  // Depending on if the symbols is terminal or non-terminal, the table value either\n  // represents a list of actions or a successor state.\n  if (self->symbol < self->language->token_count) {\n    const TSParseActionEntry *entry = &self->language->parse_actions[self->table_value];\n    self->action_count = entry->entry.count;\n    self->actions = (const TSParseAction *)(entry + 1);\n    self->next_state = 0;\n  } else {\n    self->action_count = 0;\n    self->next_state = self->table_value;\n  }\n  return true;\n}\n\n// Whether the state is a \"primary state\". If this returns false, it indicates that there exists\n// another state that behaves identically to this one with respect to query analysis.\nstatic inline bool ts_language_state_is_primary(\n  const TSLanguage *self,\n  TSStateId state\n) {\n  if (self->abi_version >= LANGUAGE_VERSION_WITH_PRIMARY_STATES) {\n    return state == self->primary_state_ids[state];\n  } else {\n    return true;\n  }\n}\n\nstatic inline const bool *ts_language_enabled_external_tokens(\n  const TSLanguage *self,\n  unsigned external_scanner_state\n) {\n  if (external_scanner_state == 0) {\n    return NULL;\n  } else {\n    return self->external_scanner.states + self->external_token_count * external_scanner_state;\n  }\n}\n\nstatic inline const TSSymbol *ts_language_alias_sequence(\n  const TSLanguage *self,\n  uint32_t production_id\n) {\n  return production_id ?\n    &self->alias_sequences[production_id * self->max_alias_sequence_length] :\n    NULL;\n}\n\nstatic inline TSSymbol ts_language_alias_at(\n  const TSLanguage *self,\n  uint32_t production_id,\n  uint32_t child_index\n) {\n  return production_id ?\n    self->alias_sequences[production_id * self->max_alias_sequence_length + child_index] :\n    0;\n}\n\nstatic inline void ts_language_field_map(\n  const TSLanguage *self,\n  uint32_t production_id,\n  const TSFieldMapEntry **start,\n  const TSFieldMapEntry **end\n) {\n  if (self->field_count == 0) {\n    *start = NULL;\n    *end = NULL;\n    return;\n  }\n\n  TSMapSlice slice = self->field_map_slices[production_id];\n  *start = &self->field_map_entries[slice.index];\n  *end = &self->field_map_entries[slice.index] + slice.length;\n}\n\nstatic inline void ts_language_aliases_for_symbol(\n  const TSLanguage *self,\n  TSSymbol original_symbol,\n  const TSSymbol **start,\n  const TSSymbol **end\n) {\n  *start = &self->public_symbol_map[original_symbol];\n  *end = *start + 1;\n\n  unsigned idx = 0;\n  for (;;) {\n    TSSymbol symbol = self->alias_map[idx++];\n    if (symbol == 0 || symbol > original_symbol) break;\n    uint16_t count = self->alias_map[idx++];\n    if (symbol == original_symbol) {\n      *start = &self->alias_map[idx];\n      *end = &self->alias_map[idx + count];\n      break;\n    }\n    idx += count;\n  }\n}\n\nstatic inline void ts_language_write_symbol_as_dot_string(\n  const TSLanguage *self,\n  FILE *f,\n  TSSymbol symbol\n) {\n  const char *name = ts_language_symbol_name(self, symbol);\n  for (const char *chr = name; *chr; chr++) {\n    switch (*chr) {\n      case '\"':\n      case '\\\\':\n        fputc('\\\\', f);\n        fputc(*chr, f);\n        break;\n      case '\\n':\n        fputs(\"\\\\n\", f);\n        break;\n      case '\\t':\n        fputs(\"\\\\t\", f);\n        break;\n      default:\n        fputc(*chr, f);\n        break;\n    }\n  }\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif  // TREE_SITTER_LANGUAGE_H_\n",
    "#include \"./length.h\"\n#include \"./lexer.h\"\n#include \"./unicode.h\"\n\n#include \"tree_sitter/api.h\"\n\n#include <stdarg.h>\n#include <stdio.h>\n\n#define LOG(message, character)              \\\n  if (self->logger.log) {                    \\\n    snprintf(                                \\\n      self->debug_buffer,                    \\\n      TREE_SITTER_SERIALIZATION_BUFFER_SIZE, \\\n      32 <= character && character < 127 ?   \\\n        message \" character:'%c'\" :          \\\n        message \" character:%d\",             \\\n      character                              \\\n    );                                       \\\n    self->logger.log(                        \\\n      self->logger.payload,                  \\\n      TSLogTypeLex,                          \\\n      self->debug_buffer                     \\\n    );                                       \\\n  }\n\nstatic const int32_t BYTE_ORDER_MARK = 0xFEFF;\n\nstatic const TSRange DEFAULT_RANGE = {\n  .start_point = {\n    .row = 0,\n    .column = 0,\n  },\n  .end_point = {\n    .row = UINT32_MAX,\n    .column = UINT32_MAX,\n  },\n  .start_byte = 0,\n  .end_byte = UINT32_MAX\n};\n\n/**\n * Sets the column data to the given value and marks it valid.\n * @param self The lexer state.\n * @param val The new value of the column data.\n */\nstatic void ts_lexer__set_column_data(Lexer *self, uint32_t val) {\n  self->column_data.valid = true;\n  self->column_data.value = val;\n}\n\n/**\n * Increments the value of the column data; no-op if invalid.\n * @param self The lexer state.\n */\nstatic void ts_lexer__increment_column_data(Lexer *self) {\n  if (self->column_data.valid) {\n    self->column_data.value++;\n  }\n}\n\n/**\n * Marks the column data as invalid.\n * @param self The lexer state.\n */\nstatic void ts_lexer__invalidate_column_data(Lexer *self) {\n  self->column_data.valid = false;\n  self->column_data.value = 0;\n}\n\n// Check if the lexer has reached EOF. This state is stored\n// by setting the lexer's `current_included_range_index` such that\n// it has consumed all of its available ranges.\nstatic bool ts_lexer__eof(const TSLexer *_self) {\n  Lexer *self = (Lexer *)_self;\n  return self->current_included_range_index == self->included_range_count;\n}\n\n// Clear the currently stored chunk of source code, because the lexer's\n// position has changed.\nstatic void ts_lexer__clear_chunk(Lexer *self) {\n  self->chunk = NULL;\n  self->chunk_size = 0;\n  self->chunk_start = 0;\n}\n\n// Call the lexer's input callback to obtain a new chunk of source code\n// for the current position.\nstatic void ts_lexer__get_chunk(Lexer *self) {\n  self->chunk_start = self->current_position.bytes;\n  self->chunk = self->input.read(\n    self->input.payload,\n    self->current_position.bytes,\n    self->current_position.extent,\n    &self->chunk_size\n  );\n  if (!self->chunk_size) {\n    self->current_included_range_index = self->included_range_count;\n    self->chunk = NULL;\n  }\n}\n\n// Decode the next unicode character in the current chunk of source code.\n// This assumes that the lexer has already retrieved a chunk of source\n// code that spans the current position.\nstatic void ts_lexer__get_lookahead(Lexer *self) {\n  uint32_t position_in_chunk = self->current_position.bytes - self->chunk_start;\n  uint32_t size = self->chunk_size - position_in_chunk;\n\n  if (size == 0) {\n    self->lookahead_size = 1;\n    self->data.lookahead = '\\0';\n    return;\n  }\n\n  const uint8_t *chunk = (const uint8_t *)self->chunk + position_in_chunk;\n  TSDecodeFunction decode =\n    self->input.encoding == TSInputEncodingUTF8    ? ts_decode_utf8     :\n    self->input.encoding == TSInputEncodingUTF16LE ? ts_decode_utf16_le :\n    self->input.encoding == TSInputEncodingUTF16BE ? ts_decode_utf16_be : self->input.decode;\n\n  self->lookahead_size = decode(chunk, size, &self->data.lookahead);\n\n  // If this chunk ended in the middle of a multi-byte character,\n  // try again with a fresh chunk.\n  if (self->data.lookahead == TS_DECODE_ERROR && size < 4) {\n    ts_lexer__get_chunk(self);\n    chunk = (const uint8_t *)self->chunk;\n    size = self->chunk_size;\n    self->lookahead_size = decode(chunk, size, &self->data.lookahead);\n  }\n\n  if (self->data.lookahead == TS_DECODE_ERROR) {\n    self->lookahead_size = 1;\n  }\n}\n\nstatic void ts_lexer_goto(Lexer *self, Length position) {\n  if (position.bytes != self->current_position.bytes) {\n    ts_lexer__invalidate_column_data(self);\n  }\n\n  self->current_position = position;\n\n  // Move to the first valid position at or after the given position.\n  bool found_included_range = false;\n  for (unsigned i = 0; i < self->included_range_count; i++) {\n    TSRange *included_range = &self->included_ranges[i];\n    if (\n      included_range->end_byte > self->current_position.bytes &&\n      included_range->end_byte > included_range->start_byte\n    ) {\n      if (included_range->start_byte >= self->current_position.bytes) {\n        self->current_position = (Length) {\n          .bytes = included_range->start_byte,\n          .extent = included_range->start_point,\n        };\n      }\n\n      self->current_included_range_index = i;\n      found_included_range = true;\n      break;\n    }\n  }\n\n  if (found_included_range) {\n    // If the current position is outside of the current chunk of text,\n    // then clear out the current chunk of text.\n    if (self->chunk && (\n      self->current_position.bytes < self->chunk_start ||\n      self->current_position.bytes >= self->chunk_start + self->chunk_size\n    )) {\n      ts_lexer__clear_chunk(self);\n    }\n\n    self->lookahead_size = 0;\n    self->data.lookahead = '\\0';\n  }\n\n  // If the given position is beyond any of included ranges, move to the EOF\n  // state - past the end of the included ranges.\n  else {\n    self->current_included_range_index = self->included_range_count;\n    TSRange *last_included_range = &self->included_ranges[self->included_range_count - 1];\n    self->current_position = (Length) {\n      .bytes = last_included_range->end_byte,\n      .extent = last_included_range->end_point,\n    };\n    ts_lexer__clear_chunk(self);\n    self->lookahead_size = 1;\n    self->data.lookahead = '\\0';\n  }\n}\n\n/**\n * Actually advances the lexer. Does not log anything.\n * @param self The lexer state.\n * @param skip Whether to mark the consumed codepoint as whitespace.\n */\nstatic void ts_lexer__do_advance(Lexer *self, bool skip) {\n  if (self->lookahead_size) {\n    if (self->data.lookahead == '\\n') {\n      self->current_position.extent.row++;\n      self->current_position.extent.column = 0;\n      ts_lexer__set_column_data(self, 0);\n    } else {\n      bool is_bom = self->current_position.bytes == 0 && \n        self->data.lookahead == BYTE_ORDER_MARK;\n      if (!is_bom) ts_lexer__increment_column_data(self);\n      self->current_position.extent.column += self->lookahead_size;\n    }\n    self->current_position.bytes += self->lookahead_size;\n  }\n\n  const TSRange *current_range = &self->included_ranges[self->current_included_range_index];\n  while (\n    self->current_position.bytes >= current_range->end_byte ||\n    current_range->end_byte == current_range->start_byte\n  ) {\n    if (self->current_included_range_index < self->included_range_count) {\n      self->current_included_range_index++;\n    }\n    if (self->current_included_range_index < self->included_range_count) {\n      current_range++;\n      self->current_position = (Length) {\n        current_range->start_byte,\n        current_range->start_point,\n      };\n    } else {\n      current_range = NULL;\n      break;\n    }\n  }\n\n  if (skip) self->token_start_position = self->current_position;\n\n  if (current_range) {\n    if (\n      self->current_position.bytes < self->chunk_start ||\n      self->current_position.bytes >= self->chunk_start + self->chunk_size\n    ) {\n      ts_lexer__get_chunk(self);\n    }\n    ts_lexer__get_lookahead(self);\n  } else {\n    ts_lexer__clear_chunk(self);\n    self->data.lookahead = '\\0';\n    self->lookahead_size = 1;\n  }\n}\n\n// Advance to the next character in the source code, retrieving a new\n// chunk of source code if needed.\nstatic void ts_lexer__advance(TSLexer *_self, bool skip) {\n  Lexer *self = (Lexer *)_self;\n  if (!self->chunk) return;\n\n  if (skip) {\n    LOG(\"skip\", self->data.lookahead)\n  } else {\n    LOG(\"consume\", self->data.lookahead)\n  }\n\n  ts_lexer__do_advance(self, skip);\n}\n\n// Mark that a token match has completed. This can be called multiple\n// times if a longer match is found later.\nstatic void ts_lexer__mark_end(TSLexer *_self) {\n  Lexer *self = (Lexer *)_self;\n  if (!ts_lexer__eof(&self->data)) {\n    // If the lexer is right at the beginning of included range,\n    // then the token should be considered to end at the *end* of the\n    // previous included range, rather than here.\n    TSRange *current_included_range = &self->included_ranges[\n      self->current_included_range_index\n    ];\n    if (\n      self->current_included_range_index > 0 &&\n      self->current_position.bytes == current_included_range->start_byte\n    ) {\n      TSRange *previous_included_range = current_included_range - 1;\n      self->token_end_position = (Length) {\n        previous_included_range->end_byte,\n        previous_included_range->end_point,\n      };\n      return;\n    }\n  }\n  self->token_end_position = self->current_position;\n}\n\nstatic uint32_t ts_lexer__get_column(TSLexer *_self) {\n  Lexer *self = (Lexer *)_self;\n\n  self->did_get_column = true;\n\n  if (!self->column_data.valid) {\n    // Record current position\n    uint32_t goal_byte = self->current_position.bytes;\n\n    // Back up to the beginning of the line\n    Length start_of_col = {\n      self->current_position.bytes - self->current_position.extent.column,\n      {self->current_position.extent.row, 0},\n    };\n    ts_lexer_goto(self, start_of_col);\n    ts_lexer__set_column_data(self, 0);\n    ts_lexer__get_chunk(self);\n\n    if (!ts_lexer__eof(_self)) {\n      ts_lexer__get_lookahead(self);\n\n      // Advance to the recorded position\n      while (self->current_position.bytes < goal_byte && !ts_lexer__eof(_self) && self->chunk) {\n        ts_lexer__do_advance(self, false);\n        if (ts_lexer__eof(_self)) break;\n      }\n    }\n  }\n\n  return self->column_data.value;\n}\n\n// Is the lexer at a boundary between two disjoint included ranges of\n// source code? This is exposed as an API because some languages' external\n// scanners need to perform custom actions at these boundaries.\nstatic bool ts_lexer__is_at_included_range_start(const TSLexer *_self) {\n  const Lexer *self = (const Lexer *)_self;\n  if (self->current_included_range_index < self->included_range_count) {\n    TSRange *current_range = &self->included_ranges[self->current_included_range_index];\n    return self->current_position.bytes == current_range->start_byte;\n  } else {\n    return false;\n  }\n}\n\nstatic void ts_lexer__log(const TSLexer *_self, const char *fmt, ...) {\n  Lexer *self = (Lexer *)_self;\n  va_list args;\n  va_start(args, fmt);\n  if (self->logger.log) {\n    vsnprintf(self->debug_buffer, TREE_SITTER_SERIALIZATION_BUFFER_SIZE, fmt, args);\n    self->logger.log(self->logger.payload, TSLogTypeLex, self->debug_buffer);\n  }\n  va_end(args);\n}\n\nvoid ts_lexer_init(Lexer *self) {\n  *self = (Lexer) {\n    .data = {\n      // The lexer's methods are stored as struct fields so that generated\n      // parsers can call them without needing to be linked against this\n      // library.\n      .advance = ts_lexer__advance,\n      .mark_end = ts_lexer__mark_end,\n      .get_column = ts_lexer__get_column,\n      .is_at_included_range_start = ts_lexer__is_at_included_range_start,\n      .eof = ts_lexer__eof,\n      .log = ts_lexer__log,\n      .lookahead = 0,\n      .result_symbol = 0,\n    },\n    .chunk = NULL,\n    .chunk_size = 0,\n    .chunk_start = 0,\n    .current_position = {0, {0, 0}},\n    .logger = {\n      .payload = NULL,\n      .log = NULL\n    },\n    .included_ranges = NULL,\n    .included_range_count = 0,\n    .current_included_range_index = 0,\n    .did_get_column = false,\n    .column_data = {\n      .valid = false,\n      .value = 0\n    }\n  };\n  ts_lexer_set_included_ranges(self, NULL, 0);\n}\n\nvoid ts_lexer_delete(Lexer *self) {\n  ts_free(self->included_ranges);\n}\n\nvoid ts_lexer_set_input(Lexer *self, TSInput input) {\n  self->input = input;\n  ts_lexer__clear_chunk(self);\n  ts_lexer_goto(self, self->current_position);\n}\n\n// Move the lexer to the given position. This doesn't do any work\n// if the parser is already at the given position.\nvoid ts_lexer_reset(Lexer *self, Length position) {\n  if (position.bytes != self->current_position.bytes) {\n    ts_lexer_goto(self, position);\n  }\n}\n\nvoid ts_lexer_start(Lexer *self) {\n  self->token_start_position = self->current_position;\n  self->token_end_position = LENGTH_UNDEFINED;\n  self->data.result_symbol = 0;\n  self->did_get_column = false;\n  if (!ts_lexer__eof(&self->data)) {\n    if (!self->chunk_size) ts_lexer__get_chunk(self);\n    if (!self->lookahead_size) ts_lexer__get_lookahead(self);\n    if (self->current_position.bytes == 0) {\n      if (self->data.lookahead == BYTE_ORDER_MARK) {\n        ts_lexer__advance(&self->data, true);\n      }\n      ts_lexer__set_column_data(self, 0);\n    }\n  }\n}\n\nvoid ts_lexer_finish(Lexer *self, uint32_t *lookahead_end_byte) {\n  if (length_is_undefined(self->token_end_position)) {\n    ts_lexer__mark_end(&self->data);\n  }\n\n  // If the token ended at an included range boundary, then its end position\n  // will have been reset to the end of the preceding range. Reset the start\n  // position to match.\n  if (self->token_end_position.bytes < self->token_start_position.bytes) {\n    self->token_start_position = self->token_end_position;\n  }\n\n  uint32_t current_lookahead_end_byte = self->current_position.bytes + 1;\n\n  // In order to determine that a byte sequence is invalid UTF8 or UTF16,\n  // the character decoding algorithm may have looked at the following byte.\n  // Therefore, the next byte *after* the current (invalid) character\n  // affects the interpretation of the current character.\n  if (self->data.lookahead == TS_DECODE_ERROR) {\n    current_lookahead_end_byte += 4; // the maximum number of bytes read to identify an invalid code point\n  }\n\n  if (current_lookahead_end_byte > *lookahead_end_byte) {\n    *lookahead_end_byte = current_lookahead_end_byte;\n  }\n}\n\nvoid ts_lexer_mark_end(Lexer *self) {\n  ts_lexer__mark_end(&self->data);\n}\n\nbool ts_lexer_set_included_ranges(\n  Lexer *self,\n  const TSRange *ranges,\n  uint32_t count\n) {\n  if (count == 0 || !ranges) {\n    ranges = &DEFAULT_RANGE;\n    count = 1;\n  } else {\n    uint32_t previous_byte = 0;\n    for (unsigned i = 0; i < count; i++) {\n      const TSRange *range = &ranges[i];\n      if (\n        range->start_byte < previous_byte ||\n        range->end_byte < range->start_byte\n      ) return false;\n      previous_byte = range->end_byte;\n    }\n  }\n\n  size_t size = count * sizeof(TSRange);\n  self->included_ranges = ts_realloc(self->included_ranges, size);\n  memcpy(self->included_ranges, ranges, size);\n  self->included_range_count = count;\n  ts_lexer_goto(self, self->current_position);\n  return true;\n}\n\nTSRange *ts_lexer_included_ranges(const Lexer *self, uint32_t *count) {\n  *count = self->included_range_count;\n  return self->included_ranges;\n}\n\n#undef LOG\n",
    "#ifndef TREE_SITTER_UNICODE_H_\n#define TREE_SITTER_UNICODE_H_\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <limits.h>\n#include <stdint.h>\n\n#define U_EXPORT\n#define U_EXPORT2\n#include \"unicode/utf8.h\"\n#include \"unicode/utf16.h\"\n#include \"portable/endian.h\"\n\n#define U16_NEXT_LE(s, i, length, c) UPRV_BLOCK_MACRO_BEGIN { \\\n    (c)=le16toh((s)[(i)++]); \\\n    if(U16_IS_LEAD(c)) { \\\n        uint16_t __c2; \\\n        if((i)!=(length) && U16_IS_TRAIL(__c2=(s)[(i)])) { \\\n            ++(i); \\\n            (c)=U16_GET_SUPPLEMENTARY((c), __c2); \\\n        } \\\n    } \\\n} UPRV_BLOCK_MACRO_END\n\n#define U16_NEXT_BE(s, i, length, c) UPRV_BLOCK_MACRO_BEGIN { \\\n    (c)=be16toh((s)[(i)++]); \\\n    if(U16_IS_LEAD(c)) { \\\n        uint16_t __c2; \\\n        if((i)!=(length) && U16_IS_TRAIL(__c2=(s)[(i)])) { \\\n            ++(i); \\\n            (c)=U16_GET_SUPPLEMENTARY((c), __c2); \\\n        } \\\n    } \\\n} UPRV_BLOCK_MACRO_END\n\nstatic const int32_t TS_DECODE_ERROR = U_SENTINEL;\n\nstatic inline uint32_t ts_decode_utf8(\n  const uint8_t *string,\n  uint32_t length,\n  int32_t *code_point\n) {\n  uint32_t i = 0;\n  U8_NEXT(string, i, length, *code_point);\n  return i;\n}\n\nstatic inline uint32_t ts_decode_utf16_le(\n  const uint8_t *string,\n  uint32_t length,\n  int32_t *code_point\n) {\n  uint32_t i = 0;\n  U16_NEXT_LE(((uint16_t *)string), i, length, *code_point);\n  return i * 2;\n}\n\nstatic inline uint32_t ts_decode_utf16_be(\n  const uint8_t *string,\n  uint32_t length,\n  int32_t *code_point\n) {\n  uint32_t i = 0;\n  U16_NEXT_BE(((uint16_t *)string), i, length, *code_point);\n  return i * 2;\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif  // TREE_SITTER_UNICODE_H_\n",
    "#include <stdbool.h>\n#include \"./point.h\"\n#include \"./subtree.h\"\n#include \"./tree.h\"\n#include \"./language.h\"\n\ntypedef struct {\n  Subtree parent;\n  const TSTree *tree;\n  Length position;\n  uint32_t child_index;\n  uint32_t structural_child_index;\n  const TSSymbol *alias_sequence;\n} NodeChildIterator;\n\nstatic inline bool ts_node__is_relevant(TSNode self, bool include_anonymous);\n\n// TSNode - constructors\n\nTSNode ts_node_new(\n  const TSTree *tree,\n  const Subtree *subtree,\n  Length position,\n  TSSymbol alias\n) {\n  return (TSNode) {\n    {position.bytes, position.extent.row, position.extent.column, alias},\n    subtree,\n    tree,\n  };\n}\n\nstatic inline TSNode ts_node__null(void) {\n  return ts_node_new(NULL, NULL, length_zero(), 0);\n}\n\n// TSNode - accessors\n\nuint32_t ts_node_start_byte(TSNode self) {\n  return self.context[0];\n}\n\nTSPoint ts_node_start_point(TSNode self) {\n  return (TSPoint) {self.context[1], self.context[2]};\n}\n\nstatic inline uint32_t ts_node__alias(const TSNode *self) {\n  return self->context[3];\n}\n\nstatic inline Subtree ts_node__subtree(TSNode self) {\n  return *(const Subtree *)self.id;\n}\n\n// NodeChildIterator\n\nstatic inline NodeChildIterator ts_node_iterate_children(const TSNode *node) {\n  Subtree subtree = ts_node__subtree(*node);\n  if (ts_subtree_child_count(subtree) == 0) {\n    return (NodeChildIterator) {NULL_SUBTREE, node->tree, length_zero(), 0, 0, NULL};\n  }\n  const TSSymbol *alias_sequence = ts_language_alias_sequence(\n    node->tree->language,\n    subtree.ptr->production_id\n  );\n  return (NodeChildIterator) {\n    .tree = node->tree,\n    .parent = subtree,\n    .position = {ts_node_start_byte(*node), ts_node_start_point(*node)},\n    .child_index = 0,\n    .structural_child_index = 0,\n    .alias_sequence = alias_sequence,\n  };\n}\n\nstatic inline bool ts_node_child_iterator_done(NodeChildIterator *self) {\n  return self->child_index == self->parent.ptr->child_count;\n}\n\nstatic inline bool ts_node_child_iterator_next(\n  NodeChildIterator *self,\n  TSNode *result\n) {\n  if (!self->parent.ptr || ts_node_child_iterator_done(self)) return false;\n  const Subtree *child = &ts_subtree_children(self->parent)[self->child_index];\n  TSSymbol alias_symbol = 0;\n  if (!ts_subtree_extra(*child)) {\n    if (self->alias_sequence) {\n      alias_symbol = self->alias_sequence[self->structural_child_index];\n    }\n    self->structural_child_index++;\n  }\n  if (self->child_index > 0) {\n    self->position = length_add(self->position, ts_subtree_padding(*child));\n  }\n  *result = ts_node_new(\n    self->tree,\n    child,\n    self->position,\n    alias_symbol\n  );\n  self->position = length_add(self->position, ts_subtree_size(*child));\n  self->child_index++;\n  return true;\n}\n\n// TSNode - private\n\nstatic inline bool ts_node__is_relevant(TSNode self, bool include_anonymous) {\n  Subtree tree = ts_node__subtree(self);\n  if (include_anonymous) {\n    return ts_subtree_visible(tree) || ts_node__alias(&self);\n  } else {\n    TSSymbol alias = ts_node__alias(&self);\n    if (alias) {\n      return ts_language_symbol_metadata(self.tree->language, alias).named;\n    } else {\n      return ts_subtree_visible(tree) && ts_subtree_named(tree);\n    }\n  }\n}\n\nstatic inline uint32_t ts_node__relevant_child_count(\n  TSNode self,\n  bool include_anonymous\n) {\n  Subtree tree = ts_node__subtree(self);\n  if (ts_subtree_child_count(tree) > 0) {\n    if (include_anonymous) {\n      return tree.ptr->visible_child_count;\n    } else {\n      return tree.ptr->named_child_count;\n    }\n  } else {\n    return 0;\n  }\n}\n\nstatic inline TSNode ts_node__child(\n  TSNode self,\n  uint32_t child_index,\n  bool include_anonymous\n) {\n  TSNode result = self;\n  bool did_descend = true;\n\n  while (did_descend) {\n    did_descend = false;\n\n    TSNode child;\n    uint32_t index = 0;\n    NodeChildIterator iterator = ts_node_iterate_children(&result);\n    while (ts_node_child_iterator_next(&iterator, &child)) {\n      if (ts_node__is_relevant(child, include_anonymous)) {\n        if (index == child_index) {\n          return child;\n        }\n        index++;\n      } else {\n        uint32_t grandchild_index = child_index - index;\n        uint32_t grandchild_count = ts_node__relevant_child_count(child, include_anonymous);\n        if (grandchild_index < grandchild_count) {\n          did_descend = true;\n          result = child;\n          child_index = grandchild_index;\n          break;\n        }\n        index += grandchild_count;\n      }\n    }\n  }\n\n  return ts_node__null();\n}\n\nstatic bool ts_subtree_has_trailing_empty_descendant(\n  Subtree self,\n  Subtree other\n) {\n  for (unsigned i = ts_subtree_child_count(self) - 1; i + 1 > 0; i--) {\n    Subtree child = ts_subtree_children(self)[i];\n    if (ts_subtree_total_bytes(child) > 0) break;\n    if (child.ptr == other.ptr || ts_subtree_has_trailing_empty_descendant(child, other)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nstatic inline TSNode ts_node__prev_sibling(TSNode self, bool include_anonymous) {\n  Subtree self_subtree = ts_node__subtree(self);\n  bool self_is_empty = ts_subtree_total_bytes(self_subtree) == 0;\n  uint32_t target_end_byte = ts_node_end_byte(self);\n\n  TSNode node = ts_node_parent(self);\n  TSNode earlier_node = ts_node__null();\n  bool earlier_node_is_relevant = false;\n\n  while (!ts_node_is_null(node)) {\n    TSNode earlier_child = ts_node__null();\n    bool earlier_child_is_relevant = false;\n    bool found_child_containing_target = false;\n\n    TSNode child;\n    NodeChildIterator iterator = ts_node_iterate_children(&node);\n    while (ts_node_child_iterator_next(&iterator, &child)) {\n      if (child.id == self.id) break;\n      if (iterator.position.bytes > target_end_byte) {\n        found_child_containing_target = true;\n        break;\n      }\n\n      if (iterator.position.bytes == target_end_byte &&\n          (!self_is_empty ||\n           ts_subtree_has_trailing_empty_descendant(ts_node__subtree(child), self_subtree))) {\n        found_child_containing_target = true;\n        break;\n      }\n\n      if (ts_node__is_relevant(child, include_anonymous)) {\n        earlier_child = child;\n        earlier_child_is_relevant = true;\n      } else if (ts_node__relevant_child_count(child, include_anonymous) > 0) {\n        earlier_child = child;\n        earlier_child_is_relevant = false;\n      }\n    }\n\n    if (found_child_containing_target) {\n      if (!ts_node_is_null(earlier_child)) {\n        earlier_node = earlier_child;\n        earlier_node_is_relevant = earlier_child_is_relevant;\n      }\n      node = child;\n    } else if (earlier_child_is_relevant) {\n      return earlier_child;\n    } else if (!ts_node_is_null(earlier_child)) {\n      node = earlier_child;\n    } else if (earlier_node_is_relevant) {\n      return earlier_node;\n    } else {\n      node = earlier_node;\n      earlier_node = ts_node__null();\n      earlier_node_is_relevant = false;\n    }\n  }\n\n  return ts_node__null();\n}\n\nstatic inline TSNode ts_node__next_sibling(TSNode self, bool include_anonymous) {\n  uint32_t target_end_byte = ts_node_end_byte(self);\n\n  TSNode node = ts_node_parent(self);\n  TSNode later_node = ts_node__null();\n  bool later_node_is_relevant = false;\n\n  while (!ts_node_is_null(node)) {\n    TSNode later_child = ts_node__null();\n    bool later_child_is_relevant = false;\n    TSNode child_containing_target = ts_node__null();\n\n    TSNode child;\n    NodeChildIterator iterator = ts_node_iterate_children(&node);\n    while (ts_node_child_iterator_next(&iterator, &child)) {\n      if (iterator.position.bytes <= target_end_byte) continue;\n      uint32_t start_byte = ts_node_start_byte(self);\n      uint32_t child_start_byte = ts_node_start_byte(child);\n\n      bool is_empty = start_byte == target_end_byte;\n      bool contains_target = is_empty ?\n        child_start_byte < start_byte :\n        child_start_byte <= start_byte;\n\n      if (contains_target) {\n        if (ts_node__subtree(child).ptr != ts_node__subtree(self).ptr) {\n          child_containing_target = child;\n        }\n      } else if (ts_node__is_relevant(child, include_anonymous)) {\n        later_child = child;\n        later_child_is_relevant = true;\n        break;\n      } else if (ts_node__relevant_child_count(child, include_anonymous) > 0) {\n        later_child = child;\n        later_child_is_relevant = false;\n        break;\n      }\n    }\n\n    if (!ts_node_is_null(child_containing_target)) {\n      if (!ts_node_is_null(later_child)) {\n        later_node = later_child;\n        later_node_is_relevant = later_child_is_relevant;\n      }\n      node = child_containing_target;\n    } else if (later_child_is_relevant) {\n      return later_child;\n    } else if (!ts_node_is_null(later_child)) {\n      node = later_child;\n    } else if (later_node_is_relevant) {\n      return later_node;\n    } else {\n      node = later_node;\n    }\n  }\n\n  return ts_node__null();\n}\n\nstatic inline TSNode ts_node__first_child_for_byte(\n  TSNode self,\n  uint32_t goal,\n  bool include_anonymous\n) {\n  TSNode node = self;\n  bool did_descend = true;\n\n  NodeChildIterator last_iterator;\n  bool has_last_iterator = false;\n\n  while (did_descend) {\n    did_descend = false;\n\n    TSNode child;\n    NodeChildIterator iterator = ts_node_iterate_children(&node);\n  loop:\n    while (ts_node_child_iterator_next(&iterator, &child)) {\n      if (ts_node_end_byte(child) > goal) {\n        if (ts_node__is_relevant(child, include_anonymous)) {\n          return child;\n        } else if (ts_node_child_count(child) > 0) {\n          if (iterator.child_index < ts_subtree_child_count(ts_node__subtree(child))) {\n            last_iterator = iterator;\n            has_last_iterator = true;\n          }\n          did_descend = true;\n          node = child;\n          break;\n        }\n      }\n    }\n\n    if (!did_descend && has_last_iterator) {\n      iterator = last_iterator;\n      has_last_iterator = false;\n      goto loop;\n    }\n  }\n\n  return ts_node__null();\n}\n\nstatic inline TSNode ts_node__descendant_for_byte_range(\n  TSNode self,\n  uint32_t range_start,\n  uint32_t range_end,\n  bool include_anonymous\n) {\n  if (range_start > range_end) {\n    return ts_node__null();\n  }\n  TSNode node = self;\n  TSNode last_visible_node = self;\n\n  bool did_descend = true;\n  while (did_descend) {\n    did_descend = false;\n\n    TSNode child;\n    NodeChildIterator iterator = ts_node_iterate_children(&node);\n    while (ts_node_child_iterator_next(&iterator, &child)) {\n      uint32_t node_end = iterator.position.bytes;\n\n      // The end of this node must extend far enough forward to touch\n      // the end of the range\n      if (node_end < range_end) continue;\n\n      // ...and exceed the start of the range, unless the node itself is\n      // empty, in which case it must at least be equal to the start of the range.\n      bool is_empty = ts_node_start_byte(child) == node_end;\n      if (is_empty ? node_end < range_start : node_end <= range_start) continue;\n\n      // The start of this node must extend far enough backward to\n      // touch the start of the range.\n      if (range_start < ts_node_start_byte(child)) break;\n\n      node = child;\n      if (ts_node__is_relevant(node, include_anonymous)) {\n        last_visible_node = node;\n      }\n      did_descend = true;\n      break;\n    }\n  }\n\n  return last_visible_node;\n}\n\nstatic inline TSNode ts_node__descendant_for_point_range(\n  TSNode self,\n  TSPoint range_start,\n  TSPoint range_end,\n  bool include_anonymous\n) {\n  if (point_gt(range_start, range_end)) {\n    return ts_node__null();\n  }\n  TSNode node = self;\n  TSNode last_visible_node = self;\n\n  bool did_descend = true;\n  while (did_descend) {\n    did_descend = false;\n\n    TSNode child;\n    NodeChildIterator iterator = ts_node_iterate_children(&node);\n    while (ts_node_child_iterator_next(&iterator, &child)) {\n      TSPoint node_end = iterator.position.extent;\n\n      // The end of this node must extend far enough forward to touch\n      // the end of the range\n      if (point_lt(node_end, range_end)) continue;\n\n      // ...and exceed the start of the range, unless the node itself is\n      // empty, in which case it must at least be equal to the start of the range.\n      bool is_empty =  point_eq(ts_node_start_point(child), node_end);\n      if (is_empty ? point_lt(node_end, range_start) : point_lte(node_end, range_start)) {\n        continue;\n      }\n\n      // The start of this node must extend far enough backward to\n      // touch the start of the range.\n      if (point_lt(range_start, ts_node_start_point(child))) break;\n\n      node = child;\n      if (ts_node__is_relevant(node, include_anonymous)) {\n        last_visible_node = node;\n      }\n      did_descend = true;\n      break;\n    }\n  }\n\n  return last_visible_node;\n}\n\n// TSNode - public\n\nuint32_t ts_node_end_byte(TSNode self) {\n  return ts_node_start_byte(self) + ts_subtree_size(ts_node__subtree(self)).bytes;\n}\n\nTSPoint ts_node_end_point(TSNode self) {\n  return point_add(ts_node_start_point(self), ts_subtree_size(ts_node__subtree(self)).extent);\n}\n\nTSSymbol ts_node_symbol(TSNode self) {\n  TSSymbol symbol = ts_node__alias(&self);\n  if (!symbol) symbol = ts_subtree_symbol(ts_node__subtree(self));\n  return ts_language_public_symbol(self.tree->language, symbol);\n}\n\nconst char *ts_node_type(TSNode self) {\n  TSSymbol symbol = ts_node__alias(&self);\n  if (!symbol) symbol = ts_subtree_symbol(ts_node__subtree(self));\n  return ts_language_symbol_name(self.tree->language, symbol);\n}\n\nconst TSLanguage *ts_node_language(TSNode self) {\n  return self.tree->language;\n}\n\nTSSymbol ts_node_grammar_symbol(TSNode self) {\n  return ts_subtree_symbol(ts_node__subtree(self));\n}\n\nconst char *ts_node_grammar_type(TSNode self) {\n  TSSymbol symbol = ts_subtree_symbol(ts_node__subtree(self));\n  return ts_language_symbol_name(self.tree->language, symbol);\n}\n\nchar *ts_node_string(TSNode self) {\n  TSSymbol alias_symbol = ts_node__alias(&self);\n  return ts_subtree_string(\n    ts_node__subtree(self),\n    alias_symbol,\n    ts_language_symbol_metadata(self.tree->language, alias_symbol).visible,\n    self.tree->language,\n    false\n  );\n}\n\nbool ts_node_eq(TSNode self, TSNode other) {\n  return self.tree == other.tree && self.id == other.id;\n}\n\nbool ts_node_is_null(TSNode self) {\n  return self.id == 0;\n}\n\nbool ts_node_is_extra(TSNode self) {\n  return ts_subtree_extra(ts_node__subtree(self));\n}\n\nbool ts_node_is_named(TSNode self) {\n  TSSymbol alias = ts_node__alias(&self);\n  return alias\n    ? ts_language_symbol_metadata(self.tree->language, alias).named\n    : ts_subtree_named(ts_node__subtree(self));\n}\n\nbool ts_node_is_missing(TSNode self) {\n  return ts_subtree_missing(ts_node__subtree(self));\n}\n\nbool ts_node_has_changes(TSNode self) {\n  return ts_subtree_has_changes(ts_node__subtree(self));\n}\n\nbool ts_node_has_error(TSNode self) {\n  return ts_subtree_error_cost(ts_node__subtree(self)) > 0;\n}\n\nbool ts_node_is_error(TSNode self) {\n  TSSymbol symbol = ts_node_symbol(self);\n  return symbol == ts_builtin_sym_error;\n}\n\nuint32_t ts_node_descendant_count(TSNode self) {\n  return ts_subtree_visible_descendant_count(ts_node__subtree(self)) + 1;\n}\n\nTSStateId ts_node_parse_state(TSNode self) {\n  return ts_subtree_parse_state(ts_node__subtree(self));\n}\n\nTSStateId ts_node_next_parse_state(TSNode self) {\n  const TSLanguage *language = self.tree->language;\n  uint16_t state = ts_node_parse_state(self);\n  if (state == TS_TREE_STATE_NONE) {\n    return TS_TREE_STATE_NONE;\n  }\n  uint16_t symbol = ts_node_grammar_symbol(self);\n  return ts_language_next_state(language, state, symbol);\n}\n\nTSNode ts_node_parent(TSNode self) {\n  TSNode node = ts_tree_root_node(self.tree);\n  if (node.id == self.id) return ts_node__null();\n\n  while (true) {\n    TSNode next_node = ts_node_child_with_descendant(node, self);\n    if (next_node.id == self.id || ts_node_is_null(next_node)) break;\n    node = next_node;\n  }\n\n  return node;\n}\n\nTSNode ts_node_child_with_descendant(TSNode self, TSNode descendant) {\n  uint32_t start_byte = ts_node_start_byte(descendant);\n  uint32_t end_byte = ts_node_end_byte(descendant);\n  bool is_empty = start_byte == end_byte;\n\n  do {\n    NodeChildIterator iter = ts_node_iterate_children(&self);\n    do {\n      if (\n        !ts_node_child_iterator_next(&iter, &self)\n        || ts_node_start_byte(self) > start_byte\n      ) {\n        return ts_node__null();\n      }\n      if (self.id == descendant.id) {\n        return self;\n      }\n\n      // If the descendant is empty, and the end byte is within `self`,\n      // we check whether `self` contains it or not.\n      if (is_empty && iter.position.bytes >= end_byte && ts_node_child_count(self) > 0) {\n        TSNode child = ts_node_child_with_descendant(self, descendant);\n        // If the child is not null, return self if it's relevant, else return the child\n        if (!ts_node_is_null(child)) {\n          return ts_node__is_relevant(self, true) ? self : child;\n        }\n      }\n    } while ((is_empty ? iter.position.bytes <= end_byte : iter.position.bytes < end_byte) || ts_node_child_count(self) == 0);\n  } while (!ts_node__is_relevant(self, true));\n\n  return self;\n}\n\nTSNode ts_node_child(TSNode self, uint32_t child_index) {\n  return ts_node__child(self, child_index, true);\n}\n\nTSNode ts_node_named_child(TSNode self, uint32_t child_index) {\n  return ts_node__child(self, child_index, false);\n}\n\nTSNode ts_node_child_by_field_id(TSNode self, TSFieldId field_id) {\nrecur:\n  if (!field_id || ts_node_child_count(self) == 0) return ts_node__null();\n\n  const TSFieldMapEntry *field_map, *field_map_end;\n  ts_language_field_map(\n    self.tree->language,\n    ts_node__subtree(self).ptr->production_id,\n    &field_map,\n    &field_map_end\n  );\n  if (field_map == field_map_end) return ts_node__null();\n\n  // The field mappings are sorted by their field id. Scan all\n  // the mappings to find the ones for the given field id.\n  while (field_map->field_id < field_id) {\n    field_map++;\n    if (field_map == field_map_end) return ts_node__null();\n  }\n  while (field_map_end[-1].field_id > field_id) {\n    field_map_end--;\n    if (field_map == field_map_end) return ts_node__null();\n  }\n\n  TSNode child;\n  NodeChildIterator iterator = ts_node_iterate_children(&self);\n  while (ts_node_child_iterator_next(&iterator, &child)) {\n    if (!ts_subtree_extra(ts_node__subtree(child))) {\n      uint32_t index = iterator.structural_child_index - 1;\n      if (index < field_map->child_index) continue;\n\n      // Hidden nodes' fields are \"inherited\" by their visible parent.\n      if (field_map->inherited) {\n\n        // If this is the *last* possible child node for this field,\n        // then perform a tail call to avoid recursion.\n        if (field_map + 1 == field_map_end) {\n          self = child;\n          goto recur;\n        }\n\n        // Otherwise, descend into this child, but if it doesn't contain\n        // the field, continue searching subsequent children.\n        else {\n          TSNode result = ts_node_child_by_field_id(child, field_id);\n          if (result.id) return result;\n          field_map++;\n          if (field_map == field_map_end) return ts_node__null();\n        }\n      }\n\n      else if (ts_node__is_relevant(child, true)) {\n        return child;\n      }\n\n      // If the field refers to a hidden node with visible children,\n      // return the first visible child.\n      else if (ts_node_child_count(child) > 0 ) {\n        return ts_node_child(child, 0);\n      }\n\n      // Otherwise, continue searching subsequent children.\n      else {\n        field_map++;\n        if (field_map == field_map_end) return ts_node__null();\n      }\n    }\n  }\n\n  return ts_node__null();\n}\n\nstatic inline const char *ts_node__field_name_from_language(TSNode self, uint32_t structural_child_index) {\n    const TSFieldMapEntry *field_map, *field_map_end;\n    ts_language_field_map(\n      self.tree->language,\n      ts_node__subtree(self).ptr->production_id,\n      &field_map,\n      &field_map_end\n    );\n    for (; field_map != field_map_end; field_map++) {\n      if (!field_map->inherited && field_map->child_index == structural_child_index) {\n        return self.tree->language->field_names[field_map->field_id];\n      }\n    }\n    return NULL;\n}\n\nconst char *ts_node_field_name_for_child(TSNode self, uint32_t child_index) {\n  TSNode result = self;\n  bool did_descend = true;\n  const char *inherited_field_name = NULL;\n\n  while (did_descend) {\n    did_descend = false;\n\n    TSNode child;\n    uint32_t index = 0;\n    NodeChildIterator iterator = ts_node_iterate_children(&result);\n    while (ts_node_child_iterator_next(&iterator, &child)) {\n      if (ts_node__is_relevant(child, true)) {\n        if (index == child_index) {\n          if (ts_node_is_extra(child)) {\n            return NULL;\n          }\n          const char *field_name = ts_node__field_name_from_language(result, iterator.structural_child_index - 1);\n          if (field_name) return field_name;\n          return inherited_field_name;\n        }\n        index++;\n      } else {\n        uint32_t grandchild_index = child_index - index;\n        uint32_t grandchild_count = ts_node__relevant_child_count(child, true);\n        if (grandchild_index < grandchild_count) {\n          const char *field_name = ts_node__field_name_from_language(result, iterator.structural_child_index - 1);\n          if (field_name) inherited_field_name = field_name;\n\n          did_descend = true;\n          result = child;\n          child_index = grandchild_index;\n          break;\n        }\n        index += grandchild_count;\n      }\n    }\n  }\n\n  return NULL;\n}\n\nconst char *ts_node_field_name_for_named_child(TSNode self, uint32_t named_child_index) {\n  TSNode result = self;\n  bool did_descend = true;\n  const char *inherited_field_name = NULL;\n\n  while (did_descend) {\n    did_descend = false;\n\n    TSNode child;\n    uint32_t index = 0;\n    NodeChildIterator iterator = ts_node_iterate_children(&result);\n    while (ts_node_child_iterator_next(&iterator, &child)) {\n      if (ts_node__is_relevant(child, false)) {\n        if (index == named_child_index) {\n          if (ts_node_is_extra(child)) {\n            return NULL;\n          }\n          const char *field_name = ts_node__field_name_from_language(result, iterator.structural_child_index - 1);\n          if (field_name) return field_name;\n          return inherited_field_name;\n        }\n        index++;\n      } else {\n        uint32_t named_grandchild_index = named_child_index - index;\n        uint32_t grandchild_count = ts_node__relevant_child_count(child, false);\n        if (named_grandchild_index < grandchild_count) {\n          const char *field_name = ts_node__field_name_from_language(result, iterator.structural_child_index - 1);\n          if (field_name) inherited_field_name = field_name;\n\n          did_descend = true;\n          result = child;\n          named_child_index = named_grandchild_index;\n          break;\n        }\n        index += grandchild_count;\n      }\n    }\n  }\n\n  return NULL;\n}\n\nTSNode ts_node_child_by_field_name(\n  TSNode self,\n  const char *name,\n  uint32_t name_length\n) {\n  TSFieldId field_id = ts_language_field_id_for_name(\n    self.tree->language,\n    name,\n    name_length\n  );\n  return ts_node_child_by_field_id(self, field_id);\n}\n\nuint32_t ts_node_child_count(TSNode self) {\n  Subtree tree = ts_node__subtree(self);\n  if (ts_subtree_child_count(tree) > 0) {\n    return tree.ptr->visible_child_count;\n  } else {\n    return 0;\n  }\n}\n\nuint32_t ts_node_named_child_count(TSNode self) {\n  Subtree tree = ts_node__subtree(self);\n  if (ts_subtree_child_count(tree) > 0) {\n    return tree.ptr->named_child_count;\n  } else {\n    return 0;\n  }\n}\n\nTSNode ts_node_next_sibling(TSNode self) {\n  return ts_node__next_sibling(self, true);\n}\n\nTSNode ts_node_next_named_sibling(TSNode self) {\n  return ts_node__next_sibling(self, false);\n}\n\nTSNode ts_node_prev_sibling(TSNode self) {\n  return ts_node__prev_sibling(self, true);\n}\n\nTSNode ts_node_prev_named_sibling(TSNode self) {\n  return ts_node__prev_sibling(self, false);\n}\n\nTSNode ts_node_first_child_for_byte(TSNode self, uint32_t byte) {\n  return ts_node__first_child_for_byte(self, byte, true);\n}\n\nTSNode ts_node_first_named_child_for_byte(TSNode self, uint32_t byte) {\n  return ts_node__first_child_for_byte(self, byte, false);\n}\n\nTSNode ts_node_descendant_for_byte_range(\n  TSNode self,\n  uint32_t start,\n  uint32_t end\n) {\n  return ts_node__descendant_for_byte_range(self, start, end, true);\n}\n\nTSNode ts_node_named_descendant_for_byte_range(\n  TSNode self,\n  uint32_t start,\n  uint32_t end\n) {\n  return ts_node__descendant_for_byte_range(self, start, end, false);\n}\n\nTSNode ts_node_descendant_for_point_range(\n  TSNode self,\n  TSPoint start,\n  TSPoint end\n) {\n  return ts_node__descendant_for_point_range(self, start, end, true);\n}\n\nTSNode ts_node_named_descendant_for_point_range(\n  TSNode self,\n  TSPoint start,\n  TSPoint end\n) {\n  return ts_node__descendant_for_point_range(self, start, end, false);\n}\n\nvoid ts_node_edit(TSNode *self, const TSInputEdit *edit) {\n  uint32_t start_byte = ts_node_start_byte(*self);\n  TSPoint start_point = ts_node_start_point(*self);\n\n  ts_point_edit(&start_point, &start_byte, edit);\n\n  self->context[0] = start_byte;\n  self->context[1] = start_point.row;\n  self->context[2] = start_point.column;\n}\n",
    "#include \"tree_sitter/api.h\"\n#include \"./array.h\"\n#include \"./get_changed_ranges.h\"\n#include \"./length.h\"\n#include \"./subtree.h\"\n#include \"./tree_cursor.h\"\n#include \"./tree.h\"\n\nTSTree *ts_tree_new(\n  Subtree root, const TSLanguage *language,\n  const TSRange *included_ranges, unsigned included_range_count\n) {\n  TSTree *result = ts_malloc(sizeof(TSTree));\n  result->root = root;\n  result->language = ts_language_copy(language);\n  result->included_ranges = ts_calloc(included_range_count, sizeof(TSRange));\n  memcpy(result->included_ranges, included_ranges, included_range_count * sizeof(TSRange));\n  result->included_range_count = included_range_count;\n  return result;\n}\n\nTSTree *ts_tree_copy(const TSTree *self) {\n  ts_subtree_retain(self->root);\n  return ts_tree_new(self->root, self->language, self->included_ranges, self->included_range_count);\n}\n\nvoid ts_tree_delete(TSTree *self) {\n  if (!self) return;\n\n  SubtreePool pool = ts_subtree_pool_new(0);\n  ts_subtree_release(&pool, self->root);\n  ts_subtree_pool_delete(&pool);\n  ts_language_delete(self->language);\n  ts_free(self->included_ranges);\n  ts_free(self);\n}\n\nTSNode ts_tree_root_node(const TSTree *self) {\n  return ts_node_new(self, &self->root, ts_subtree_padding(self->root), 0);\n}\n\nTSNode ts_tree_root_node_with_offset(\n  const TSTree *self,\n  uint32_t offset_bytes,\n  TSPoint offset_extent\n) {\n  Length offset = {offset_bytes, offset_extent};\n  return ts_node_new(self, &self->root, length_add(offset, ts_subtree_padding(self->root)), 0);\n}\n\nconst TSLanguage *ts_tree_language(const TSTree *self) {\n  return self->language;\n}\n\nvoid ts_tree_edit(TSTree *self, const TSInputEdit *edit) {\n  for (unsigned i = 0; i < self->included_range_count; i++) {\n    ts_range_edit(&self->included_ranges[i], edit);\n  }\n\n  SubtreePool pool = ts_subtree_pool_new(0);\n  self->root = ts_subtree_edit(self->root, edit, &pool);\n  ts_subtree_pool_delete(&pool);\n}\n\nTSRange *ts_tree_included_ranges(const TSTree *self, uint32_t *length) {\n  *length = self->included_range_count;\n  TSRange *ranges = ts_calloc(self->included_range_count, sizeof(TSRange));\n  memcpy(ranges, self->included_ranges, self->included_range_count * sizeof(TSRange));\n  return ranges;\n}\n\nTSRange *ts_tree_get_changed_ranges(const TSTree *old_tree, const TSTree *new_tree, uint32_t *length) {\n  TreeCursor cursor1 = {NULL, array_new(), 0};\n  TreeCursor cursor2 = {NULL, array_new(), 0};\n  ts_tree_cursor_init(&cursor1, ts_tree_root_node(old_tree));\n  ts_tree_cursor_init(&cursor2, ts_tree_root_node(new_tree));\n\n  TSRangeArray included_range_differences = array_new();\n  ts_range_array_get_changed_ranges(\n    old_tree->included_ranges, old_tree->included_range_count,\n    new_tree->included_ranges, new_tree->included_range_count,\n    &included_range_differences\n  );\n\n  TSRange *result;\n  *length = ts_subtree_get_changed_ranges(\n    &old_tree->root, &new_tree->root, &cursor1, &cursor2,\n    old_tree->language, &included_range_differences, &result\n  );\n\n  array_delete(&included_range_differences);\n  array_delete(&cursor1.stack);\n  array_delete(&cursor2.stack);\n  return result;\n}\n\n#ifdef _WIN32\n\n#include <io.h>\n#include <windows.h>\n\nint _ts_dup(HANDLE handle) {\n  HANDLE dup_handle;\n  if (!DuplicateHandle(\n    GetCurrentProcess(), handle,\n    GetCurrentProcess(), &dup_handle,\n    0, FALSE, DUPLICATE_SAME_ACCESS\n  )) return -1;\n\n  return _open_osfhandle((intptr_t)dup_handle, 0);\n}\n\nvoid ts_tree_print_dot_graph(const TSTree *self, int fd) {\n  FILE *file = _fdopen(_ts_dup((HANDLE)_get_osfhandle(fd)), \"a\");\n  ts_subtree_print_dot_graph(self->root, self->language, file);\n  fclose(file);\n}\n\n#elif !defined(__wasm__) // Wasm doesn't support dup\n\n#include <unistd.h>\n\nint _ts_dup(int file_descriptor) {\n  return dup(file_descriptor);\n}\n\nvoid ts_tree_print_dot_graph(const TSTree *self, int file_descriptor) {\n  FILE *file = fdopen(_ts_dup(file_descriptor), \"a\");\n  ts_subtree_print_dot_graph(self->root, self->language, file);\n  fclose(file);\n}\n\n#else\n\nvoid ts_tree_print_dot_graph(const TSTree *self, int file_descriptor) {\n  (void)self;\n  (void)file_descriptor;\n}\n\n#endif\n",
    "#include \"point.h\"\n\nvoid ts_point_edit(TSPoint *point, uint32_t *byte, const TSInputEdit *edit) {\n  uint32_t start_byte = *byte;\n  TSPoint start_point = *point;\n\n  if (start_byte >= edit->old_end_byte) {\n    start_byte = edit->new_end_byte + (start_byte - edit->old_end_byte);\n    start_point = point_add(edit->new_end_point, point_sub(start_point, edit->old_end_point));\n  } else if (start_byte > edit->start_byte) {\n    start_byte = edit->new_end_byte;\n    start_point = edit->new_end_point;\n  }\n\n  *point = start_point;\n  *byte = start_byte;\n}\n",
    "#include <stdio.h>\n#include <limits.h>\n#include <stdbool.h>\n#include <inttypes.h>\n#include \"tree_sitter/api.h\"\n#include \"./alloc.h\"\n#include \"./array.h\"\n#include \"./error_costs.h\"\n#include \"./get_changed_ranges.h\"\n#include \"./language.h\"\n#include \"./length.h\"\n#include \"./lexer.h\"\n#include \"./reduce_action.h\"\n#include \"./reusable_node.h\"\n#include \"./stack.h\"\n#include \"./subtree.h\"\n#include \"./tree.h\"\n#include \"./ts_assert.h\"\n#include \"./wasm_store.h\"\n\n#define LOG(...)                                                                            \\\n  if (self->lexer.logger.log || self->dot_graph_file) {                                     \\\n    snprintf(self->lexer.debug_buffer, TREE_SITTER_SERIALIZATION_BUFFER_SIZE, __VA_ARGS__); \\\n    ts_parser__log(self);                                                                   \\\n  }\n\n#define LOG_LOOKAHEAD(symbol_name, size)                      \\\n  if (self->lexer.logger.log || self->dot_graph_file) {       \\\n    char *buf = self->lexer.debug_buffer;                     \\\n    const char *symbol = symbol_name;                         \\\n    int off = snprintf(                                       \\\n      buf,                                                    \\\n      TREE_SITTER_SERIALIZATION_BUFFER_SIZE,                  \\\n      \"lexed_lookahead sym:\"                                  \\\n    );                                                        \\\n    for (                                                     \\\n      int i = 0;                                              \\\n      symbol[i] != '\\0'                                       \\\n      && off < TREE_SITTER_SERIALIZATION_BUFFER_SIZE;         \\\n      i++                                                     \\\n    ) {                                                       \\\n      switch (symbol[i]) {                                    \\\n      case '\\t': buf[off++] = '\\\\'; buf[off++] = 't'; break;  \\\n      case '\\n': buf[off++] = '\\\\'; buf[off++] = 'n'; break;  \\\n      case '\\v': buf[off++] = '\\\\'; buf[off++] = 'v'; break;  \\\n      case '\\f': buf[off++] = '\\\\'; buf[off++] = 'f'; break;  \\\n      case '\\r': buf[off++] = '\\\\'; buf[off++] = 'r'; break;  \\\n      case '\\\\': buf[off++] = '\\\\'; buf[off++] = '\\\\'; break; \\\n      default:   buf[off++] = symbol[i]; break;               \\\n      }                                                       \\\n    }                                                         \\\n    snprintf(                                                 \\\n      buf + off,                                              \\\n      TREE_SITTER_SERIALIZATION_BUFFER_SIZE - off,            \\\n      \", size:%u\",                                            \\\n      size                                                    \\\n    );                                                        \\\n    ts_parser__log(self);                                     \\\n  }\n\n#define LOG_STACK()                                                              \\\n  if (self->dot_graph_file) {                                                    \\\n    ts_stack_print_dot_graph(self->stack, self->language, self->dot_graph_file); \\\n    fputs(\"\\n\\n\", self->dot_graph_file);                                         \\\n  }\n\n#define LOG_TREE(tree)                                                      \\\n  if (self->dot_graph_file) {                                               \\\n    ts_subtree_print_dot_graph(tree, self->language, self->dot_graph_file); \\\n    fputs(\"\\n\", self->dot_graph_file);                                      \\\n  }\n\n#define SYM_NAME(symbol) ts_language_symbol_name(self->language, symbol)\n\n#define TREE_NAME(tree) SYM_NAME(ts_subtree_symbol(tree))\n\nstatic const unsigned MAX_VERSION_COUNT = 6;\nstatic const unsigned MAX_VERSION_COUNT_OVERFLOW = 4;\nstatic const unsigned MAX_SUMMARY_DEPTH = 16;\nstatic const unsigned MAX_COST_DIFFERENCE = 18 * ERROR_COST_PER_SKIPPED_TREE;\nstatic const unsigned OP_COUNT_PER_PARSER_CALLBACK_CHECK = 100;\n\ntypedef struct {\n  Subtree token;\n  Subtree last_external_token;\n  uint32_t byte_index;\n} TokenCache;\n\nstruct TSParser {\n  Lexer lexer;\n  Stack *stack;\n  SubtreePool tree_pool;\n  const TSLanguage *language;\n  TSWasmStore *wasm_store;\n  ReduceActionSet reduce_actions;\n  Subtree finished_tree;\n  SubtreeArray trailing_extras;\n  SubtreeArray trailing_extras2;\n  SubtreeArray scratch_trees;\n  TokenCache token_cache;\n  ReusableNode reusable_node;\n  void *external_scanner_payload;\n  FILE *dot_graph_file;\n  unsigned accept_count;\n  unsigned operation_count;\n  Subtree old_tree;\n  TSRangeArray included_range_differences;\n  TSParseOptions parse_options;\n  TSParseState parse_state;\n  unsigned included_range_difference_index;\n  bool has_scanner_error;\n  bool canceled_balancing;\n  bool has_error;\n};\n\ntypedef struct {\n  unsigned cost;\n  unsigned node_count;\n  int dynamic_precedence;\n  bool is_in_error;\n} ErrorStatus;\n\ntypedef enum {\n  ErrorComparisonTakeLeft,\n  ErrorComparisonPreferLeft,\n  ErrorComparisonNone,\n  ErrorComparisonPreferRight,\n  ErrorComparisonTakeRight,\n} ErrorComparison;\n\ntypedef struct {\n  const char *string;\n  uint32_t length;\n} TSStringInput;\n\n// StringInput\n\nstatic const char *ts_string_input_read(\n  void *_self,\n  uint32_t byte,\n  TSPoint point,\n  uint32_t *length\n) {\n  (void)point;\n  TSStringInput *self = (TSStringInput *)_self;\n  if (byte >= self->length) {\n    *length = 0;\n    return \"\";\n  } else {\n    *length = self->length - byte;\n    return self->string + byte;\n  }\n}\n\n// Parser - Private\n\nstatic void ts_parser__log(TSParser *self) {\n  if (self->lexer.logger.log) {\n    self->lexer.logger.log(\n      self->lexer.logger.payload,\n      TSLogTypeParse,\n      self->lexer.debug_buffer\n    );\n  }\n\n  if (self->dot_graph_file) {\n    fprintf(self->dot_graph_file, \"graph {\\nlabel=\\\"\");\n    for (char *chr = &self->lexer.debug_buffer[0]; *chr != 0; chr++) {\n      if (*chr == '\"' || *chr == '\\\\') fputc('\\\\', self->dot_graph_file);\n      fputc(*chr, self->dot_graph_file);\n    }\n    fprintf(self->dot_graph_file, \"\\\"\\n}\\n\\n\");\n  }\n}\n\nstatic bool ts_parser__breakdown_top_of_stack(\n  TSParser *self,\n  StackVersion version\n) {\n  bool did_break_down = false;\n  bool pending = false;\n\n  do {\n    StackSliceArray pop = ts_stack_pop_pending(self->stack, version);\n    if (!pop.size) break;\n\n    did_break_down = true;\n    pending = false;\n    for (uint32_t i = 0; i < pop.size; i++) {\n      StackSlice slice = *array_get(&pop, i);\n      TSStateId state = ts_stack_state(self->stack, slice.version);\n      Subtree parent = *array_front(&slice.subtrees);\n\n      for (uint32_t j = 0, n = ts_subtree_child_count(parent); j < n; j++) {\n        Subtree child = ts_subtree_children(parent)[j];\n        pending = ts_subtree_child_count(child) > 0;\n\n        if (ts_subtree_is_error(child)) {\n          state = ERROR_STATE;\n        } else if (!ts_subtree_extra(child)) {\n          state = ts_language_next_state(self->language, state, ts_subtree_symbol(child));\n        }\n\n        ts_subtree_retain(child);\n        ts_stack_push(self->stack, slice.version, child, pending, state);\n      }\n\n      for (uint32_t j = 1; j < slice.subtrees.size; j++) {\n        Subtree tree = *array_get(&slice.subtrees, j);\n        ts_stack_push(self->stack, slice.version, tree, false, state);\n      }\n\n      ts_subtree_release(&self->tree_pool, parent);\n      array_delete(&slice.subtrees);\n\n      LOG(\"breakdown_top_of_stack tree:%s\", TREE_NAME(parent));\n      LOG_STACK();\n    }\n  } while (pending);\n\n  return did_break_down;\n}\n\nstatic void ts_parser__breakdown_lookahead(\n  TSParser *self,\n  Subtree *lookahead,\n  TSStateId state,\n  ReusableNode *reusable_node\n) {\n  bool did_descend = false;\n  Subtree tree = reusable_node_tree(reusable_node);\n  while (ts_subtree_child_count(tree) > 0 && ts_subtree_parse_state(tree) != state) {\n    LOG(\"state_mismatch sym:%s\", TREE_NAME(tree));\n    reusable_node_descend(reusable_node);\n    tree = reusable_node_tree(reusable_node);\n    did_descend = true;\n  }\n\n  if (did_descend) {\n    ts_subtree_release(&self->tree_pool, *lookahead);\n    *lookahead = tree;\n    ts_subtree_retain(*lookahead);\n  }\n}\n\nstatic ErrorComparison ts_parser__compare_versions(\n  TSParser *self,\n  ErrorStatus a,\n  ErrorStatus b\n) {\n  (void)self;\n  if (!a.is_in_error && b.is_in_error) {\n    if (a.cost < b.cost) {\n      return ErrorComparisonTakeLeft;\n    } else {\n      return ErrorComparisonPreferLeft;\n    }\n  }\n\n  if (a.is_in_error && !b.is_in_error) {\n    if (b.cost < a.cost) {\n      return ErrorComparisonTakeRight;\n    } else {\n      return ErrorComparisonPreferRight;\n    }\n  }\n\n  if (a.cost < b.cost) {\n    if ((b.cost - a.cost) * (1 + a.node_count) > MAX_COST_DIFFERENCE) {\n      return ErrorComparisonTakeLeft;\n    } else {\n      return ErrorComparisonPreferLeft;\n    }\n  }\n\n  if (b.cost < a.cost) {\n    if ((a.cost - b.cost) * (1 + b.node_count) > MAX_COST_DIFFERENCE) {\n      return ErrorComparisonTakeRight;\n    } else {\n      return ErrorComparisonPreferRight;\n    }\n  }\n\n  if (a.dynamic_precedence > b.dynamic_precedence) return ErrorComparisonPreferLeft;\n  if (b.dynamic_precedence > a.dynamic_precedence) return ErrorComparisonPreferRight;\n  return ErrorComparisonNone;\n}\n\nstatic ErrorStatus ts_parser__version_status(\n  TSParser *self,\n  StackVersion version\n) {\n  unsigned cost = ts_stack_error_cost(self->stack, version);\n  bool is_paused = ts_stack_is_paused(self->stack, version);\n  if (is_paused) cost += ERROR_COST_PER_SKIPPED_TREE;\n  return (ErrorStatus) {\n    .cost = cost,\n    .node_count = ts_stack_node_count_since_error(self->stack, version),\n    .dynamic_precedence = ts_stack_dynamic_precedence(self->stack, version),\n    .is_in_error = is_paused || ts_stack_state(self->stack, version) == ERROR_STATE\n  };\n}\n\nstatic bool ts_parser__better_version_exists(\n  TSParser *self,\n  StackVersion version,\n  bool is_in_error,\n  unsigned cost\n) {\n  if (self->finished_tree.ptr && ts_subtree_error_cost(self->finished_tree) <= cost) {\n    return true;\n  }\n\n  Length position = ts_stack_position(self->stack, version);\n  ErrorStatus status = {\n    .cost = cost,\n    .is_in_error = is_in_error,\n    .dynamic_precedence = ts_stack_dynamic_precedence(self->stack, version),\n    .node_count = ts_stack_node_count_since_error(self->stack, version),\n  };\n\n  for (StackVersion i = 0, n = ts_stack_version_count(self->stack); i < n; i++) {\n    if (i == version ||\n        !ts_stack_is_active(self->stack, i) ||\n        ts_stack_position(self->stack, i).bytes < position.bytes) continue;\n    ErrorStatus status_i = ts_parser__version_status(self, i);\n    switch (ts_parser__compare_versions(self, status, status_i)) {\n      case ErrorComparisonTakeRight:\n        return true;\n      case ErrorComparisonPreferRight:\n        if (ts_stack_can_merge(self->stack, i, version)) return true;\n        break;\n      default:\n        break;\n    }\n  }\n\n  return false;\n}\n\nstatic bool ts_parser__call_main_lex_fn(TSParser *self, TSLexerMode lex_mode) {\n  if (ts_language_is_wasm(self->language)) {\n    return ts_wasm_store_call_lex_main(self->wasm_store, lex_mode.lex_state);\n  } else {\n    return self->language->lex_fn(&self->lexer.data, lex_mode.lex_state);\n  }\n}\n\nstatic bool ts_parser__call_keyword_lex_fn(TSParser *self) {\n  if (ts_language_is_wasm(self->language)) {\n    return ts_wasm_store_call_lex_keyword(self->wasm_store, 0);\n  } else {\n    return self->language->keyword_lex_fn(&self->lexer.data, 0);\n  }\n}\n\nstatic void ts_parser__external_scanner_create(\n  TSParser *self\n) {\n  if (self->language && self->language->external_scanner.states) {\n    if (ts_language_is_wasm(self->language)) {\n      self->external_scanner_payload = (void *)(uintptr_t)ts_wasm_store_call_scanner_create(\n        self->wasm_store\n      );\n      if (ts_wasm_store_has_error(self->wasm_store)) {\n        self->has_scanner_error = true;\n      }\n    } else if (self->language->external_scanner.create) {\n      self->external_scanner_payload = self->language->external_scanner.create();\n    }\n  }\n}\n\nstatic void ts_parser__external_scanner_destroy(\n  TSParser *self\n) {\n  if (\n    self->language &&\n    self->external_scanner_payload &&\n    self->language->external_scanner.destroy &&\n    !ts_language_is_wasm(self->language)\n  ) {\n    self->language->external_scanner.destroy(\n      self->external_scanner_payload\n    );\n  }\n  self->external_scanner_payload = NULL;\n}\n\nstatic unsigned ts_parser__external_scanner_serialize(\n  TSParser *self\n) {\n  uint32_t length;\n  if (ts_language_is_wasm(self->language)) {\n    length = ts_wasm_store_call_scanner_serialize(\n      self->wasm_store,\n      (uintptr_t)self->external_scanner_payload,\n      self->lexer.debug_buffer\n    );\n    if (ts_wasm_store_has_error(self->wasm_store)) {\n      self->has_scanner_error = true;\n    }\n  } else {\n    length = self->language->external_scanner.serialize(\n      self->external_scanner_payload,\n      self->lexer.debug_buffer\n    );\n  }\n  ts_assert(length <= TREE_SITTER_SERIALIZATION_BUFFER_SIZE);\n  return length;\n}\n\nstatic void ts_parser__external_scanner_deserialize(\n  TSParser *self,\n  Subtree external_token\n) {\n  const char *data = NULL;\n  uint32_t length = 0;\n  if (external_token.ptr) {\n    data = ts_external_scanner_state_data(&external_token.ptr->external_scanner_state);\n    length = external_token.ptr->external_scanner_state.length;\n  }\n\n  if (ts_language_is_wasm(self->language)) {\n    ts_wasm_store_call_scanner_deserialize(\n      self->wasm_store,\n      (uintptr_t)self->external_scanner_payload,\n      data,\n      length\n    );\n    if (ts_wasm_store_has_error(self->wasm_store)) {\n      self->has_scanner_error = true;\n    }\n  } else {\n    self->language->external_scanner.deserialize(\n      self->external_scanner_payload,\n      data,\n      length\n    );\n  }\n}\n\nstatic bool ts_parser__external_scanner_scan(\n  TSParser *self,\n  TSStateId external_lex_state\n) {\n  if (ts_language_is_wasm(self->language)) {\n    bool result = ts_wasm_store_call_scanner_scan(\n      self->wasm_store,\n      (uintptr_t)self->external_scanner_payload,\n      external_lex_state * self->language->external_token_count\n    );\n    if (ts_wasm_store_has_error(self->wasm_store)) {\n      self->has_scanner_error = true;\n    }\n    return result;\n  } else {\n    const bool *valid_external_tokens = ts_language_enabled_external_tokens(\n      self->language,\n      external_lex_state\n    );\n    return self->language->external_scanner.scan(\n      self->external_scanner_payload,\n      &self->lexer.data,\n      valid_external_tokens\n    );\n  }\n}\n\nstatic bool ts_parser__can_reuse_first_leaf(\n  TSParser *self,\n  TSStateId state,\n  Subtree tree,\n  TableEntry *table_entry\n) {\n  TSSymbol leaf_symbol = ts_subtree_leaf_symbol(tree);\n  TSStateId leaf_state = ts_subtree_leaf_parse_state(tree);\n  TSLexerMode current_lex_mode = ts_language_lex_mode_for_state(self->language, state);\n  TSLexerMode leaf_lex_mode = ts_language_lex_mode_for_state(self->language, leaf_state);\n\n  // At the end of a non-terminal extra node, the lexer normally returns\n  // NULL, which indicates that the parser should look for a reduce action\n  // at symbol `0`. Avoid reusing tokens in this situation to ensure that\n  // the same thing happens when incrementally reparsing.\n  if (current_lex_mode.lex_state == (uint16_t)(-1)) return false;\n\n  // If the token was created in a state with the same set of lookaheads, it is reusable.\n  if (\n    table_entry->action_count > 0 &&\n    memcmp(&leaf_lex_mode, &current_lex_mode, sizeof(TSLexerMode)) == 0 &&\n    (\n      leaf_symbol != self->language->keyword_capture_token ||\n      (!ts_subtree_is_keyword(tree) && ts_subtree_parse_state(tree) == state)\n    )\n  ) return true;\n\n  // Empty tokens are not reusable in states with different lookaheads.\n  if (ts_subtree_size(tree).bytes == 0 && leaf_symbol != ts_builtin_sym_end) return false;\n\n  // If the current state allows external tokens or other tokens that conflict with this\n  // token, this token is not reusable.\n  return current_lex_mode.external_lex_state == 0 && table_entry->is_reusable;\n}\n\nstatic Subtree ts_parser__lex(\n  TSParser *self,\n  StackVersion version,\n  TSStateId parse_state\n) {\n  TSLexerMode lex_mode = ts_language_lex_mode_for_state(self->language, parse_state);\n  if (lex_mode.lex_state == (uint16_t)-1) {\n    LOG(\"no_lookahead_after_non_terminal_extra\");\n    return NULL_SUBTREE;\n  }\n\n  const Length start_position = ts_stack_position(self->stack, version);\n  const Subtree external_token = ts_stack_last_external_token(self->stack, version);\n\n  bool found_external_token = false;\n  bool error_mode = parse_state == ERROR_STATE;\n  bool skipped_error = false;\n  bool called_get_column = false;\n  int32_t first_error_character = 0;\n  Length error_start_position = length_zero();\n  Length error_end_position = length_zero();\n  uint32_t lookahead_end_byte = 0;\n  uint32_t external_scanner_state_len = 0;\n  bool external_scanner_state_changed = false;\n  ts_lexer_reset(&self->lexer, start_position);\n\n  for (;;) {\n    bool found_token = false;\n    Length current_position = self->lexer.current_position;\n    ColumnData column_data = self->lexer.column_data;\n\n    if (lex_mode.external_lex_state != 0) {\n      LOG(\n        \"lex_external state:%d, row:%u, column:%u\",\n        lex_mode.external_lex_state,\n        current_position.extent.row,\n        current_position.extent.column\n      );\n      ts_lexer_start(&self->lexer);\n      ts_parser__external_scanner_deserialize(self, external_token);\n      found_token = ts_parser__external_scanner_scan(self, lex_mode.external_lex_state);\n      if (self->has_scanner_error) return NULL_SUBTREE;\n      ts_lexer_finish(&self->lexer, &lookahead_end_byte);\n\n      if (found_token) {\n        external_scanner_state_len = ts_parser__external_scanner_serialize(self);\n        external_scanner_state_changed = !ts_external_scanner_state_eq(\n          ts_subtree_external_scanner_state(external_token),\n          self->lexer.debug_buffer,\n          external_scanner_state_len\n        );\n\n        // Avoid infinite loops caused by the external scanner returning empty tokens.\n        // Empty tokens are needed in some circumstances, e.g. indent/dedent tokens\n        // in Python. Ignore the following classes of empty tokens:\n        //\n        // * Tokens produced during error recovery. When recovering from an error,\n        //   all tokens are allowed, so it's easy to accidentally return unwanted\n        //   empty tokens.\n        // * Tokens that are marked as 'extra' in the grammar. These don't change\n        //   the parse state, so they would definitely cause an infinite loop.\n        if (\n          self->lexer.token_end_position.bytes <= current_position.bytes &&\n          !external_scanner_state_changed\n        ) {\n          TSSymbol symbol = self->language->external_scanner.symbol_map[self->lexer.data.result_symbol];\n          TSStateId next_parse_state = ts_language_next_state(self->language, parse_state, symbol);\n          bool token_is_extra = (next_parse_state == parse_state);\n          if (error_mode || !ts_stack_has_advanced_since_error(self->stack, version) || token_is_extra) {\n            LOG(\n              \"ignore_empty_external_token symbol:%s\",\n              SYM_NAME(self->language->external_scanner.symbol_map[self->lexer.data.result_symbol])\n            );\n            found_token = false;\n          }\n        }\n      }\n\n      if (found_token) {\n        found_external_token = true;\n        called_get_column = self->lexer.did_get_column;\n        break;\n      }\n\n      ts_lexer_reset(&self->lexer, current_position);\n      self->lexer.column_data = column_data;\n    }\n\n    LOG(\n      \"lex_internal state:%d, row:%u, column:%u\",\n      lex_mode.lex_state,\n      current_position.extent.row,\n      current_position.extent.column\n    );\n    ts_lexer_start(&self->lexer);\n    found_token = ts_parser__call_main_lex_fn(self, lex_mode);\n    ts_lexer_finish(&self->lexer, &lookahead_end_byte);\n    if (found_token) break;\n\n    if (!error_mode) {\n      error_mode = true;\n      lex_mode = ts_language_lex_mode_for_state(self->language, ERROR_STATE);\n      ts_lexer_reset(&self->lexer, start_position);\n      continue;\n    }\n\n    if (!skipped_error) {\n      LOG(\"skip_unrecognized_character\");\n      skipped_error = true;\n      error_start_position = self->lexer.token_start_position;\n      error_end_position = self->lexer.token_start_position;\n      first_error_character = self->lexer.data.lookahead;\n    }\n\n    if (self->lexer.current_position.bytes == error_end_position.bytes) {\n      if (self->lexer.data.eof(&self->lexer.data)) {\n        self->lexer.data.result_symbol = ts_builtin_sym_error;\n        break;\n      }\n      self->lexer.data.advance(&self->lexer.data, false);\n    }\n\n    error_end_position = self->lexer.current_position;\n  }\n\n  Subtree result;\n  if (skipped_error) {\n    Length padding = length_sub(error_start_position, start_position);\n    Length size = length_sub(error_end_position, error_start_position);\n    uint32_t lookahead_bytes = lookahead_end_byte - error_end_position.bytes;\n    result = ts_subtree_new_error(\n      &self->tree_pool,\n      first_error_character,\n      padding,\n      size,\n      lookahead_bytes,\n      parse_state,\n      self->language\n    );\n  } else {\n    bool is_keyword = false;\n    TSSymbol symbol = self->lexer.data.result_symbol;\n    Length padding = length_sub(self->lexer.token_start_position, start_position);\n    Length size = length_sub(self->lexer.token_end_position, self->lexer.token_start_position);\n    uint32_t lookahead_bytes = lookahead_end_byte - self->lexer.token_end_position.bytes;\n\n    if (found_external_token) {\n      symbol = self->language->external_scanner.symbol_map[symbol];\n    } else if (symbol == self->language->keyword_capture_token && symbol != 0) {\n      uint32_t end_byte = self->lexer.token_end_position.bytes;\n      ts_lexer_reset(&self->lexer, self->lexer.token_start_position);\n      ts_lexer_start(&self->lexer);\n\n      is_keyword = ts_parser__call_keyword_lex_fn(self);\n\n      if (\n        is_keyword &&\n        self->lexer.token_end_position.bytes == end_byte &&\n        (\n          ts_language_has_actions(self->language, parse_state, self->lexer.data.result_symbol) ||\n          ts_language_is_reserved_word(self->language, parse_state, self->lexer.data.result_symbol)\n        )\n      ) {\n        symbol = self->lexer.data.result_symbol;\n      }\n    }\n\n    result = ts_subtree_new_leaf(\n      &self->tree_pool,\n      symbol,\n      padding,\n      size,\n      lookahead_bytes,\n      parse_state,\n      found_external_token,\n      called_get_column,\n      is_keyword,\n      self->language\n    );\n\n    if (found_external_token) {\n      MutableSubtree mut_result = ts_subtree_to_mut_unsafe(result);\n      ts_external_scanner_state_init(\n        &mut_result.ptr->external_scanner_state,\n        self->lexer.debug_buffer,\n        external_scanner_state_len\n      );\n      mut_result.ptr->has_external_scanner_state_change = external_scanner_state_changed;\n    }\n  }\n\n  LOG_LOOKAHEAD(\n    SYM_NAME(ts_subtree_symbol(result)),\n    ts_subtree_total_size(result).bytes\n  );\n  return result;\n}\n\nstatic Subtree ts_parser__get_cached_token(\n  TSParser *self,\n  TSStateId state,\n  size_t position,\n  Subtree last_external_token,\n  TableEntry *table_entry\n) {\n  TokenCache *cache = &self->token_cache;\n  if (\n    cache->token.ptr && cache->byte_index == position &&\n    ts_subtree_external_scanner_state_eq(cache->last_external_token, last_external_token)\n  ) {\n    ts_language_table_entry(self->language, state, ts_subtree_symbol(cache->token), table_entry);\n    if (ts_parser__can_reuse_first_leaf(self, state, cache->token, table_entry)) {\n      ts_subtree_retain(cache->token);\n      return cache->token;\n    }\n  }\n  return NULL_SUBTREE;\n}\n\nstatic void ts_parser__set_cached_token(\n  TSParser *self,\n  uint32_t byte_index,\n  Subtree last_external_token,\n  Subtree token\n) {\n  TokenCache *cache = &self->token_cache;\n  if (token.ptr) ts_subtree_retain(token);\n  if (last_external_token.ptr) ts_subtree_retain(last_external_token);\n  if (cache->token.ptr) ts_subtree_release(&self->tree_pool, cache->token);\n  if (cache->last_external_token.ptr) ts_subtree_release(&self->tree_pool, cache->last_external_token);\n  cache->token = token;\n  cache->byte_index = byte_index;\n  cache->last_external_token = last_external_token;\n}\n\nstatic bool ts_parser__has_included_range_difference(\n  const TSParser *self,\n  uint32_t start_position,\n  uint32_t end_position\n) {\n  return ts_range_array_intersects(\n    &self->included_range_differences,\n    self->included_range_difference_index,\n    start_position,\n    end_position\n  );\n}\n\nstatic Subtree ts_parser__reuse_node(\n  TSParser *self,\n  StackVersion version,\n  TSStateId *state,\n  uint32_t position,\n  Subtree last_external_token,\n  TableEntry *table_entry\n) {\n  Subtree result;\n  while ((result = reusable_node_tree(&self->reusable_node)).ptr) {\n    uint32_t byte_offset = reusable_node_byte_offset(&self->reusable_node);\n    uint32_t end_byte_offset = byte_offset + ts_subtree_total_bytes(result);\n\n    // Do not reuse an EOF node if the included ranges array has changes\n    // later on in the file.\n    if (ts_subtree_is_eof(result)) end_byte_offset = UINT32_MAX;\n\n    if (byte_offset > position) {\n      LOG(\"before_reusable_node symbol:%s\", TREE_NAME(result));\n      break;\n    }\n\n    if (byte_offset < position) {\n      LOG(\"past_reusable_node symbol:%s\", TREE_NAME(result));\n      if (end_byte_offset <= position || !reusable_node_descend(&self->reusable_node)) {\n        reusable_node_advance(&self->reusable_node);\n      }\n      continue;\n    }\n\n    if (!ts_subtree_external_scanner_state_eq(self->reusable_node.last_external_token, last_external_token)) {\n      LOG(\"reusable_node_has_different_external_scanner_state symbol:%s\", TREE_NAME(result));\n      reusable_node_advance(&self->reusable_node);\n      continue;\n    }\n\n    const char *reason = NULL;\n    if (ts_subtree_has_changes(result)) {\n      reason = \"has_changes\";\n    } else if (ts_subtree_is_error(result)) {\n      reason = \"is_error\";\n    } else if (ts_subtree_missing(result)) {\n      reason = \"is_missing\";\n    } else if (ts_subtree_is_fragile(result)) {\n      reason = \"is_fragile\";\n    } else if (ts_parser__has_included_range_difference(self, byte_offset, end_byte_offset)) {\n      reason = \"contains_different_included_range\";\n    }\n\n    if (reason) {\n      LOG(\"cant_reuse_node_%s tree:%s\", reason, TREE_NAME(result));\n      if (!reusable_node_descend(&self->reusable_node)) {\n        reusable_node_advance(&self->reusable_node);\n        ts_parser__breakdown_top_of_stack(self, version);\n        *state = ts_stack_state(self->stack, version);\n      }\n      continue;\n    }\n\n    TSSymbol leaf_symbol = ts_subtree_leaf_symbol(result);\n    ts_language_table_entry(self->language, *state, leaf_symbol, table_entry);\n    if (!ts_parser__can_reuse_first_leaf(self, *state, result, table_entry)) {\n      LOG(\n        \"cant_reuse_node symbol:%s, first_leaf_symbol:%s\",\n        TREE_NAME(result),\n        SYM_NAME(leaf_symbol)\n      );\n      reusable_node_advance_past_leaf(&self->reusable_node);\n      break;\n    }\n\n    LOG(\"reuse_node symbol:%s\", TREE_NAME(result));\n    ts_subtree_retain(result);\n    return result;\n  }\n\n  return NULL_SUBTREE;\n}\n\n// Determine if a given tree should be replaced by an alternative tree.\n//\n// The decision is based on the trees' error costs (if any), their dynamic precedence,\n// and finally, as a default, by a recursive comparison of the trees' symbols.\nstatic bool ts_parser__select_tree(TSParser *self, Subtree left, Subtree right) {\n  if (!left.ptr) return true;\n  if (!right.ptr) return false;\n\n  if (ts_subtree_error_cost(right) < ts_subtree_error_cost(left)) {\n    LOG(\"select_smaller_error symbol:%s, over_symbol:%s\", TREE_NAME(right), TREE_NAME(left));\n    return true;\n  }\n\n  if (ts_subtree_error_cost(left) < ts_subtree_error_cost(right)) {\n    LOG(\"select_smaller_error symbol:%s, over_symbol:%s\", TREE_NAME(left), TREE_NAME(right));\n    return false;\n  }\n\n  if (ts_subtree_dynamic_precedence(right) > ts_subtree_dynamic_precedence(left)) {\n    LOG(\"select_higher_precedence symbol:%s, prec:%\" PRId32 \", over_symbol:%s, other_prec:%\" PRId32,\n        TREE_NAME(right), ts_subtree_dynamic_precedence(right), TREE_NAME(left),\n        ts_subtree_dynamic_precedence(left));\n    return true;\n  }\n\n  if (ts_subtree_dynamic_precedence(left) > ts_subtree_dynamic_precedence(right)) {\n    LOG(\"select_higher_precedence symbol:%s, prec:%\" PRId32 \", over_symbol:%s, other_prec:%\" PRId32,\n        TREE_NAME(left), ts_subtree_dynamic_precedence(left), TREE_NAME(right),\n        ts_subtree_dynamic_precedence(right));\n    return false;\n  }\n\n  if (ts_subtree_error_cost(left) > 0) return true;\n\n  int comparison = ts_subtree_compare(left, right, &self->tree_pool);\n  switch (comparison) {\n    case -1:\n      LOG(\"select_earlier symbol:%s, over_symbol:%s\", TREE_NAME(left), TREE_NAME(right));\n      return false;\n      break;\n    case 1:\n      LOG(\"select_earlier symbol:%s, over_symbol:%s\", TREE_NAME(right), TREE_NAME(left));\n      return true;\n    default:\n      LOG(\"select_existing symbol:%s, over_symbol:%s\", TREE_NAME(left), TREE_NAME(right));\n      return false;\n  }\n}\n\n// Determine if a given tree's children should be replaced by an alternative\n// array of children.\nstatic bool ts_parser__select_children(\n  TSParser *self,\n  Subtree left,\n  const SubtreeArray *children\n) {\n  array_assign(&self->scratch_trees, children);\n\n  // Create a temporary subtree using the scratch trees array. This node does\n  // not perform any allocation except for possibly growing the array to make\n  // room for its own heap data. The scratch tree is never explicitly released,\n  // so the same 'scratch trees' array can be reused again later.\n  MutableSubtree scratch_tree = ts_subtree_new_node(\n    ts_subtree_symbol(left),\n    &self->scratch_trees,\n    0,\n    self->language\n  );\n\n  return ts_parser__select_tree(\n    self,\n    left,\n    ts_subtree_from_mut(scratch_tree)\n  );\n}\n\nstatic void ts_parser__shift(\n  TSParser *self,\n  StackVersion version,\n  TSStateId state,\n  Subtree lookahead,\n  bool extra\n) {\n  bool is_leaf = ts_subtree_child_count(lookahead) == 0;\n  Subtree subtree_to_push = lookahead;\n  if (extra != ts_subtree_extra(lookahead) && is_leaf) {\n    MutableSubtree result = ts_subtree_make_mut(&self->tree_pool, lookahead);\n    ts_subtree_set_extra(&result, extra);\n    subtree_to_push = ts_subtree_from_mut(result);\n  }\n\n  ts_stack_push(self->stack, version, subtree_to_push, !is_leaf, state);\n  if (ts_subtree_has_external_tokens(subtree_to_push)) {\n    ts_stack_set_last_external_token(\n      self->stack, version, ts_subtree_last_external_token(subtree_to_push)\n    );\n  }\n}\n\nstatic StackVersion ts_parser__reduce(\n  TSParser *self,\n  StackVersion version,\n  TSSymbol symbol,\n  uint32_t count,\n  int dynamic_precedence,\n  uint16_t production_id,\n  bool is_fragile,\n  bool end_of_non_terminal_extra\n) {\n  uint32_t initial_version_count = ts_stack_version_count(self->stack);\n\n  // Pop the given number of nodes from the given version of the parse stack.\n  // If stack versions have previously merged, then there may be more than one\n  // path back through the stack. For each path, create a new parent node to\n  // contain the popped children, and push it onto the stack in place of the\n  // children.\n  StackSliceArray pop = ts_stack_pop_count(self->stack, version, count);\n  uint32_t removed_version_count = 0;\n  uint32_t halted_version_count = ts_stack_halted_version_count(self->stack);\n  for (uint32_t i = 0; i < pop.size; i++) {\n    StackSlice slice = *array_get(&pop, i);\n    StackVersion slice_version = slice.version - removed_version_count;\n\n    // This is where new versions are added to the parse stack. The versions\n    // will all be sorted and truncated at the end of the outer parsing loop.\n    // Allow the maximum version count to be temporarily exceeded, but only\n    // by a limited threshold.\n    if (slice_version > MAX_VERSION_COUNT + MAX_VERSION_COUNT_OVERFLOW + halted_version_count) {\n      ts_stack_remove_version(self->stack, slice_version);\n      ts_subtree_array_delete(&self->tree_pool, &slice.subtrees);\n      removed_version_count++;\n      while (i + 1 < pop.size) {\n        LOG(\"aborting reduce with too many versions\")\n        StackSlice next_slice = *array_get(&pop, i + 1);\n        if (next_slice.version != slice.version) break;\n        ts_subtree_array_delete(&self->tree_pool, &next_slice.subtrees);\n        i++;\n      }\n      continue;\n    }\n\n    // Extra tokens on top of the stack should not be included in this new parent\n    // node. They will be re-pushed onto the stack after the parent node is\n    // created and pushed.\n    SubtreeArray children = slice.subtrees;\n    ts_subtree_array_remove_trailing_extras(&children, &self->trailing_extras);\n\n    MutableSubtree parent = ts_subtree_new_node(\n      symbol, &children, production_id, self->language\n    );\n\n    // This pop operation may have caused multiple stack versions to collapse\n    // into one, because they all diverged from a common state. In that case,\n    // choose one of the arrays of trees to be the parent node's children, and\n    // delete the rest of the tree arrays.\n    while (i + 1 < pop.size) {\n      StackSlice next_slice = *array_get(&pop, i + 1);\n      if (next_slice.version != slice.version) break;\n      i++;\n\n      SubtreeArray next_slice_children = next_slice.subtrees;\n      ts_subtree_array_remove_trailing_extras(&next_slice_children, &self->trailing_extras2);\n\n      if (ts_parser__select_children(\n        self,\n        ts_subtree_from_mut(parent),\n        &next_slice_children\n      )) {\n        ts_subtree_array_clear(&self->tree_pool, &self->trailing_extras);\n        ts_subtree_release(&self->tree_pool, ts_subtree_from_mut(parent));\n        array_swap(&self->trailing_extras, &self->trailing_extras2);\n        parent = ts_subtree_new_node(\n          symbol, &next_slice_children, production_id, self->language\n        );\n      } else {\n        array_clear(&self->trailing_extras2);\n        ts_subtree_array_delete(&self->tree_pool, &next_slice.subtrees);\n      }\n    }\n\n    TSStateId state = ts_stack_state(self->stack, slice_version);\n    TSStateId next_state = ts_language_next_state(self->language, state, symbol);\n    if (end_of_non_terminal_extra && next_state == state) {\n      parent.ptr->extra = true;\n    }\n    if (is_fragile || pop.size > 1 || initial_version_count > 1) {\n      parent.ptr->fragile_left = true;\n      parent.ptr->fragile_right = true;\n      parent.ptr->parse_state = TS_TREE_STATE_NONE;\n    } else {\n      parent.ptr->parse_state = state;\n    }\n    parent.ptr->dynamic_precedence += dynamic_precedence;\n\n    // Push the parent node onto the stack, along with any extra tokens that\n    // were previously on top of the stack.\n    ts_stack_push(self->stack, slice_version, ts_subtree_from_mut(parent), false, next_state);\n    for (uint32_t j = 0; j < self->trailing_extras.size; j++) {\n      ts_stack_push(self->stack, slice_version, *array_get(&self->trailing_extras, j), false, next_state);\n    }\n\n    for (StackVersion j = 0; j < slice_version; j++) {\n      if (j == version) continue;\n      if (ts_stack_merge(self->stack, j, slice_version)) {\n        removed_version_count++;\n        break;\n      }\n    }\n  }\n\n  // Return the first new stack version that was created.\n  return ts_stack_version_count(self->stack) > initial_version_count\n    ? initial_version_count\n    : STACK_VERSION_NONE;\n}\n\nstatic void ts_parser__accept(\n  TSParser *self,\n  StackVersion version,\n  Subtree lookahead\n) {\n  ts_assert(ts_subtree_is_eof(lookahead));\n  ts_stack_push(self->stack, version, lookahead, false, 1);\n\n  StackSliceArray pop = ts_stack_pop_all(self->stack, version);\n  for (uint32_t i = 0; i < pop.size; i++) {\n    SubtreeArray trees = array_get(&pop, i)->subtrees;\n\n    Subtree root = NULL_SUBTREE;\n    for (uint32_t j = trees.size - 1; j + 1 > 0; j--) {\n      Subtree tree = *array_get(&trees, j);\n      if (!ts_subtree_extra(tree)) {\n        ts_assert(!tree.data.is_inline);\n        uint32_t child_count = ts_subtree_child_count(tree);\n        const Subtree *children = ts_subtree_children(tree);\n        for (uint32_t k = 0; k < child_count; k++) {\n          ts_subtree_retain(children[k]);\n        }\n        array_splice(&trees, j, 1, child_count, children);\n        root = ts_subtree_from_mut(ts_subtree_new_node(\n          ts_subtree_symbol(tree),\n          &trees,\n          tree.ptr->production_id,\n          self->language\n        ));\n        ts_subtree_release(&self->tree_pool, tree);\n        break;\n      }\n    }\n\n    ts_assert(root.ptr);\n    self->accept_count++;\n\n    if (self->finished_tree.ptr) {\n      if (ts_parser__select_tree(self, self->finished_tree, root)) {\n        ts_subtree_release(&self->tree_pool, self->finished_tree);\n        self->finished_tree = root;\n      } else {\n        ts_subtree_release(&self->tree_pool, root);\n      }\n    } else {\n      self->finished_tree = root;\n    }\n  }\n\n  ts_stack_remove_version(self->stack, array_get(&pop, 0)->version);\n  ts_stack_halt(self->stack, version);\n}\n\nstatic bool ts_parser__do_all_potential_reductions(\n  TSParser *self,\n  StackVersion starting_version,\n  TSSymbol lookahead_symbol\n) {\n  uint32_t initial_version_count = ts_stack_version_count(self->stack);\n\n  bool can_shift_lookahead_symbol = false;\n  StackVersion version = starting_version;\n  for (unsigned i = 0; true; i++) {\n    uint32_t version_count = ts_stack_version_count(self->stack);\n    if (version >= version_count) break;\n\n    bool merged = false;\n    for (StackVersion j = initial_version_count; j < version; j++) {\n      if (ts_stack_merge(self->stack, j, version)) {\n        merged = true;\n        break;\n      }\n    }\n    if (merged) continue;\n\n    TSStateId state = ts_stack_state(self->stack, version);\n    bool has_shift_action = false;\n    array_clear(&self->reduce_actions);\n\n    TSSymbol first_symbol, end_symbol;\n    if (lookahead_symbol != 0) {\n      first_symbol = lookahead_symbol;\n      end_symbol = lookahead_symbol + 1;\n    } else {\n      first_symbol = 1;\n      end_symbol = self->language->token_count;\n    }\n\n    for (TSSymbol symbol = first_symbol; symbol < end_symbol; symbol++) {\n      TableEntry entry;\n      ts_language_table_entry(self->language, state, symbol, &entry);\n      for (uint32_t j = 0; j < entry.action_count; j++) {\n        TSParseAction action = entry.actions[j];\n        switch (action.type) {\n          case TSParseActionTypeShift:\n          case TSParseActionTypeRecover:\n            if (!action.shift.extra && !action.shift.repetition) has_shift_action = true;\n            break;\n          case TSParseActionTypeReduce:\n            if (action.reduce.child_count > 0)\n              ts_reduce_action_set_add(&self->reduce_actions, (ReduceAction) {\n                .symbol = action.reduce.symbol,\n                .count = action.reduce.child_count,\n                .dynamic_precedence = action.reduce.dynamic_precedence,\n                .production_id = action.reduce.production_id,\n              });\n            break;\n          default:\n            break;\n        }\n      }\n    }\n\n    StackVersion reduction_version = STACK_VERSION_NONE;\n    for (uint32_t j = 0; j < self->reduce_actions.size; j++) {\n      ReduceAction action = *array_get(&self->reduce_actions, j);\n\n      reduction_version = ts_parser__reduce(\n        self, version, action.symbol, action.count,\n        action.dynamic_precedence, action.production_id,\n        true, false\n      );\n    }\n\n    if (has_shift_action) {\n      can_shift_lookahead_symbol = true;\n    } else if (reduction_version != STACK_VERSION_NONE && i < MAX_VERSION_COUNT) {\n      ts_stack_renumber_version(self->stack, reduction_version, version);\n      continue;\n    } else if (lookahead_symbol != 0) {\n      ts_stack_remove_version(self->stack, version);\n    }\n\n    if (version == starting_version) {\n      version = version_count;\n    } else {\n      version++;\n    }\n  }\n\n  return can_shift_lookahead_symbol;\n}\n\nstatic bool ts_parser__recover_to_state(\n  TSParser *self,\n  StackVersion version,\n  unsigned depth,\n  TSStateId goal_state\n) {\n  StackSliceArray pop = ts_stack_pop_count(self->stack, version, depth);\n  StackVersion previous_version = STACK_VERSION_NONE;\n\n  for (unsigned i = 0; i < pop.size; i++) {\n    StackSlice slice = *array_get(&pop, i);\n\n    if (slice.version == previous_version) {\n      ts_subtree_array_delete(&self->tree_pool, &slice.subtrees);\n      array_erase(&pop, i--);\n      continue;\n    }\n\n    if (ts_stack_state(self->stack, slice.version) != goal_state) {\n      ts_stack_halt(self->stack, slice.version);\n      ts_subtree_array_delete(&self->tree_pool, &slice.subtrees);\n      array_erase(&pop, i--);\n      continue;\n    }\n\n    SubtreeArray error_trees = ts_stack_pop_error(self->stack, slice.version);\n    if (error_trees.size > 0) {\n      ts_assert(error_trees.size == 1);\n      Subtree error_tree = *array_get(&error_trees, 0);\n      uint32_t error_child_count = ts_subtree_child_count(error_tree);\n      if (error_child_count > 0) {\n        array_splice(&slice.subtrees, 0, 0, error_child_count, ts_subtree_children(error_tree));\n        for (unsigned j = 0; j < error_child_count; j++) {\n          ts_subtree_retain(*array_get(&slice.subtrees, j));\n        }\n      }\n      ts_subtree_array_delete(&self->tree_pool, &error_trees);\n    }\n\n    ts_subtree_array_remove_trailing_extras(&slice.subtrees, &self->trailing_extras);\n\n    if (slice.subtrees.size > 0) {\n      Subtree error = ts_subtree_new_error_node(&slice.subtrees, true, self->language);\n      ts_stack_push(self->stack, slice.version, error, false, goal_state);\n    } else {\n      array_delete(&slice.subtrees);\n    }\n\n    for (unsigned j = 0; j < self->trailing_extras.size; j++) {\n      Subtree tree = *array_get(&self->trailing_extras, j);\n      ts_stack_push(self->stack, slice.version, tree, false, goal_state);\n    }\n\n    previous_version = slice.version;\n  }\n\n  return previous_version != STACK_VERSION_NONE;\n}\n\nstatic void ts_parser__recover(\n  TSParser *self,\n  StackVersion version,\n  Subtree lookahead\n) {\n  bool did_recover = false;\n  unsigned previous_version_count = ts_stack_version_count(self->stack);\n  Length position = ts_stack_position(self->stack, version);\n  StackSummary *summary = ts_stack_get_summary(self->stack, version);\n  unsigned node_count_since_error = ts_stack_node_count_since_error(self->stack, version);\n  unsigned current_error_cost = ts_stack_error_cost(self->stack, version);\n\n  // When the parser is in the error state, there are two strategies for recovering with a\n  // given lookahead token:\n  // 1. Find a previous state on the stack in which that lookahead token would be valid. Then,\n  //    create a new stack version that is in that state again. This entails popping all of the\n  //    subtrees that have been pushed onto the stack since that previous state, and wrapping\n  //    them in an ERROR node.\n  // 2. Wrap the lookahead token in an ERROR node, push that ERROR node onto the stack, and\n  //    move on to the next lookahead token, remaining in the error state.\n  //\n  // First, try the strategy 1. Upon entering the error state, the parser recorded a summary\n  // of the previous parse states and their depths. Look at each state in the summary, to see\n  // if the current lookahead token would be valid in that state.\n  if (summary && !ts_subtree_is_error(lookahead)) {\n    for (unsigned i = 0; i < summary->size; i++) {\n      StackSummaryEntry entry = *array_get(summary, i);\n\n      if (entry.state == ERROR_STATE) continue;\n      if (entry.position.bytes == position.bytes) continue;\n      unsigned depth = entry.depth;\n      if (node_count_since_error > 0) depth++;\n\n      // Do not recover in ways that create redundant stack versions.\n      bool would_merge = false;\n      for (unsigned j = 0; j < previous_version_count; j++) {\n        if (\n          ts_stack_state(self->stack, j) == entry.state &&\n          ts_stack_position(self->stack, j).bytes == position.bytes\n        ) {\n          would_merge = true;\n          break;\n        }\n      }\n      if (would_merge) continue;\n\n      // Do not recover if the result would clearly be worse than some existing stack version.\n      unsigned new_cost =\n        current_error_cost +\n        entry.depth * ERROR_COST_PER_SKIPPED_TREE +\n        (position.bytes - entry.position.bytes) * ERROR_COST_PER_SKIPPED_CHAR +\n        (position.extent.row - entry.position.extent.row) * ERROR_COST_PER_SKIPPED_LINE;\n      if (ts_parser__better_version_exists(self, version, false, new_cost)) break;\n\n      // If the current lookahead token is valid in some previous state, recover to that state.\n      // Then stop looking for further recoveries.\n      if (ts_language_has_actions(self->language, entry.state, ts_subtree_symbol(lookahead))) {\n        if (ts_parser__recover_to_state(self, version, depth, entry.state)) {\n          did_recover = true;\n          LOG(\"recover_to_previous state:%u, depth:%u\", entry.state, depth);\n          LOG_STACK();\n          break;\n        }\n      }\n    }\n  }\n\n  // In the process of attempting to recover, some stack versions may have been created\n  // and subsequently halted. Remove those versions.\n  for (unsigned i = previous_version_count; i < ts_stack_version_count(self->stack); i++) {\n    if (!ts_stack_is_active(self->stack, i)) {\n      LOG(\"removed paused version:%u\", i);\n      ts_stack_remove_version(self->stack, i--);\n      LOG_STACK();\n    }\n  }\n\n  // If the parser is still in the error state at the end of the file, just wrap everything\n  // in an ERROR node and terminate.\n  if (ts_subtree_is_eof(lookahead)) {\n    LOG(\"recover_eof\");\n    SubtreeArray children = array_new();\n    Subtree parent = ts_subtree_new_error_node(&children, false, self->language);\n    ts_stack_push(self->stack, version, parent, false, 1);\n    ts_parser__accept(self, version, lookahead);\n    return;\n  }\n\n  // If strategy 1 succeeded, a new stack version will have been created which is able to handle\n  // the current lookahead token. Now, in addition, try strategy 2 described above: skip the\n  // current lookahead token by wrapping it in an ERROR node.\n\n  // Don't pursue this additional strategy if there are already too many stack versions.\n  if (did_recover && ts_stack_version_count(self->stack) > MAX_VERSION_COUNT) {\n    ts_stack_halt(self->stack, version);\n    ts_subtree_release(&self->tree_pool, lookahead);\n    return;\n  }\n\n  if (\n    did_recover &&\n    ts_subtree_has_external_scanner_state_change(lookahead)\n  ) {\n    ts_stack_halt(self->stack, version);\n    ts_subtree_release(&self->tree_pool, lookahead);\n    return;\n  }\n\n  // Do not recover if the result would clearly be worse than some existing stack version.\n  unsigned new_cost =\n    current_error_cost + ERROR_COST_PER_SKIPPED_TREE +\n    ts_subtree_total_bytes(lookahead) * ERROR_COST_PER_SKIPPED_CHAR +\n    ts_subtree_total_size(lookahead).extent.row * ERROR_COST_PER_SKIPPED_LINE;\n  if (ts_parser__better_version_exists(self, version, false, new_cost)) {\n    ts_stack_halt(self->stack, version);\n    ts_subtree_release(&self->tree_pool, lookahead);\n    return;\n  }\n\n  // If the current lookahead token is an extra token, mark it as extra. This means it won't\n  // be counted in error cost calculations.\n  unsigned n;\n  const TSParseAction *actions = ts_language_actions(self->language, 1, ts_subtree_symbol(lookahead), &n);\n  if (n > 0 && actions[n - 1].type == TSParseActionTypeShift && actions[n - 1].shift.extra) {\n    MutableSubtree mutable_lookahead = ts_subtree_make_mut(&self->tree_pool, lookahead);\n    ts_subtree_set_extra(&mutable_lookahead, true);\n    lookahead = ts_subtree_from_mut(mutable_lookahead);\n  }\n\n  // Wrap the lookahead token in an ERROR.\n  LOG(\"skip_token symbol:%s\", TREE_NAME(lookahead));\n  SubtreeArray children = array_new();\n  array_reserve(&children, 1);\n  array_push(&children, lookahead);\n  MutableSubtree error_repeat = ts_subtree_new_node(\n    ts_builtin_sym_error_repeat,\n    &children,\n    0,\n    self->language\n  );\n\n  // If other tokens have already been skipped, so there is already an ERROR at the top of the\n  // stack, then pop that ERROR off the stack and wrap the two ERRORs together into one larger\n  // ERROR.\n  if (node_count_since_error > 0) {\n    StackSliceArray pop = ts_stack_pop_count(self->stack, version, 1);\n\n    // TODO: Figure out how to make this condition occur.\n    // See https://github.com/atom/atom/issues/18450#issuecomment-439579778\n    // If multiple stack versions have merged at this point, just pick one of the errors\n    // arbitrarily and discard the rest.\n    if (pop.size > 1) {\n      for (unsigned i = 1; i < pop.size; i++) {\n        ts_subtree_array_delete(&self->tree_pool, &array_get(&pop, i)->subtrees);\n      }\n      while (ts_stack_version_count(self->stack) > array_get(&pop, 0)->version + 1) {\n        ts_stack_remove_version(self->stack, array_get(&pop, 0)->version + 1);\n      }\n    }\n\n    ts_stack_renumber_version(self->stack, array_get(&pop, 0)->version, version);\n    array_push(&array_get(&pop, 0)->subtrees, ts_subtree_from_mut(error_repeat));\n    error_repeat = ts_subtree_new_node(\n      ts_builtin_sym_error_repeat,\n      &array_get(&pop, 0)->subtrees,\n      0,\n      self->language\n    );\n  }\n\n  // Push the new ERROR onto the stack.\n  ts_stack_push(self->stack, version, ts_subtree_from_mut(error_repeat), false, ERROR_STATE);\n  if (ts_subtree_has_external_tokens(lookahead)) {\n    ts_stack_set_last_external_token(\n      self->stack, version, ts_subtree_last_external_token(lookahead)\n    );\n  }\n\n  bool has_error = true;\n  for (unsigned i = 0; i < ts_stack_version_count(self->stack); i++) {\n    ErrorStatus status = ts_parser__version_status(self, i);\n    if (!status.is_in_error) {\n      has_error = false;\n      break;\n    }\n  }\n  self->has_error = has_error;\n}\n\nstatic void ts_parser__handle_error(\n  TSParser *self,\n  StackVersion version,\n  Subtree lookahead\n) {\n  uint32_t previous_version_count = ts_stack_version_count(self->stack);\n\n  // Perform any reductions that can happen in this state, regardless of the lookahead. After\n  // skipping one or more invalid tokens, the parser might find a token that would have allowed\n  // a reduction to take place.\n  ts_parser__do_all_potential_reductions(self, version, 0);\n  uint32_t version_count = ts_stack_version_count(self->stack);\n  Length position = ts_stack_position(self->stack, version);\n\n  // Push a discontinuity onto the stack. Merge all of the stack versions that\n  // were created in the previous step.\n  bool did_insert_missing_token = false;\n  for (StackVersion v = version; v < version_count;) {\n    if (!did_insert_missing_token) {\n      TSStateId state = ts_stack_state(self->stack, v);\n      for (\n        TSSymbol missing_symbol = 1;\n        missing_symbol < (uint16_t)self->language->token_count;\n        missing_symbol++\n      ) {\n        TSStateId state_after_missing_symbol = ts_language_next_state(\n          self->language, state, missing_symbol\n        );\n        if (state_after_missing_symbol == 0 || state_after_missing_symbol == state) {\n          continue;\n        }\n\n        if (ts_language_has_reduce_action(\n          self->language,\n          state_after_missing_symbol,\n          ts_subtree_leaf_symbol(lookahead)\n        )) {\n          // In case the parser is currently outside of any included range, the lexer will\n          // snap to the beginning of the next included range. The missing token's padding\n          // must be assigned to position it within the next included range.\n          ts_lexer_reset(&self->lexer, position);\n          ts_lexer_mark_end(&self->lexer);\n          Length padding = length_sub(self->lexer.token_end_position, position);\n          uint32_t lookahead_bytes = ts_subtree_total_bytes(lookahead) + ts_subtree_lookahead_bytes(lookahead);\n\n          StackVersion version_with_missing_tree = ts_stack_copy_version(self->stack, v);\n          Subtree missing_tree = ts_subtree_new_missing_leaf(\n            &self->tree_pool, missing_symbol,\n            padding, lookahead_bytes,\n            self->language\n          );\n          ts_stack_push(\n            self->stack, version_with_missing_tree,\n            missing_tree, false,\n            state_after_missing_symbol\n          );\n\n          if (ts_parser__do_all_potential_reductions(\n            self, version_with_missing_tree,\n            ts_subtree_leaf_symbol(lookahead)\n          )) {\n            LOG(\n              \"recover_with_missing symbol:%s, state:%u\",\n              SYM_NAME(missing_symbol),\n              ts_stack_state(self->stack, version_with_missing_tree)\n            );\n            did_insert_missing_token = true;\n            break;\n          }\n        }\n      }\n    }\n\n    ts_stack_push(self->stack, v, NULL_SUBTREE, false, ERROR_STATE);\n    v = (v == version) ? previous_version_count : v + 1;\n  }\n\n  for (unsigned i = previous_version_count; i < version_count; i++) {\n    bool did_merge = ts_stack_merge(self->stack, version, previous_version_count);\n    ts_assert(did_merge);\n  }\n\n  ts_stack_record_summary(self->stack, version, MAX_SUMMARY_DEPTH);\n\n  // Begin recovery with the current lookahead node, rather than waiting for the\n  // next turn of the parse loop. This ensures that the tree accounts for the\n  // current lookahead token's \"lookahead bytes\" value, which describes how far\n  // the lexer needed to look ahead beyond the content of the token in order to\n  // recognize it.\n  if (ts_subtree_child_count(lookahead) > 0) {\n    ts_parser__breakdown_lookahead(self, &lookahead, ERROR_STATE, &self->reusable_node);\n  }\n  ts_parser__recover(self, version, lookahead);\n\n  LOG_STACK();\n}\n\nstatic bool ts_parser__check_progress(TSParser *self, Subtree *lookahead, const uint32_t *position, unsigned operations) {\n  self->operation_count += operations;\n  if (self->operation_count >= OP_COUNT_PER_PARSER_CALLBACK_CHECK) {\n    self->operation_count = 0;\n  }\n  if (position != NULL) {\n    self->parse_state.current_byte_offset = *position;\n    self->parse_state.has_error = self->has_error;\n  }\n  if (\n    self->operation_count == 0 &&\n    (self->parse_options.progress_callback && self->parse_options.progress_callback(&self->parse_state))\n  ) {\n    if (lookahead && lookahead->ptr) {\n      ts_subtree_release(&self->tree_pool, *lookahead);\n    }\n    return false;\n  }\n  return true;\n}\n\nstatic bool ts_parser__advance(\n  TSParser *self,\n  StackVersion version,\n  bool allow_node_reuse\n) {\n  TSStateId state = ts_stack_state(self->stack, version);\n  uint32_t position = ts_stack_position(self->stack, version).bytes;\n  Subtree last_external_token = ts_stack_last_external_token(self->stack, version);\n\n  bool did_reuse = true;\n  Subtree lookahead = NULL_SUBTREE;\n  TableEntry table_entry = {.action_count = 0};\n\n  // If possible, reuse a node from the previous syntax tree.\n  if (allow_node_reuse) {\n    lookahead = ts_parser__reuse_node(\n      self, version, &state, position, last_external_token, &table_entry\n    );\n  }\n\n  // If no node from the previous syntax tree could be reused, then try to\n  // reuse the token previously returned by the lexer.\n  if (!lookahead.ptr) {\n    did_reuse = false;\n    lookahead = ts_parser__get_cached_token(\n      self, state, position, last_external_token, &table_entry\n    );\n  }\n\n  bool needs_lex = !lookahead.ptr;\n  for (;;) {\n    // Otherwise, re-run the lexer.\n    if (needs_lex) {\n      needs_lex = false;\n      lookahead = ts_parser__lex(self, version, state);\n      if (self->has_scanner_error) return false;\n\n      if (lookahead.ptr) {\n        ts_parser__set_cached_token(self, position, last_external_token, lookahead);\n        ts_language_table_entry(self->language, state, ts_subtree_symbol(lookahead), &table_entry);\n      }\n\n      // When parsing a non-terminal extra, a null lookahead indicates the\n      // end of the rule. The reduction is stored in the EOF table entry.\n      // After the reduction, the lexer needs to be run again.\n      else {\n        ts_language_table_entry(self->language, state, ts_builtin_sym_end, &table_entry);\n      }\n    }\n\n    // If a progress callback was provided, then check every\n    // time a fixed number of parse actions has been processed.\n    if (!ts_parser__check_progress(self, &lookahead, &position, 1)) {\n      return false;\n    }\n\n    // Process each parse action for the current lookahead token in\n    // the current state. If there are multiple actions, then this is\n    // an ambiguous state. REDUCE actions always create a new stack\n    // version, whereas SHIFT actions update the existing stack version\n    // and terminate this loop.\n    bool did_reduce = false;\n    StackVersion last_reduction_version = STACK_VERSION_NONE;\n    for (uint32_t i = 0; i < table_entry.action_count; i++) {\n      TSParseAction action = table_entry.actions[i];\n\n      switch (action.type) {\n        case TSParseActionTypeShift: {\n          if (action.shift.repetition) break;\n          TSStateId next_state;\n          if (action.shift.extra) {\n            next_state = state;\n            LOG(\"shift_extra\");\n          } else {\n            next_state = action.shift.state;\n            LOG(\"shift state:%u\", next_state);\n          }\n\n          if (ts_subtree_child_count(lookahead) > 0) {\n            ts_parser__breakdown_lookahead(self, &lookahead, state, &self->reusable_node);\n            next_state = ts_language_next_state(self->language, state, ts_subtree_symbol(lookahead));\n          }\n\n          ts_parser__shift(self, version, next_state, lookahead, action.shift.extra);\n          if (did_reuse) reusable_node_advance(&self->reusable_node);\n          return true;\n        }\n\n        case TSParseActionTypeReduce: {\n          bool is_fragile = table_entry.action_count > 1;\n          bool end_of_non_terminal_extra = lookahead.ptr == NULL;\n          LOG(\"reduce sym:%s, child_count:%u\", SYM_NAME(action.reduce.symbol), action.reduce.child_count);\n          StackVersion reduction_version = ts_parser__reduce(\n            self, version, action.reduce.symbol, action.reduce.child_count,\n            action.reduce.dynamic_precedence, action.reduce.production_id,\n            is_fragile, end_of_non_terminal_extra\n          );\n          did_reduce = true;\n          if (reduction_version != STACK_VERSION_NONE) {\n            last_reduction_version = reduction_version;\n          }\n          break;\n        }\n\n        case TSParseActionTypeAccept: {\n          LOG(\"accept\");\n          ts_parser__accept(self, version, lookahead);\n          return true;\n        }\n\n        case TSParseActionTypeRecover: {\n          if (ts_subtree_child_count(lookahead) > 0) {\n            ts_parser__breakdown_lookahead(self, &lookahead, ERROR_STATE, &self->reusable_node);\n          }\n\n          ts_parser__recover(self, version, lookahead);\n          if (did_reuse) reusable_node_advance(&self->reusable_node);\n          return true;\n        }\n      }\n    }\n\n    // If a reduction was performed, then replace the current stack version\n    // with one of the stack versions created by a reduction, and continue\n    // processing this version of the stack with the same lookahead symbol.\n    if (last_reduction_version != STACK_VERSION_NONE) {\n      ts_stack_renumber_version(self->stack, last_reduction_version, version);\n      LOG_STACK();\n      state = ts_stack_state(self->stack, version);\n\n      // At the end of a non-terminal extra rule, the lexer will return a\n      // null subtree, because the parser needs to perform a fixed reduction\n      // regardless of the lookahead node. After performing that reduction,\n      // (and completing the non-terminal extra rule) run the lexer again based\n      // on the current parse state.\n      if (!lookahead.ptr) {\n        needs_lex = true;\n      } else {\n        ts_language_table_entry(\n          self->language,\n          state,\n          ts_subtree_leaf_symbol(lookahead),\n          &table_entry\n        );\n      }\n\n      continue;\n    }\n\n    // A reduction was performed, but was merged into an existing stack version.\n    // This version can be discarded.\n    if (did_reduce) {\n      if (lookahead.ptr) {\n        ts_subtree_release(&self->tree_pool, lookahead);\n      }\n      ts_stack_halt(self->stack, version);\n      return true;\n    }\n\n    // If the current lookahead token is a keyword that is not valid, but the\n    // default word token *is* valid, then treat the lookahead token as the word\n    // token instead.\n    if (\n      ts_subtree_is_keyword(lookahead) &&\n      ts_subtree_symbol(lookahead) != self->language->keyword_capture_token &&\n      !ts_language_is_reserved_word(self->language, state, ts_subtree_symbol(lookahead))\n    ) {\n      ts_language_table_entry(\n        self->language,\n        state,\n        self->language->keyword_capture_token,\n        &table_entry\n      );\n      if (table_entry.action_count > 0) {\n        LOG(\n          \"switch from_keyword:%s, to_word_token:%s\",\n          TREE_NAME(lookahead),\n          SYM_NAME(self->language->keyword_capture_token)\n        );\n\n        MutableSubtree mutable_lookahead = ts_subtree_make_mut(&self->tree_pool, lookahead);\n        ts_subtree_set_symbol(&mutable_lookahead, self->language->keyword_capture_token, self->language);\n        lookahead = ts_subtree_from_mut(mutable_lookahead);\n        continue;\n      }\n    }\n\n    // If the current lookahead token is not valid and the previous subtree on\n    // the stack was reused from an old tree, then it wasn't actually valid to\n    // reuse that previous subtree. Remove it from the stack, and in its place,\n    // push each of its children. Then try again to process the current lookahead.\n    if (ts_parser__breakdown_top_of_stack(self, version)) {\n      state = ts_stack_state(self->stack, version);\n      ts_subtree_release(&self->tree_pool, lookahead);\n      needs_lex = true;\n      continue;\n    }\n\n    // Otherwise, there is definitely an error in this version of the parse stack.\n    // Mark this version as paused and continue processing any other stack\n    // versions that exist. If some other version advances successfully, then\n    // this version can simply be removed. But if all versions end up paused,\n    // then error recovery is needed.\n    LOG(\"detect_error lookahead:%s\", TREE_NAME(lookahead));\n    ts_stack_pause(self->stack, version, lookahead);\n    return true;\n  }\n}\n\nstatic unsigned ts_parser__condense_stack(TSParser *self) {\n  bool made_changes = false;\n  unsigned min_error_cost = UINT_MAX;\n  for (StackVersion i = 0; i < ts_stack_version_count(self->stack); i++) {\n    // Prune any versions that have been marked for removal.\n    if (ts_stack_is_halted(self->stack, i)) {\n      ts_stack_remove_version(self->stack, i);\n      i--;\n      continue;\n    }\n\n    // Keep track of the minimum error cost of any stack version so\n    // that it can be returned.\n    ErrorStatus status_i = ts_parser__version_status(self, i);\n    if (!status_i.is_in_error && status_i.cost < min_error_cost) {\n      min_error_cost = status_i.cost;\n    }\n\n    // Examine each pair of stack versions, removing any versions that\n    // are clearly worse than another version. Ensure that the versions\n    // are ordered from most promising to least promising.\n    for (StackVersion j = 0; j < i; j++) {\n      ErrorStatus status_j = ts_parser__version_status(self, j);\n\n      switch (ts_parser__compare_versions(self, status_j, status_i)) {\n        case ErrorComparisonTakeLeft:\n          made_changes = true;\n          ts_stack_remove_version(self->stack, i);\n          i--;\n          j = i;\n          break;\n\n        case ErrorComparisonPreferLeft:\n        case ErrorComparisonNone:\n          if (ts_stack_merge(self->stack, j, i)) {\n            made_changes = true;\n            i--;\n            j = i;\n          }\n          break;\n\n        case ErrorComparisonPreferRight:\n          made_changes = true;\n          if (ts_stack_merge(self->stack, j, i)) {\n            i--;\n            j = i;\n          } else {\n            ts_stack_swap_versions(self->stack, i, j);\n          }\n          break;\n\n        case ErrorComparisonTakeRight:\n          made_changes = true;\n          ts_stack_remove_version(self->stack, j);\n          i--;\n          j--;\n          break;\n      }\n    }\n  }\n\n  // Enforce a hard upper bound on the number of stack versions by\n  // discarding the least promising versions.\n  while (ts_stack_version_count(self->stack) > MAX_VERSION_COUNT) {\n    ts_stack_remove_version(self->stack, MAX_VERSION_COUNT);\n    made_changes = true;\n  }\n\n  // If the best-performing stack version is currently paused, or all\n  // versions are paused, then resume the best paused version and begin\n  // the error recovery process. Otherwise, remove the paused versions.\n  if (ts_stack_version_count(self->stack) > 0) {\n    bool has_unpaused_version = false;\n    for (StackVersion i = 0, n = ts_stack_version_count(self->stack); i < n; i++) {\n      if (ts_stack_is_paused(self->stack, i)) {\n        if (!has_unpaused_version && self->accept_count < MAX_VERSION_COUNT) {\n          LOG(\"resume version:%u\", i);\n          min_error_cost = ts_stack_error_cost(self->stack, i);\n          Subtree lookahead = ts_stack_resume(self->stack, i);\n          ts_parser__handle_error(self, i, lookahead);\n          has_unpaused_version = true;\n        } else {\n          ts_stack_remove_version(self->stack, i);\n          made_changes = true;\n          i--;\n          n--;\n        }\n      } else {\n        has_unpaused_version = true;\n      }\n    }\n  }\n\n  if (made_changes) {\n    LOG(\"condense\");\n    LOG_STACK();\n  }\n\n  return min_error_cost;\n}\n\nstatic bool ts_parser__balance_subtree(TSParser *self) {\n  Subtree finished_tree = self->finished_tree;\n\n  // If we haven't canceled balancing in progress before, then we want to clear the tree stack and\n  // push the initial finished tree onto it. Otherwise, if we're resuming balancing after a\n  // cancellation, we don't want to clear the tree stack.\n  if (!self->canceled_balancing) {\n    array_clear(&self->tree_pool.tree_stack);\n    if (ts_subtree_child_count(finished_tree) > 0 && finished_tree.ptr->ref_count == 1) {\n      array_push(&self->tree_pool.tree_stack, ts_subtree_to_mut_unsafe(finished_tree));\n    }\n  }\n\n  while (self->tree_pool.tree_stack.size > 0) {\n    if (!ts_parser__check_progress(self, NULL, NULL, 1)) {\n      return false;\n    }\n\n    MutableSubtree tree = *array_get(&self->tree_pool.tree_stack, \n      self->tree_pool.tree_stack.size - 1\n    );\n\n    if (tree.ptr->repeat_depth > 0) {\n      Subtree child1 = ts_subtree_children(tree)[0];\n      Subtree child2 = ts_subtree_children(tree)[tree.ptr->child_count - 1];\n      long repeat_delta = (long)ts_subtree_repeat_depth(child1) - (long)ts_subtree_repeat_depth(child2);\n      if (repeat_delta > 0) {\n        unsigned n = (unsigned)repeat_delta;\n\n        for (unsigned i = n / 2; i > 0; i /= 2) {\n          ts_subtree_compress(tree, i, self->language, &self->tree_pool.tree_stack);\n          n -= i;\n\n          // We scale the operation count increment in `ts_parser__check_progress` proportionately to the compression\n          // size since larger values of i take longer to process. Shifting by 4 empirically provides good check\n          // intervals (e.g. 193 operations when i=3100) to prevent blocking during large compressions.\n          uint8_t operations = i >> 4 > 0 ? i >> 4 : 1;\n          if (!ts_parser__check_progress(self, NULL, NULL, operations)) {\n            return false;\n          }\n        }\n      }\n    }\n\n    (void)array_pop(&self->tree_pool.tree_stack);\n\n    for (uint32_t i = 0; i < tree.ptr->child_count; i++) {\n      Subtree child = ts_subtree_children(tree)[i];\n      if (ts_subtree_child_count(child) > 0 && child.ptr->ref_count == 1) {\n        array_push(&self->tree_pool.tree_stack, ts_subtree_to_mut_unsafe(child));\n      }\n    }\n  }\n\n  return true;\n}\n\nstatic bool ts_parser_has_outstanding_parse(TSParser *self) {\n  return (\n    self->canceled_balancing ||\n    self->external_scanner_payload ||\n    ts_stack_state(self->stack, 0) != 1 ||\n    ts_stack_node_count_since_error(self->stack, 0) != 0\n  );\n}\n\n// Parser - Public\n\nTSParser *ts_parser_new(void) {\n  TSParser *self = ts_calloc(1, sizeof(TSParser));\n  ts_lexer_init(&self->lexer);\n  array_init(&self->reduce_actions);\n  array_reserve(&self->reduce_actions, 4);\n  self->tree_pool = ts_subtree_pool_new(32);\n  self->stack = ts_stack_new(&self->tree_pool);\n  self->finished_tree = NULL_SUBTREE;\n  self->reusable_node = reusable_node_new();\n  self->dot_graph_file = NULL;\n  self->language = NULL;\n  self->has_scanner_error = false;\n  self->has_error = false;\n  self->canceled_balancing = false;\n  self->external_scanner_payload = NULL;\n  self->operation_count = 0;\n  self->old_tree = NULL_SUBTREE;\n  self->included_range_differences = (TSRangeArray) array_new();\n  self->included_range_difference_index = 0;\n  ts_parser__set_cached_token(self, 0, NULL_SUBTREE, NULL_SUBTREE);\n  return self;\n}\n\nvoid ts_parser_delete(TSParser *self) {\n  if (!self) return;\n\n  ts_parser_set_language(self, NULL);\n  ts_stack_delete(self->stack);\n  if (self->reduce_actions.contents) {\n    array_delete(&self->reduce_actions);\n  }\n  if (self->included_range_differences.contents) {\n    array_delete(&self->included_range_differences);\n  }\n  if (self->old_tree.ptr) {\n    ts_subtree_release(&self->tree_pool, self->old_tree);\n    self->old_tree = NULL_SUBTREE;\n  }\n  ts_wasm_store_delete(self->wasm_store);\n  ts_lexer_delete(&self->lexer);\n  ts_parser__set_cached_token(self, 0, NULL_SUBTREE, NULL_SUBTREE);\n  ts_subtree_pool_delete(&self->tree_pool);\n  reusable_node_delete(&self->reusable_node);\n  array_delete(&self->trailing_extras);\n  array_delete(&self->trailing_extras2);\n  array_delete(&self->scratch_trees);\n  ts_free(self);\n}\n\nconst TSLanguage *ts_parser_language(const TSParser *self) {\n  return self->language;\n}\n\nbool ts_parser_set_language(TSParser *self, const TSLanguage *language) {\n  ts_parser_reset(self);\n  ts_language_delete(self->language);\n  self->language = NULL;\n\n  if (language) {\n    if (\n      language->abi_version > TREE_SITTER_LANGUAGE_VERSION ||\n      language->abi_version < TREE_SITTER_MIN_COMPATIBLE_LANGUAGE_VERSION\n    ) return false;\n\n    if (ts_language_is_wasm(language)) {\n      if (\n        !self->wasm_store ||\n        !ts_wasm_store_start(self->wasm_store, &self->lexer.data, language)\n      ) return false;\n    }\n  }\n\n  self->language = ts_language_copy(language);\n  return true;\n}\n\nTSLogger ts_parser_logger(const TSParser *self) {\n  return self->lexer.logger;\n}\n\nvoid ts_parser_set_logger(TSParser *self, TSLogger logger) {\n  self->lexer.logger = logger;\n}\n\nvoid ts_parser_print_dot_graphs(TSParser *self, int fd) {\n  if (self->dot_graph_file) {\n    fclose(self->dot_graph_file);\n  }\n\n  if (fd >= 0) {\n    #ifdef _WIN32\n    self->dot_graph_file = _fdopen(fd, \"a\");\n    #else\n    self->dot_graph_file = fdopen(fd, \"a\");\n    #endif\n  } else {\n    self->dot_graph_file = NULL;\n  }\n}\n\nbool ts_parser_set_included_ranges(\n  TSParser *self,\n  const TSRange *ranges,\n  uint32_t count\n) {\n  return ts_lexer_set_included_ranges(&self->lexer, ranges, count);\n}\n\nconst TSRange *ts_parser_included_ranges(const TSParser *self, uint32_t *count) {\n  return ts_lexer_included_ranges(&self->lexer, count);\n}\n\nvoid ts_parser_reset(TSParser *self) {\n  ts_parser__external_scanner_destroy(self);\n  if (self->wasm_store) {\n    ts_wasm_store_reset(self->wasm_store);\n  }\n\n  if (self->old_tree.ptr) {\n    ts_subtree_release(&self->tree_pool, self->old_tree);\n    self->old_tree = NULL_SUBTREE;\n  }\n\n  reusable_node_clear(&self->reusable_node);\n  ts_lexer_reset(&self->lexer, length_zero());\n  ts_stack_clear(self->stack);\n  ts_parser__set_cached_token(self, 0, NULL_SUBTREE, NULL_SUBTREE);\n  if (self->finished_tree.ptr) {\n    ts_subtree_release(&self->tree_pool, self->finished_tree);\n    self->finished_tree = NULL_SUBTREE;\n  }\n  self->accept_count = 0;\n  self->has_scanner_error = false;\n  self->has_error = false;\n  self->canceled_balancing = false;\n  self->parse_options = (TSParseOptions) {0};\n  self->parse_state = (TSParseState) {0};\n}\n\nTSTree *ts_parser_parse(\n  TSParser *self,\n  const TSTree *old_tree,\n  TSInput input\n) {\n  TSTree *result = NULL;\n  if (!self->language || !input.read) return NULL;\n\n  if (ts_language_is_wasm(self->language)) {\n    if (!self->wasm_store) return NULL;\n    ts_wasm_store_start(self->wasm_store, &self->lexer.data, self->language);\n  }\n\n  ts_lexer_set_input(&self->lexer, input);\n  array_clear(&self->included_range_differences);\n  self->included_range_difference_index = 0;\n\n  self->operation_count = 0;\n\n  if (ts_parser_has_outstanding_parse(self)) {\n    LOG(\"resume_parsing\");\n    if (self->canceled_balancing) goto balance;\n  } else {\n    ts_parser__external_scanner_create(self);\n    if (self->has_scanner_error) goto exit;\n\n    if (old_tree) {\n      ts_subtree_retain(old_tree->root);\n      self->old_tree = old_tree->root;\n      ts_range_array_get_changed_ranges(\n        old_tree->included_ranges, old_tree->included_range_count,\n        self->lexer.included_ranges, self->lexer.included_range_count,\n        &self->included_range_differences\n      );\n      reusable_node_reset(&self->reusable_node, old_tree->root);\n      LOG(\"parse_after_edit\");\n      LOG_TREE(self->old_tree);\n      for (unsigned i = 0; i < self->included_range_differences.size; i++) {\n        TSRange *range = array_get(&self->included_range_differences, i);\n        LOG(\"different_included_range %u - %u\", range->start_byte, range->end_byte);\n      }\n    } else {\n      reusable_node_clear(&self->reusable_node);\n      LOG(\"new_parse\");\n    }\n  }\n\n  uint32_t position = 0, last_position = 0, version_count = 0;\n  do {\n    for (\n      StackVersion version = 0;\n      version_count = ts_stack_version_count(self->stack),\n      version < version_count;\n      version++\n    ) {\n      bool allow_node_reuse = version_count == 1;\n      while (ts_stack_is_active(self->stack, version)) {\n        LOG(\n          \"process version:%u, version_count:%u, state:%d, row:%u, col:%u\",\n          version,\n          ts_stack_version_count(self->stack),\n          ts_stack_state(self->stack, version),\n          ts_stack_position(self->stack, version).extent.row,\n          ts_stack_position(self->stack, version).extent.column\n        );\n\n        if (!ts_parser__advance(self, version, allow_node_reuse)) {\n          if (self->has_scanner_error) goto exit;\n          return NULL;\n        }\n\n        LOG_STACK();\n\n        position = ts_stack_position(self->stack, version).bytes;\n        if (position > last_position || (version > 0 && position == last_position)) {\n          last_position = position;\n          break;\n        }\n      }\n    }\n\n    // After advancing each version of the stack, re-sort the versions by their cost,\n    // removing any versions that are no longer worth pursuing.\n    unsigned min_error_cost = ts_parser__condense_stack(self);\n\n    // If there's already a finished parse tree that's better than any in-progress version,\n    // then terminate parsing. Clear the parse stack to remove any extra references to subtrees\n    // within the finished tree, ensuring that these subtrees can be safely mutated in-place\n    // for rebalancing.\n    if (self->finished_tree.ptr && ts_subtree_error_cost(self->finished_tree) < min_error_cost) {\n      ts_stack_clear(self->stack);\n      break;\n    }\n\n    while (self->included_range_difference_index < self->included_range_differences.size) {\n      TSRange *range = array_get(&self->included_range_differences, self->included_range_difference_index);\n      if (range->end_byte <= position) {\n        self->included_range_difference_index++;\n      } else {\n        break;\n      }\n    }\n  } while (version_count != 0);\n\nbalance:\n  ts_assert(self->finished_tree.ptr);\n  if (!ts_parser__balance_subtree(self)) {\n    self->canceled_balancing = true;\n    return false;\n  }\n  self->canceled_balancing = false;\n  LOG(\"done\");\n  LOG_TREE(self->finished_tree);\n\n  result = ts_tree_new(\n    self->finished_tree,\n    self->language,\n    self->lexer.included_ranges,\n    self->lexer.included_range_count\n  );\n  self->finished_tree = NULL_SUBTREE;\n\nexit:\n  ts_parser_reset(self);\n  return result;\n}\n\nTSTree *ts_parser_parse_with_options(\n  TSParser *self,\n  const TSTree *old_tree,\n  TSInput input,\n  TSParseOptions parse_options\n) {\n  self->parse_options = parse_options;\n  self->parse_state.payload = parse_options.payload;\n  TSTree *result = ts_parser_parse(self, old_tree, input);\n  // Reset parser options before further parse calls.\n  self->parse_options = (TSParseOptions) {0};\n  return result;\n}\n\nTSTree *ts_parser_parse_string(\n  TSParser *self,\n  const TSTree *old_tree,\n  const char *string,\n  uint32_t length\n) {\n  return ts_parser_parse_string_encoding(self, old_tree, string, length, TSInputEncodingUTF8);\n}\n\nTSTree *ts_parser_parse_string_encoding(\n  TSParser *self,\n  const TSTree *old_tree,\n  const char *string,\n  uint32_t length,\n  TSInputEncoding encoding\n) {\n  TSStringInput input = {string, length};\n  return ts_parser_parse(self, old_tree, (TSInput) {\n    &input,\n    ts_string_input_read,\n    encoding,\n    NULL,\n  });\n}\n\nvoid ts_parser_set_wasm_store(TSParser *self, TSWasmStore *store) {\n  if (self->language && ts_language_is_wasm(self->language)) {\n    // Copy the assigned language into the new store.\n    const TSLanguage *copy = ts_language_copy(self->language);\n    ts_parser_set_language(self, copy);\n    ts_language_delete(copy);\n  }\n\n  ts_wasm_store_delete(self->wasm_store);\n  self->wasm_store = store;\n}\n\nTSWasmStore *ts_parser_take_wasm_store(TSParser *self) {\n  if (self->language && ts_language_is_wasm(self->language)) {\n    ts_parser_set_language(self, NULL);\n  }\n\n  TSWasmStore *result = self->wasm_store;\n  self->wasm_store = NULL;\n  return result;\n}\n\n#undef LOG\n",
    "#include \"./alloc.h\"\n#include \"./language.h\"\n#include \"./subtree.h\"\n#include \"./array.h\"\n#include \"./stack.h\"\n#include \"./length.h\"\n#include <assert.h>\n#include <inttypes.h>\n#include <stdio.h>\n\n#define MAX_LINK_COUNT 8\n#define MAX_NODE_POOL_SIZE 50\n#define MAX_ITERATOR_COUNT 64\n\n#if defined _WIN32 && !defined __GNUC__\n#define forceinline __forceinline\n#else\n#define forceinline static inline __attribute__((always_inline))\n#endif\n\ntypedef struct StackNode StackNode;\n\ntypedef struct {\n  StackNode *node;\n  Subtree subtree;\n  bool is_pending;\n} StackLink;\n\nstruct StackNode {\n  TSStateId state;\n  Length position;\n  StackLink links[MAX_LINK_COUNT];\n  short unsigned int link_count;\n  uint32_t ref_count;\n  unsigned error_cost;\n  unsigned node_count;\n  int dynamic_precedence;\n};\n\ntypedef struct {\n  StackNode *node;\n  SubtreeArray subtrees;\n  uint32_t subtree_count;\n  bool is_pending;\n} StackIterator;\n\ntypedef Array(StackNode *) StackNodeArray;\n\ntypedef enum {\n  StackStatusActive,\n  StackStatusPaused,\n  StackStatusHalted,\n} StackStatus;\n\ntypedef struct {\n  StackNode *node;\n  StackSummary *summary;\n  unsigned node_count_at_last_error;\n  Subtree last_external_token;\n  Subtree lookahead_when_paused;\n  StackStatus status;\n} StackHead;\n\nstruct Stack {\n  Array(StackHead) heads;\n  StackSliceArray slices;\n  Array(StackIterator) iterators;\n  StackNodeArray node_pool;\n  StackNode *base_node;\n  SubtreePool *subtree_pool;\n};\n\ntypedef unsigned StackAction;\nenum {\n  StackActionNone,\n  StackActionStop = 1,\n  StackActionPop = 2,\n};\n\ntypedef StackAction (*StackCallback)(void *, const StackIterator *);\n\nstatic void stack_node_retain(StackNode *self) {\n  if (!self)\n    return;\n  ts_assert(self->ref_count > 0);\n  self->ref_count++;\n  ts_assert(self->ref_count != 0);\n}\n\nstatic void stack_node_release(\n  StackNode *self,\n  StackNodeArray *pool,\n  SubtreePool *subtree_pool\n) {\nrecur:\n  ts_assert(self->ref_count != 0);\n  self->ref_count--;\n  if (self->ref_count > 0) return;\n\n  StackNode *first_predecessor = NULL;\n  if (self->link_count > 0) {\n    for (unsigned i = self->link_count - 1; i > 0; i--) {\n      StackLink link = self->links[i];\n      if (link.subtree.ptr) ts_subtree_release(subtree_pool, link.subtree);\n      stack_node_release(link.node, pool, subtree_pool);\n    }\n    StackLink link = self->links[0];\n    if (link.subtree.ptr) ts_subtree_release(subtree_pool, link.subtree);\n    first_predecessor = self->links[0].node;\n  }\n\n  if (pool->size < MAX_NODE_POOL_SIZE) {\n    array_push(pool, self);\n  } else {\n    ts_free(self);\n  }\n\n  if (first_predecessor) {\n    self = first_predecessor;\n    goto recur;\n  }\n}\n\n/// Get the number of nodes in the subtree, for the purpose of measuring\n/// how much progress has been made by a given version of the stack.\nstatic uint32_t stack__subtree_node_count(Subtree subtree) {\n  uint32_t count = ts_subtree_visible_descendant_count(subtree);\n  if (ts_subtree_visible(subtree)) count++;\n\n  // Count intermediate error nodes even though they are not visible,\n  // because a stack version's node count is used to check whether it\n  // has made any progress since the last time it encountered an error.\n  if (ts_subtree_symbol(subtree) == ts_builtin_sym_error_repeat) count++;\n\n  return count;\n}\n\nstatic StackNode *stack_node_new(\n  StackNode *previous_node,\n  Subtree subtree,\n  bool is_pending,\n  TSStateId state,\n  StackNodeArray *pool\n) {\n  StackNode *node = pool->size > 0\n    ? array_pop(pool)\n    : ts_malloc(sizeof(StackNode));\n  *node = (StackNode) {\n    .ref_count = 1,\n    .link_count = 0,\n    .state = state\n  };\n\n  if (previous_node) {\n    node->link_count = 1;\n    node->links[0] = (StackLink) {\n      .node = previous_node,\n      .subtree = subtree,\n      .is_pending = is_pending,\n    };\n\n    node->position = previous_node->position;\n    node->error_cost = previous_node->error_cost;\n    node->dynamic_precedence = previous_node->dynamic_precedence;\n    node->node_count = previous_node->node_count;\n\n    if (subtree.ptr) {\n      node->error_cost += ts_subtree_error_cost(subtree);\n      node->position = length_add(node->position, ts_subtree_total_size(subtree));\n      node->node_count += stack__subtree_node_count(subtree);\n      node->dynamic_precedence += ts_subtree_dynamic_precedence(subtree);\n    }\n  } else {\n    node->position = length_zero();\n    node->error_cost = 0;\n  }\n\n  return node;\n}\n\nstatic bool stack__subtree_is_equivalent(Subtree left, Subtree right) {\n  if (left.ptr == right.ptr) return true;\n  if (!left.ptr || !right.ptr) return false;\n\n  // Symbols must match\n  if (ts_subtree_symbol(left) != ts_subtree_symbol(right)) return false;\n\n  // If both have errors, don't bother keeping both.\n  if (ts_subtree_error_cost(left) > 0 && ts_subtree_error_cost(right) > 0) return true;\n\n  return (\n    ts_subtree_padding(left).bytes == ts_subtree_padding(right).bytes &&\n    ts_subtree_size(left).bytes == ts_subtree_size(right).bytes &&\n    ts_subtree_child_count(left) == ts_subtree_child_count(right) &&\n    ts_subtree_extra(left) == ts_subtree_extra(right) &&\n    ts_subtree_external_scanner_state_eq(left, right)\n  );\n}\n\nstatic void stack_node_add_link(\n  StackNode *self,\n  StackLink link,\n  SubtreePool *subtree_pool\n) {\n  if (link.node == self) return;\n\n  for (int i = 0; i < self->link_count; i++) {\n    StackLink *existing_link = &self->links[i];\n    if (stack__subtree_is_equivalent(existing_link->subtree, link.subtree)) {\n      // In general, we preserve ambiguities until they are removed from the stack\n      // during a pop operation where multiple paths lead to the same node. But in\n      // the special case where two links directly connect the same pair of nodes,\n      // we can safely remove the ambiguity ahead of time without changing behavior.\n      if (existing_link->node == link.node) {\n        if (\n          ts_subtree_dynamic_precedence(link.subtree) >\n          ts_subtree_dynamic_precedence(existing_link->subtree)\n        ) {\n          ts_subtree_retain(link.subtree);\n          ts_subtree_release(subtree_pool, existing_link->subtree);\n          existing_link->subtree = link.subtree;\n          self->dynamic_precedence =\n            link.node->dynamic_precedence + ts_subtree_dynamic_precedence(link.subtree);\n        }\n        return;\n      }\n\n      // If the previous nodes are mergeable, merge them recursively.\n      if (\n        existing_link->node->state == link.node->state &&\n        existing_link->node->position.bytes == link.node->position.bytes &&\n        existing_link->node->error_cost == link.node->error_cost\n      ) {\n        for (int j = 0; j < link.node->link_count; j++) {\n          stack_node_add_link(existing_link->node, link.node->links[j], subtree_pool);\n        }\n        int32_t dynamic_precedence = link.node->dynamic_precedence;\n        if (link.subtree.ptr) {\n          dynamic_precedence += ts_subtree_dynamic_precedence(link.subtree);\n        }\n        if (dynamic_precedence > self->dynamic_precedence) {\n          self->dynamic_precedence = dynamic_precedence;\n        }\n        return;\n      }\n    }\n  }\n\n  if (self->link_count == MAX_LINK_COUNT) return;\n\n  stack_node_retain(link.node);\n  unsigned node_count = link.node->node_count;\n  int dynamic_precedence = link.node->dynamic_precedence;\n  self->links[self->link_count++] = link;\n\n  if (link.subtree.ptr) {\n    ts_subtree_retain(link.subtree);\n    node_count += stack__subtree_node_count(link.subtree);\n    dynamic_precedence += ts_subtree_dynamic_precedence(link.subtree);\n  }\n\n  if (node_count > self->node_count) self->node_count = node_count;\n  if (dynamic_precedence > self->dynamic_precedence) self->dynamic_precedence = dynamic_precedence;\n}\n\nstatic void stack_head_delete(\n  StackHead *self,\n  StackNodeArray *pool,\n  SubtreePool *subtree_pool\n) {\n  if (self->node) {\n    if (self->last_external_token.ptr) {\n      ts_subtree_release(subtree_pool, self->last_external_token);\n    }\n    if (self->lookahead_when_paused.ptr) {\n      ts_subtree_release(subtree_pool, self->lookahead_when_paused);\n    }\n    if (self->summary) {\n      array_delete(self->summary);\n      ts_free(self->summary);\n    }\n    stack_node_release(self->node, pool, subtree_pool);\n  }\n}\n\nstatic StackVersion ts_stack__add_version(\n  Stack *self,\n  StackVersion original_version,\n  StackNode *node\n) {\n  StackHead head = {\n    .node = node,\n    .node_count_at_last_error = array_get(&self->heads, original_version)->node_count_at_last_error,\n    .last_external_token = array_get(&self->heads, original_version)->last_external_token,\n    .status = StackStatusActive,\n    .lookahead_when_paused = NULL_SUBTREE,\n  };\n  array_push(&self->heads, head);\n  stack_node_retain(node);\n  if (head.last_external_token.ptr) ts_subtree_retain(head.last_external_token);\n  return (StackVersion)(self->heads.size - 1);\n}\n\nstatic void ts_stack__add_slice(\n  Stack *self,\n  StackVersion original_version,\n  StackNode *node,\n  SubtreeArray *subtrees\n) {\n  for (uint32_t i = self->slices.size - 1; i + 1 > 0; i--) {\n    StackVersion version = array_get(&self->slices, i)->version;\n    if (array_get(&self->heads, version)->node == node) {\n      StackSlice slice = {*subtrees, version};\n      array_insert(&self->slices, i + 1, slice);\n      return;\n    }\n  }\n\n  StackVersion version = ts_stack__add_version(self, original_version, node);\n  StackSlice slice = { *subtrees, version };\n  array_push(&self->slices, slice);\n}\n\nstatic StackSliceArray stack__iter(\n  Stack *self,\n  StackVersion version,\n  StackCallback callback,\n  void *payload,\n  int goal_subtree_count\n) {\n  array_clear(&self->slices);\n  array_clear(&self->iterators);\n\n  StackHead *head = array_get(&self->heads, version);\n  StackIterator new_iterator = {\n    .node = head->node,\n    .subtrees = array_new(),\n    .subtree_count = 0,\n    .is_pending = true,\n  };\n\n  bool include_subtrees = false;\n  if (goal_subtree_count >= 0) {\n    include_subtrees = true;\n    array_reserve(&new_iterator.subtrees, (uint32_t)ts_subtree_alloc_size(goal_subtree_count) / sizeof(Subtree));\n  }\n\n  array_push(&self->iterators, new_iterator);\n\n  while (self->iterators.size > 0) {\n    for (uint32_t i = 0, size = self->iterators.size; i < size; i++) {\n      StackIterator *iterator = array_get(&self->iterators, i);\n      StackNode *node = iterator->node;\n\n      StackAction action = callback(payload, iterator);\n      bool should_pop = action & StackActionPop;\n      bool should_stop = action & StackActionStop || node->link_count == 0;\n\n      if (should_pop) {\n        SubtreeArray subtrees = iterator->subtrees;\n        if (!should_stop) {\n          ts_subtree_array_copy(subtrees, &subtrees);\n        }\n        ts_subtree_array_reverse(&subtrees);\n        ts_stack__add_slice(\n          self,\n          version,\n          node,\n          &subtrees\n        );\n      }\n\n      if (should_stop) {\n        if (!should_pop) {\n          ts_subtree_array_delete(self->subtree_pool, &iterator->subtrees);\n        }\n        array_erase(&self->iterators, i);\n        i--, size--;\n        continue;\n      }\n\n      for (uint32_t j = 1; j <= node->link_count; j++) {\n        StackIterator *next_iterator;\n        StackLink link;\n        if (j == node->link_count) {\n          link = node->links[0];\n          next_iterator = array_get(&self->iterators, i);\n        } else {\n          if (self->iterators.size >= MAX_ITERATOR_COUNT) continue;\n          link = node->links[j];\n          StackIterator current_iterator = *array_get(&self->iterators, i);\n          array_push(&self->iterators, current_iterator);\n          next_iterator = array_back(&self->iterators);\n          ts_subtree_array_copy(next_iterator->subtrees, &next_iterator->subtrees);\n        }\n\n        next_iterator->node = link.node;\n        if (link.subtree.ptr) {\n          if (include_subtrees) {\n            array_push(&next_iterator->subtrees, link.subtree);\n            ts_subtree_retain(link.subtree);\n          }\n\n          if (!ts_subtree_extra(link.subtree)) {\n            next_iterator->subtree_count++;\n            if (!link.is_pending) {\n              next_iterator->is_pending = false;\n            }\n          }\n        } else {\n          next_iterator->subtree_count++;\n          next_iterator->is_pending = false;\n        }\n      }\n    }\n  }\n\n  return self->slices;\n}\n\nStack *ts_stack_new(SubtreePool *subtree_pool) {\n  Stack *self = ts_calloc(1, sizeof(Stack));\n\n  array_init(&self->heads);\n  array_init(&self->slices);\n  array_init(&self->iterators);\n  array_init(&self->node_pool);\n  array_reserve(&self->heads, 4);\n  array_reserve(&self->slices, 4);\n  array_reserve(&self->iterators, 4);\n  array_reserve(&self->node_pool, MAX_NODE_POOL_SIZE);\n\n  self->subtree_pool = subtree_pool;\n  self->base_node = stack_node_new(NULL, NULL_SUBTREE, false, 1, &self->node_pool);\n  ts_stack_clear(self);\n\n  return self;\n}\n\nvoid ts_stack_delete(Stack *self) {\n  if (self->slices.contents)\n    array_delete(&self->slices);\n  if (self->iterators.contents)\n    array_delete(&self->iterators);\n  stack_node_release(self->base_node, &self->node_pool, self->subtree_pool);\n  for (uint32_t i = 0; i < self->heads.size; i++) {\n    stack_head_delete(array_get(&self->heads, i), &self->node_pool, self->subtree_pool);\n  }\n  array_clear(&self->heads);\n  if (self->node_pool.contents) {\n    for (uint32_t i = 0; i < self->node_pool.size; i++)\n      ts_free(*array_get(&self->node_pool, i));\n    array_delete(&self->node_pool);\n  }\n  array_delete(&self->heads);\n  ts_free(self);\n}\n\nuint32_t ts_stack_version_count(const Stack *self) {\n  return self->heads.size;\n}\n\nuint32_t ts_stack_halted_version_count(Stack *self) {\n  uint32_t count = 0;\n  for (uint32_t i = 0; i < self->heads.size; i++) {\n    StackHead *head = array_get(&self->heads, i);\n    if (head->status == StackStatusHalted) {\n      count++;\n    }\n  }\n  return count;\n}\n\nTSStateId ts_stack_state(const Stack *self, StackVersion version) {\n  return array_get(&self->heads, version)->node->state;\n}\n\nLength ts_stack_position(const Stack *self, StackVersion version) {\n  return array_get(&self->heads, version)->node->position;\n}\n\nSubtree ts_stack_last_external_token(const Stack *self, StackVersion version) {\n  return array_get(&self->heads, version)->last_external_token;\n}\n\nvoid ts_stack_set_last_external_token(Stack *self, StackVersion version, Subtree token) {\n  StackHead *head = array_get(&self->heads, version);\n  if (token.ptr) ts_subtree_retain(token);\n  if (head->last_external_token.ptr) ts_subtree_release(self->subtree_pool, head->last_external_token);\n  head->last_external_token = token;\n}\n\nunsigned ts_stack_error_cost(const Stack *self, StackVersion version) {\n  StackHead *head = array_get(&self->heads, version);\n  unsigned result = head->node->error_cost;\n  if (\n    head->status == StackStatusPaused ||\n    (head->node->state == ERROR_STATE && !head->node->links[0].subtree.ptr)) {\n    result += ERROR_COST_PER_RECOVERY;\n  }\n  return result;\n}\n\nunsigned ts_stack_node_count_since_error(const Stack *self, StackVersion version) {\n  StackHead *head = array_get(&self->heads, version);\n  if (head->node->node_count < head->node_count_at_last_error) {\n    head->node_count_at_last_error = head->node->node_count;\n  }\n  return head->node->node_count - head->node_count_at_last_error;\n}\n\nvoid ts_stack_push(\n  Stack *self,\n  StackVersion version,\n  Subtree subtree,\n  bool pending,\n  TSStateId state\n) {\n  StackHead *head = array_get(&self->heads, version);\n  StackNode *new_node = stack_node_new(head->node, subtree, pending, state, &self->node_pool);\n  if (!subtree.ptr) head->node_count_at_last_error = new_node->node_count;\n  head->node = new_node;\n}\n\nforceinline StackAction pop_count_callback(void *payload, const StackIterator *iterator) {\n  unsigned *goal_subtree_count = payload;\n  if (iterator->subtree_count == *goal_subtree_count) {\n    return StackActionPop | StackActionStop;\n  } else {\n    return StackActionNone;\n  }\n}\n\nStackSliceArray ts_stack_pop_count(Stack *self, StackVersion version, uint32_t count) {\n  return stack__iter(self, version, pop_count_callback, &count, (int)count);\n}\n\n\nforceinline StackAction pop_pending_callback(void *payload, const StackIterator *iterator) {\n  (void)payload;\n  if (iterator->subtree_count >= 1) {\n    if (iterator->is_pending) {\n      return StackActionPop | StackActionStop;\n    } else {\n      return StackActionStop;\n    }\n  } else {\n    return StackActionNone;\n  }\n}\n\nStackSliceArray ts_stack_pop_pending(Stack *self, StackVersion version) {\n  StackSliceArray pop = stack__iter(self, version, pop_pending_callback, NULL, 0);\n  if (pop.size > 0) {\n    ts_stack_renumber_version(self, array_get(&pop, 0)->version, version);\n    array_get(&pop, 0)->version = version;\n  }\n  return pop;\n}\n\nforceinline StackAction pop_error_callback(void *payload, const StackIterator *iterator) {\n  if (iterator->subtrees.size > 0) {\n    bool *found_error = payload;\n    if (!*found_error && ts_subtree_is_error(*array_get(&iterator->subtrees, 0))) {\n      *found_error = true;\n      return StackActionPop | StackActionStop;\n    } else {\n      return StackActionStop;\n    }\n  } else {\n    return StackActionNone;\n  }\n}\n\nSubtreeArray ts_stack_pop_error(Stack *self, StackVersion version) {\n  StackNode *node = array_get(&self->heads, version)->node;\n  for (unsigned i = 0; i < node->link_count; i++) {\n    if (node->links[i].subtree.ptr && ts_subtree_is_error(node->links[i].subtree)) {\n      bool found_error = false;\n      StackSliceArray pop = stack__iter(self, version, pop_error_callback, &found_error, 1);\n      if (pop.size > 0) {\n        ts_assert(pop.size == 1);\n        ts_stack_renumber_version(self, array_get(&pop, 0)->version, version);\n        return array_get(&pop, 0)->subtrees;\n      }\n      break;\n    }\n  }\n  return (SubtreeArray) {.size = 0};\n}\n\nforceinline StackAction pop_all_callback(void *payload, const StackIterator *iterator) {\n  (void)payload;\n  return iterator->node->link_count == 0 ? StackActionPop : StackActionNone;\n}\n\nStackSliceArray ts_stack_pop_all(Stack *self, StackVersion version) {\n  return stack__iter(self, version, pop_all_callback, NULL, 0);\n}\n\ntypedef struct {\n  StackSummary *summary;\n  unsigned max_depth;\n} SummarizeStackSession;\n\nforceinline StackAction summarize_stack_callback(void *payload, const StackIterator *iterator) {\n  SummarizeStackSession *session = payload;\n  TSStateId state = iterator->node->state;\n  unsigned depth = iterator->subtree_count;\n  if (depth > session->max_depth) return StackActionStop;\n  for (unsigned i = session->summary->size - 1; i + 1 > 0; i--) {\n    StackSummaryEntry entry = *array_get(session->summary, i);\n    if (entry.depth < depth) break;\n    if (entry.depth == depth && entry.state == state) return StackActionNone;\n  }\n  array_push(session->summary, ((StackSummaryEntry) {\n    .position = iterator->node->position,\n    .depth = depth,\n    .state = state,\n  }));\n  return StackActionNone;\n}\n\nvoid ts_stack_record_summary(Stack *self, StackVersion version, unsigned max_depth) {\n  SummarizeStackSession session = {\n    .summary = ts_malloc(sizeof(StackSummary)),\n    .max_depth = max_depth\n  };\n  array_init(session.summary);\n  stack__iter(self, version, summarize_stack_callback, &session, -1);\n  StackHead *head = array_get(&self->heads, version);\n  if (head->summary) {\n    array_delete(head->summary);\n    ts_free(head->summary);\n  }\n  head->summary = session.summary;\n}\n\nStackSummary *ts_stack_get_summary(Stack *self, StackVersion version) {\n  return array_get(&self->heads, version)->summary;\n}\n\nint ts_stack_dynamic_precedence(Stack *self, StackVersion version) {\n  return array_get(&self->heads, version)->node->dynamic_precedence;\n}\n\nbool ts_stack_has_advanced_since_error(const Stack *self, StackVersion version) {\n  const StackHead *head = array_get(&self->heads, version);\n  const StackNode *node = head->node;\n  if (node->error_cost == 0) return true;\n  while (node) {\n    if (node->link_count > 0) {\n      Subtree subtree = node->links[0].subtree;\n      if (subtree.ptr) {\n        if (ts_subtree_total_bytes(subtree) > 0) {\n          return true;\n        } else if (\n          node->node_count > head->node_count_at_last_error &&\n          ts_subtree_error_cost(subtree) == 0\n        ) {\n          node = node->links[0].node;\n          continue;\n        }\n      }\n    }\n    break;\n  }\n  return false;\n}\n\nvoid ts_stack_remove_version(Stack *self, StackVersion version) {\n  stack_head_delete(array_get(&self->heads, version), &self->node_pool, self->subtree_pool);\n  array_erase(&self->heads, version);\n}\n\nvoid ts_stack_renumber_version(Stack *self, StackVersion v1, StackVersion v2) {\n  if (v1 == v2) return;\n  ts_assert(v2 < v1);\n  ts_assert((uint32_t)v1 < self->heads.size);\n  StackHead *source_head = array_get(&self->heads, v1);\n  StackHead *target_head = array_get(&self->heads, v2);\n  if (target_head->summary && !source_head->summary) {\n    source_head->summary = target_head->summary;\n    target_head->summary = NULL;\n  }\n  stack_head_delete(target_head, &self->node_pool, self->subtree_pool);\n  *target_head = *source_head;\n  array_erase(&self->heads, v1);\n}\n\nvoid ts_stack_swap_versions(Stack *self, StackVersion v1, StackVersion v2) {\n  StackHead temporary_head = *array_get(&self->heads, v1);\n  *array_get(&self->heads, v1) = *array_get(&self->heads, v2);\n  *array_get(&self->heads, v2) = temporary_head;\n}\n\nStackVersion ts_stack_copy_version(Stack *self, StackVersion version) {\n  ts_assert(version < self->heads.size);\n  StackHead version_head = *array_get(&self->heads, version);\n  array_push(&self->heads, version_head);\n  StackHead *head = array_back(&self->heads);\n  stack_node_retain(head->node);\n  if (head->last_external_token.ptr) ts_subtree_retain(head->last_external_token);\n  head->summary = NULL;\n  return self->heads.size - 1;\n}\n\nbool ts_stack_merge(Stack *self, StackVersion version1, StackVersion version2) {\n  if (!ts_stack_can_merge(self, version1, version2)) return false;\n  StackHead *head1 = array_get(&self->heads, version1);\n  StackHead *head2 = array_get(&self->heads, version2);\n  for (uint32_t i = 0; i < head2->node->link_count; i++) {\n    stack_node_add_link(head1->node, head2->node->links[i], self->subtree_pool);\n  }\n  if (head1->node->state == ERROR_STATE) {\n    head1->node_count_at_last_error = head1->node->node_count;\n  }\n  ts_stack_remove_version(self, version2);\n  return true;\n}\n\nbool ts_stack_can_merge(Stack *self, StackVersion version1, StackVersion version2) {\n  StackHead *head1 = array_get(&self->heads, version1);\n  StackHead *head2 = array_get(&self->heads, version2);\n  return\n    head1->status == StackStatusActive &&\n    head2->status == StackStatusActive &&\n    head1->node->state == head2->node->state &&\n    head1->node->position.bytes == head2->node->position.bytes &&\n    head1->node->error_cost == head2->node->error_cost &&\n    ts_subtree_external_scanner_state_eq(head1->last_external_token, head2->last_external_token);\n}\n\nvoid ts_stack_halt(Stack *self, StackVersion version) {\n  array_get(&self->heads, version)->status = StackStatusHalted;\n}\n\nvoid ts_stack_pause(Stack *self, StackVersion version, Subtree lookahead) {\n  StackHead *head = array_get(&self->heads, version);\n  head->status = StackStatusPaused;\n  head->lookahead_when_paused = lookahead;\n  head->node_count_at_last_error = head->node->node_count;\n}\n\nbool ts_stack_is_active(const Stack *self, StackVersion version) {\n  return array_get(&self->heads, version)->status == StackStatusActive;\n}\n\nbool ts_stack_is_halted(const Stack *self, StackVersion version) {\n  return array_get(&self->heads, version)->status == StackStatusHalted;\n}\n\nbool ts_stack_is_paused(const Stack *self, StackVersion version) {\n  return array_get(&self->heads, version)->status == StackStatusPaused;\n}\n\nSubtree ts_stack_resume(Stack *self, StackVersion version) {\n  StackHead *head = array_get(&self->heads, version);\n  ts_assert(head->status == StackStatusPaused);\n  Subtree result = head->lookahead_when_paused;\n  head->status = StackStatusActive;\n  head->lookahead_when_paused = NULL_SUBTREE;\n  return result;\n}\n\nvoid ts_stack_clear(Stack *self) {\n  stack_node_retain(self->base_node);\n  for (uint32_t i = 0; i < self->heads.size; i++) {\n    stack_head_delete(array_get(&self->heads, i), &self->node_pool, self->subtree_pool);\n  }\n  array_clear(&self->heads);\n  array_push(&self->heads, ((StackHead) {\n    .node = self->base_node,\n    .status = StackStatusActive,\n    .last_external_token = NULL_SUBTREE,\n    .lookahead_when_paused = NULL_SUBTREE,\n  }));\n}\n\nbool ts_stack_print_dot_graph(Stack *self, const TSLanguage *language, FILE *f) {\n  array_reserve(&self->iterators, 32);\n  if (!f) f = stderr;\n\n  fprintf(f, \"digraph stack {\\n\");\n  fprintf(f, \"rankdir=\\\"RL\\\";\\n\");\n  fprintf(f, \"edge [arrowhead=none]\\n\");\n\n  Array(StackNode *) visited_nodes = array_new();\n\n  array_clear(&self->iterators);\n  for (uint32_t i = 0; i < self->heads.size; i++) {\n    StackHead *head = array_get(&self->heads, i);\n    if (head->status == StackStatusHalted) continue;\n\n    fprintf(f, \"node_head_%u [shape=none, label=\\\"\\\"]\\n\", i);\n    fprintf(f, \"node_head_%u -> node_%p [\", i, (void *)head->node);\n\n    if (head->status == StackStatusPaused) {\n      fprintf(f, \"color=red \");\n    }\n    fprintf(f,\n      \"label=%u, fontcolor=blue, weight=10000, labeltooltip=\\\"node_count: %u\\nerror_cost: %u\",\n      i,\n      ts_stack_node_count_since_error(self, i),\n      ts_stack_error_cost(self, i)\n    );\n\n    if (head->summary) {\n      fprintf(f, \"\\nsummary:\");\n      for (uint32_t j = 0; j < head->summary->size; j++) fprintf(f, \" %u\", array_get(head->summary, j)->state);\n    }\n\n    if (head->last_external_token.ptr) {\n      const ExternalScannerState *state = &head->last_external_token.ptr->external_scanner_state;\n      const char *data = ts_external_scanner_state_data(state);\n      fprintf(f, \"\\nexternal_scanner_state:\");\n      for (uint32_t j = 0; j < state->length; j++) fprintf(f, \" %2X\", data[j]);\n    }\n\n    fprintf(f, \"\\\"]\\n\");\n    array_push(&self->iterators, ((StackIterator) {\n      .node = head->node\n    }));\n  }\n\n  bool all_iterators_done = false;\n  while (!all_iterators_done) {\n    all_iterators_done = true;\n\n    for (uint32_t i = 0; i < self->iterators.size; i++) {\n      StackIterator iterator = *array_get(&self->iterators, i);\n      StackNode *node = iterator.node;\n\n      for (uint32_t j = 0; j < visited_nodes.size; j++) {\n        if (*array_get(&visited_nodes, j) == node) {\n          node = NULL;\n          break;\n        }\n      }\n\n      if (!node) continue;\n      all_iterators_done = false;\n\n      fprintf(f, \"node_%p [\", (void *)node);\n      if (node->state == ERROR_STATE) {\n        fprintf(f, \"label=\\\"?\\\"\");\n      } else if (\n        node->link_count == 1 &&\n        node->links[0].subtree.ptr &&\n        ts_subtree_extra(node->links[0].subtree)\n      ) {\n        fprintf(f, \"shape=point margin=0 label=\\\"\\\"\");\n      } else {\n        fprintf(f, \"label=\\\"%d\\\"\", node->state);\n      }\n\n      fprintf(\n        f,\n        \" tooltip=\\\"position: %u,%u\\nnode_count:%u\\nerror_cost: %u\\ndynamic_precedence: %d\\\"];\\n\",\n        node->position.extent.row + 1,\n        node->position.extent.column,\n        node->node_count,\n        node->error_cost,\n        node->dynamic_precedence\n      );\n\n      for (int j = 0; j < node->link_count; j++) {\n        StackLink link = node->links[j];\n        fprintf(f, \"node_%p -> node_%p [\", (void *)node, (void *)link.node);\n        if (link.is_pending) fprintf(f, \"style=dashed \");\n        if (link.subtree.ptr && ts_subtree_extra(link.subtree)) fprintf(f, \"fontcolor=gray \");\n\n        if (!link.subtree.ptr) {\n          fprintf(f, \"color=red\");\n        } else {\n          fprintf(f, \"label=\\\"\");\n          bool quoted = ts_subtree_visible(link.subtree) && !ts_subtree_named(link.subtree);\n          if (quoted) fprintf(f, \"'\");\n          ts_language_write_symbol_as_dot_string(language, f, ts_subtree_symbol(link.subtree));\n          if (quoted) fprintf(f, \"'\");\n          fprintf(f, \"\\\"\");\n          fprintf(\n            f,\n            \"labeltooltip=\\\"error_cost: %u\\ndynamic_precedence: %\" PRId32 \"\\\"\",\n            ts_subtree_error_cost(link.subtree),\n            ts_subtree_dynamic_precedence(link.subtree)\n          );\n        }\n\n        fprintf(f, \"];\\n\");\n\n        StackIterator *next_iterator;\n        if (j == 0) {\n          next_iterator = array_get(&self->iterators, i);\n        } else {\n          array_push(&self->iterators, iterator);\n          next_iterator = array_back(&self->iterators);\n        }\n        next_iterator->node = link.node;\n      }\n\n      array_push(&visited_nodes, node);\n    }\n  }\n\n  fprintf(f, \"}\\n\");\n\n  array_delete(&visited_nodes);\n  return true;\n}\n\n#undef forceinline\n",
    "#include \"./subtree.h\"\n\ntypedef struct {\n  Subtree tree;\n  uint32_t child_index;\n  uint32_t byte_offset;\n} StackEntry;\n\ntypedef struct {\n  Array(StackEntry) stack;\n  Subtree last_external_token;\n} ReusableNode;\n\nstatic inline ReusableNode reusable_node_new(void) {\n  return (ReusableNode) {array_new(), NULL_SUBTREE};\n}\n\nstatic inline void reusable_node_clear(ReusableNode *self) {\n  array_clear(&self->stack);\n  self->last_external_token = NULL_SUBTREE;\n}\n\nstatic inline Subtree reusable_node_tree(ReusableNode *self) {\n  return self->stack.size > 0\n    ? self->stack.contents[self->stack.size - 1].tree\n    : NULL_SUBTREE;\n}\n\nstatic inline uint32_t reusable_node_byte_offset(ReusableNode *self) {\n  return self->stack.size > 0\n    ? self->stack.contents[self->stack.size - 1].byte_offset\n    : UINT32_MAX;\n}\n\nstatic inline void reusable_node_delete(ReusableNode *self) {\n  array_delete(&self->stack);\n}\n\nstatic inline void reusable_node_advance(ReusableNode *self) {\n  StackEntry last_entry = *array_back(&self->stack);\n  uint32_t byte_offset = last_entry.byte_offset + ts_subtree_total_bytes(last_entry.tree);\n  if (ts_subtree_has_external_tokens(last_entry.tree)) {\n    self->last_external_token = ts_subtree_last_external_token(last_entry.tree);\n  }\n\n  Subtree tree;\n  uint32_t next_index;\n  do {\n    StackEntry popped_entry = array_pop(&self->stack);\n    next_index = popped_entry.child_index + 1;\n    if (self->stack.size == 0) return;\n    tree = array_back(&self->stack)->tree;\n  } while (ts_subtree_child_count(tree) <= next_index);\n\n  array_push(&self->stack, ((StackEntry) {\n    .tree = ts_subtree_children(tree)[next_index],\n    .child_index = next_index,\n    .byte_offset = byte_offset,\n  }));\n}\n\nstatic inline bool reusable_node_descend(ReusableNode *self) {\n  StackEntry last_entry = *array_back(&self->stack);\n  if (ts_subtree_child_count(last_entry.tree) > 0) {\n    array_push(&self->stack, ((StackEntry) {\n      .tree = ts_subtree_children(last_entry.tree)[0],\n      .child_index = 0,\n      .byte_offset = last_entry.byte_offset,\n    }));\n    return true;\n  } else {\n    return false;\n  }\n}\n\nstatic inline void reusable_node_advance_past_leaf(ReusableNode *self) {\n  while (reusable_node_descend(self)) {}\n  reusable_node_advance(self);\n}\n\nstatic inline void reusable_node_reset(ReusableNode *self, Subtree tree) {\n  reusable_node_clear(self);\n  array_push(&self->stack, ((StackEntry) {\n    .tree = tree,\n    .child_index = 0,\n    .byte_offset = 0,\n  }));\n\n  // Never reuse the root node, because it has a non-standard internal structure\n  // due to transformations that are applied when it is accepted: adding the EOF\n  // child and any extra children.\n  if (!reusable_node_descend(self)) {\n    reusable_node_clear(self);\n  }\n}\n",
    "#ifndef TREE_SITTER_ATOMIC_H_\n#define TREE_SITTER_ATOMIC_H_\n\n#include <stddef.h>\n#include <stdint.h>\n#include <stdlib.h>\n\n#ifdef __TINYC__\n\nstatic inline size_t atomic_load(const volatile size_t *p) {\n  return *p;\n}\n\nstatic inline uint32_t atomic_inc(volatile uint32_t *p) {\n  *p += 1;\n  return *p;\n}\n\nstatic inline uint32_t atomic_dec(volatile uint32_t *p) {\n  *p-= 1;\n  return *p;\n}\n\n#elif defined(_WIN32)\n\n#include <windows.h>\n\nstatic inline size_t atomic_load(const volatile size_t *p) {\n  return *p;\n}\n\nstatic inline uint32_t atomic_inc(volatile uint32_t *p) {\n  return InterlockedIncrement((long volatile *)p);\n}\n\nstatic inline uint32_t atomic_dec(volatile uint32_t *p) {\n  return InterlockedDecrement((long volatile *)p);\n}\n\n#else\n\nstatic inline size_t atomic_load(const volatile size_t *p) {\n#ifdef __ATOMIC_RELAXED\n  return __atomic_load_n(p, __ATOMIC_RELAXED);\n#else\n  return __sync_fetch_and_add((volatile size_t *)p, 0);\n#endif\n}\n\nstatic inline uint32_t atomic_inc(volatile uint32_t *p) {\n  #ifdef __ATOMIC_RELAXED\n    return __atomic_add_fetch(p, 1U, __ATOMIC_SEQ_CST);\n  #else\n    return __sync_add_and_fetch(p, 1U);\n  #endif\n}\n\nstatic inline uint32_t atomic_dec(volatile uint32_t *p) {\n  #ifdef __ATOMIC_RELAXED\n    return __atomic_sub_fetch(p, 1U, __ATOMIC_SEQ_CST);\n  #else\n    return __sync_sub_and_fetch(p, 1U);\n  #endif\n}\n\n#endif\n\n#endif  // TREE_SITTER_ATOMIC_H_\n",
    "/*\n * On NetBSD, defining standard requirements like this removes symbols\n * from the namespace; however, we need non-standard symbols for\n * endian.h.\n */\n#if defined(__NetBSD__) && defined(_POSIX_C_SOURCE)\n#undef _POSIX_C_SOURCE\n#endif\n\n#include \"tree_sitter/api.h\"\n#include \"./alloc.h\"\n#include \"./array.h\"\n#include \"./language.h\"\n#include \"./point.h\"\n#include \"./tree_cursor.h\"\n#include \"./unicode.h\"\n#include <wctype.h>\n\n// #define DEBUG_ANALYZE_QUERY\n// #define DEBUG_EXECUTE_QUERY\n\n#define MAX_STEP_CAPTURE_COUNT 3\n#define MAX_NEGATED_FIELD_COUNT 8\n#define MAX_STATE_PREDECESSOR_COUNT 256\n#define MAX_ANALYSIS_STATE_DEPTH 8\n#define MAX_ANALYSIS_ITERATION_COUNT 256\n\n/*\n * Stream - A sequence of unicode characters derived from a UTF8 string.\n * This struct is used in parsing queries from S-expressions.\n */\ntypedef struct {\n  const char *input;\n  const char *start;\n  const char *end;\n  int32_t next;\n  uint8_t next_size;\n} Stream;\n\n/*\n * QueryStep - A step in the process of matching a query. Each node within\n * a query S-expression corresponds to one of these steps. An entire pattern\n * is represented as a sequence of these steps. The basic properties of a\n * node are represented by these fields:\n * - `symbol` - The grammar symbol to match. A zero value represents the\n *    wildcard symbol, '_'.\n * - `field` - The field name to match. A zero value means that a field name\n *    was not specified.\n * - `capture_ids` - An array of integers representing the names of captures\n *    associated with this node in the pattern, terminated by a `NONE` value.\n * - `depth` - The depth where this node occurs in the pattern. The root node\n *    of the pattern has depth zero.\n * - `negated_field_list_id` - An id representing a set of fields that must\n *    not be present on a node matching this step.\n *\n * Steps have some additional fields in order to handle the `.` (or \"anchor\") operator,\n * which forbids additional child nodes:\n * - `is_immediate` - Indicates that the node matching this step cannot be preceded\n *   by other sibling nodes that weren't specified in the pattern.\n * - `is_last_child` - Indicates that the node matching this step cannot have any\n *   subsequent named siblings.\n *\n * For simple patterns, steps are matched in sequential order. But in order to\n * handle alternative/repeated/optional sub-patterns, query steps are not always\n * structured as a linear sequence; they sometimes need to split and merge. This\n * is done using the following fields:\n *  - `alternative_index` - The index of a different query step that serves as\n *    an alternative to this step. A `NONE` value represents no alternative.\n *    When a query state reaches a step with an alternative index, the state\n *    is duplicated, with one copy remaining at the original step, and one copy\n *    moving to the alternative step. The alternative may have its own alternative\n *    step, so this splitting is an iterative process.\n * - `is_dead_end` - Indicates that this state cannot be passed directly, and\n *    exists only in order to redirect to an alternative index, with no splitting.\n * - `is_pass_through` - Indicates that state has no matching logic of its own,\n *    and exists only to split a state. One copy of the state advances immediately\n *    to the next step, and one moves to the alternative step.\n * - `alternative_is_immediate` - Indicates that this step's alternative step\n *    should be treated as if `is_immediate` is true.\n *\n * Steps also store some derived state that summarizes how they relate to other\n * steps within the same pattern. This is used to optimize the matching process:\n *  - `contains_captures` - Indicates that this step or one of its child steps\n *     has a non-empty `capture_ids` list.\n *  - `parent_pattern_guaranteed` - Indicates that if this step is reached, then\n *     it and all of its subsequent sibling steps within the same parent pattern\n *     are guaranteed to match.\n *  - `root_pattern_guaranteed` - Similar to `parent_pattern_guaranteed`, but\n *     for the entire top-level pattern. When iterating through a query's\n *     captures using `ts_query_cursor_next_capture`, this field is used to\n *     detect that a capture can safely be returned from a match that has not\n *     even completed yet.\n */\ntypedef struct {\n  TSSymbol symbol;\n  TSSymbol supertype_symbol;\n  TSFieldId field;\n  uint16_t capture_ids[MAX_STEP_CAPTURE_COUNT];\n  uint16_t depth;\n  uint16_t alternative_index;\n  uint16_t negated_field_list_id;\n  bool is_named: 1;\n  bool is_immediate: 1;\n  bool is_last_child: 1;\n  bool is_pass_through: 1;\n  bool is_dead_end: 1;\n  bool alternative_is_immediate: 1;\n  bool contains_captures: 1;\n  bool root_pattern_guaranteed: 1;\n  bool parent_pattern_guaranteed: 1;\n  bool is_missing: 1;\n} QueryStep;\n\n/*\n * Slice - A slice of an external array. Within a query, capture names,\n * literal string values, and predicate step information are stored in three\n * contiguous arrays. Individual captures, string values, and predicates are\n * represented as slices of these three arrays.\n */\ntypedef struct {\n  uint32_t offset;\n  uint32_t length;\n} Slice;\n\n/*\n * SymbolTable - a two-way mapping of strings to ids.\n */\ntypedef struct {\n  Array(char) characters;\n  Array(Slice) slices;\n} SymbolTable;\n\n/**\n * CaptureQuantifiers - a data structure holding the quantifiers of pattern captures.\n */\ntypedef Array(uint8_t) CaptureQuantifiers;\n\n/*\n * PatternEntry - Information about the starting point for matching a particular\n * pattern. These entries are stored in a 'pattern map' - a sorted array that\n * makes it possible to efficiently lookup patterns based on the symbol for their\n * first step. The entry consists of the following fields:\n * - `pattern_index` - the index of the pattern within the query\n * - `step_index` - the index of the pattern's first step in the shared `steps` array\n * - `is_rooted` - whether or not the pattern has a single root node. This property\n *   affects decisions about whether or not to start the pattern for nodes outside\n *   of a QueryCursor's range restriction.\n */\ntypedef struct {\n  uint16_t step_index;\n  uint16_t pattern_index;\n  bool is_rooted;\n} PatternEntry;\n\ntypedef struct {\n  Slice steps;\n  Slice predicate_steps;\n  uint32_t start_byte;\n  uint32_t end_byte;\n  bool is_non_local;\n} QueryPattern;\n\ntypedef struct {\n  uint32_t byte_offset;\n  uint16_t step_index;\n} StepOffset;\n\n/*\n * QueryState - The state of an in-progress match of a particular pattern\n * in a query. While executing, a `TSQueryCursor` must keep track of a number\n * of possible in-progress matches. Each of those possible matches is\n * represented as one of these states. Fields:\n * - `id` - A numeric id that is exposed to the public API. This allows the\n *    caller to remove a given match, preventing any more of its captures\n *    from being returned.\n * - `start_depth` - The depth in the tree where the first step of the state's\n *    pattern was matched.\n * - `pattern_index` - The pattern that the state is matching.\n * - `consumed_capture_count` - The number of captures from this match that\n *    have already been returned.\n * - `capture_list_id` - A numeric id that can be used to retrieve the state's\n *    list of captures from the `CaptureListPool`.\n * - `seeking_immediate_match` - A flag that indicates that the state's next\n *    step must be matched by the very next sibling. This is used when\n *    processing repetitions, or when processing a wildcard node followed by\n *    an anchor.\n * - `has_in_progress_alternatives` - A flag that indicates that there is are\n *    other states that have the same captures as this state, but are at\n *    different steps in their pattern. This means that in order to obey the\n *    'longest-match' rule, this state should not be returned as a match until\n *    it is clear that there can be no other alternative match with more captures.\n */\ntypedef struct {\n  uint32_t id;\n  uint32_t capture_list_id;\n  uint16_t start_depth;\n  uint16_t step_index;\n  uint16_t pattern_index;\n  uint16_t consumed_capture_count: 12;\n  bool seeking_immediate_match: 1;\n  bool has_in_progress_alternatives: 1;\n  bool dead: 1;\n  bool needs_parent: 1;\n} QueryState;\n\ntypedef Array(TSQueryCapture) CaptureList;\n\n/*\n * CaptureListPool - A collection of *lists* of captures. Each query state needs\n * to maintain its own list of captures. To avoid repeated allocations, this struct\n * maintains a fixed set of capture lists, and keeps track of which ones are\n * currently in use by a query state.\n */\ntypedef struct {\n  Array(CaptureList) list;\n  CaptureList empty_list;\n  // The maximum number of capture lists that we are allowed to allocate. We\n  // never allow `list` to allocate more entries than this, dropping pending\n  // matches if needed to stay under the limit.\n  uint32_t max_capture_list_count;\n  // The number of capture lists allocated in `list` that are not currently in\n  // use. We reuse those existing-but-unused capture lists before trying to\n  // allocate any new ones. We use an invalid value (UINT32_MAX) for a capture\n  // list's length to indicate that it's not in use.\n  uint32_t free_capture_list_count;\n} CaptureListPool;\n\n/*\n * AnalysisState - The state needed for walking the parse table when analyzing\n * a query pattern, to determine at which steps the pattern might fail to match.\n */\ntypedef struct {\n  TSStateId parse_state;\n  TSSymbol parent_symbol;\n  uint16_t child_index;\n  TSFieldId field_id: 15;\n  bool done: 1;\n} AnalysisStateEntry;\n\ntypedef struct {\n  AnalysisStateEntry stack[MAX_ANALYSIS_STATE_DEPTH];\n  uint16_t depth;\n  uint16_t step_index;\n  TSSymbol root_symbol;\n} AnalysisState;\n\ntypedef Array(AnalysisState *) AnalysisStateSet;\n\ntypedef struct {\n  AnalysisStateSet states;\n  AnalysisStateSet next_states;\n  AnalysisStateSet deeper_states;\n  AnalysisStateSet state_pool;\n  Array(uint16_t) final_step_indices;\n  Array(TSSymbol) finished_parent_symbols;\n  bool did_abort;\n} QueryAnalysis;\n\n/*\n * AnalysisSubgraph - A subset of the states in the parse table that are used\n * in constructing nodes with a certain symbol. Each state is accompanied by\n * some information about the possible node that could be produced in\n * downstream states.\n */\ntypedef struct {\n  TSStateId state;\n  uint16_t production_id;\n  uint8_t child_index: 7;\n  bool done: 1;\n} AnalysisSubgraphNode;\n\ntypedef struct {\n  TSSymbol symbol;\n  Array(TSStateId) start_states;\n  Array(AnalysisSubgraphNode) nodes;\n} AnalysisSubgraph;\n\ntypedef Array(AnalysisSubgraph) AnalysisSubgraphArray;\n\n/*\n * StatePredecessorMap - A map that stores the predecessors of each parse state.\n * This is used during query analysis to determine which parse states can lead\n * to which reduce actions.\n */\ntypedef struct {\n  TSStateId *contents;\n} StatePredecessorMap;\n\n/*\n * TSQuery - A tree query, compiled from a string of S-expressions. The query\n * itself is immutable. The mutable state used in the process of executing the\n * query is stored in a `TSQueryCursor`.\n */\nstruct TSQuery {\n  SymbolTable captures;\n  SymbolTable predicate_values;\n  Array(CaptureQuantifiers) capture_quantifiers;\n  Array(QueryStep) steps;\n  Array(PatternEntry) pattern_map;\n  Array(TSQueryPredicateStep) predicate_steps;\n  Array(QueryPattern) patterns;\n  Array(StepOffset) step_offsets;\n  Array(TSFieldId) negated_fields;\n  Array(char) string_buffer;\n  Array(TSSymbol) repeat_symbols_with_rootless_patterns;\n  const TSLanguage *language;\n  uint16_t wildcard_root_pattern_count;\n};\n\n/*\n * TSQueryCursor - A stateful struct used to execute a query on a tree.\n */\nstruct TSQueryCursor {\n  const TSQuery *query;\n  TSTreeCursor cursor;\n  Array(QueryState) states;\n  Array(QueryState) finished_states;\n  CaptureListPool capture_list_pool;\n  uint32_t depth;\n  uint32_t max_start_depth;\n  TSRange included_range;\n  TSRange containing_range;\n  uint32_t next_state_id;\n  const TSQueryCursorOptions *query_options;\n  TSQueryCursorState query_state;\n  unsigned operation_count;\n  bool on_visible_node;\n  bool ascending;\n  bool halted;\n  bool did_exceed_match_limit;\n};\n\nstatic const TSQueryError PARENT_DONE = -1;\nstatic const uint16_t PATTERN_DONE_MARKER = UINT16_MAX;\nstatic const uint16_t NONE = UINT16_MAX;\nstatic const TSSymbol WILDCARD_SYMBOL = 0;\nstatic const unsigned OP_COUNT_PER_QUERY_CALLBACK_CHECK = 100;\n\n/**********\n * Stream\n **********/\n\n// Advance to the next unicode code point in the stream.\nstatic bool stream_advance(Stream *self) {\n  self->input += self->next_size;\n  if (self->input < self->end) {\n    uint32_t size = ts_decode_utf8(\n      (const uint8_t *)self->input,\n      (uint32_t)(self->end - self->input),\n      &self->next\n    );\n    if (size > 0) {\n      self->next_size = size;\n      return true;\n    }\n  } else {\n    self->next_size = 0;\n    self->next = '\\0';\n  }\n  return false;\n}\n\n// Reset the stream to the given input position, represented as a pointer\n// into the input string.\nstatic void stream_reset(Stream *self, const char *input) {\n  self->input = input;\n  self->next_size = 0;\n  stream_advance(self);\n}\n\nstatic Stream stream_new(const char *string, uint32_t length) {\n  Stream self = {\n    .next = 0,\n    .input = string,\n    .start = string,\n    .end = string + length,\n  };\n  stream_advance(&self);\n  return self;\n}\n\nstatic void stream_skip_whitespace(Stream *self) {\n  for (;;) {\n    if (iswspace(self->next)) {\n      stream_advance(self);\n    } else if (self->next == ';') {\n      // skip over comments\n      stream_advance(self);\n      while (self->next && self->next != '\\n') {\n        if (!stream_advance(self)) break;\n      }\n    } else {\n      break;\n    }\n  }\n}\n\nstatic bool stream_is_ident_start(Stream *self) {\n  return iswalnum(self->next) || self->next == '_' || self->next == '-';\n}\n\nstatic void stream_scan_identifier(Stream *stream) {\n  do {\n    stream_advance(stream);\n  } while (\n    iswalnum(stream->next) ||\n    stream->next == '_' ||\n    stream->next == '-' ||\n    stream->next == '.'\n  );\n}\n\nstatic uint32_t stream_offset(Stream *self) {\n  return (uint32_t)(self->input - self->start);\n}\n\n/******************\n * CaptureListPool\n ******************/\n\nstatic CaptureListPool capture_list_pool_new(void) {\n  return (CaptureListPool) {\n    .list = array_new(),\n    .empty_list = array_new(),\n    .max_capture_list_count = UINT32_MAX,\n    .free_capture_list_count = 0,\n  };\n}\n\nstatic void capture_list_pool_reset(CaptureListPool *self) {\n  for (uint16_t i = 0; i < (uint16_t)self->list.size; i++) {\n    // This invalid size means that the list is not in use.\n    array_get(&self->list, i)->size = UINT32_MAX;\n  }\n  self->free_capture_list_count = self->list.size;\n}\n\nstatic void capture_list_pool_delete(CaptureListPool *self) {\n  for (uint16_t i = 0; i < (uint16_t)self->list.size; i++) {\n    array_delete(array_get(&self->list, i));\n  }\n  array_delete(&self->list);\n}\n\nstatic const CaptureList *capture_list_pool_get(const CaptureListPool *self, uint16_t id) {\n  if (id >= self->list.size) return &self->empty_list;\n  return array_get(&self->list, id);\n}\n\nstatic CaptureList *capture_list_pool_get_mut(CaptureListPool *self, uint16_t id) {\n  ts_assert(id < self->list.size);\n  return array_get(&self->list, id);\n}\n\nstatic bool capture_list_pool_is_empty(const CaptureListPool *self) {\n  // The capture list pool is empty if all allocated lists are in use, and we\n  // have reached the maximum allowed number of allocated lists.\n  return self->free_capture_list_count == 0 && self->list.size >= self->max_capture_list_count;\n}\n\nstatic uint16_t capture_list_pool_acquire(CaptureListPool *self) {\n  // First see if any already allocated capture list is currently unused.\n  if (self->free_capture_list_count > 0) {\n    for (uint16_t i = 0; i < (uint16_t)self->list.size; i++) {\n      if (array_get(&self->list, i)->size == UINT32_MAX) {\n        array_clear(array_get(&self->list, i));\n        self->free_capture_list_count--;\n        return i;\n      }\n    }\n  }\n\n  // Otherwise allocate and initialize a new capture list, as long as that\n  // doesn't put us over the requested maximum.\n  uint32_t i = self->list.size;\n  if (i >= self->max_capture_list_count) {\n    return NONE;\n  }\n  CaptureList list;\n  array_init(&list);\n  array_push(&self->list, list);\n  return i;\n}\n\nstatic void capture_list_pool_release(CaptureListPool *self, uint16_t id) {\n  if (id >= self->list.size) return;\n  array_get(&self->list, id)->size = UINT32_MAX;\n  self->free_capture_list_count++;\n}\n\n/**************\n * Quantifiers\n **************/\n\nstatic TSQuantifier quantifier_mul(\n  TSQuantifier left,\n  TSQuantifier right\n) {\n  switch (left)\n  {\n    case TSQuantifierZero:\n      return TSQuantifierZero;\n    case TSQuantifierZeroOrOne:\n      switch (right) {\n        case TSQuantifierZero:\n          return TSQuantifierZero;\n        case TSQuantifierZeroOrOne:\n        case TSQuantifierOne:\n          return TSQuantifierZeroOrOne;\n        case TSQuantifierZeroOrMore:\n        case TSQuantifierOneOrMore:\n          return TSQuantifierZeroOrMore;\n      };\n      break;\n    case TSQuantifierZeroOrMore:\n      switch (right) {\n        case TSQuantifierZero:\n          return TSQuantifierZero;\n        case TSQuantifierZeroOrOne:\n        case TSQuantifierZeroOrMore:\n        case TSQuantifierOne:\n        case TSQuantifierOneOrMore:\n          return TSQuantifierZeroOrMore;\n      };\n      break;\n    case TSQuantifierOne:\n      return right;\n    case TSQuantifierOneOrMore:\n      switch (right) {\n        case TSQuantifierZero:\n          return TSQuantifierZero;\n        case TSQuantifierZeroOrOne:\n        case TSQuantifierZeroOrMore:\n          return TSQuantifierZeroOrMore;\n        case TSQuantifierOne:\n        case TSQuantifierOneOrMore:\n          return TSQuantifierOneOrMore;\n      };\n      break;\n  }\n  return TSQuantifierZero; // to make compiler happy, but all cases should be covered above!\n}\n\nstatic TSQuantifier quantifier_join(\n  TSQuantifier left,\n  TSQuantifier right\n) {\n  switch (left)\n  {\n    case TSQuantifierZero:\n      switch (right) {\n        case TSQuantifierZero:\n          return TSQuantifierZero;\n        case TSQuantifierZeroOrOne:\n        case TSQuantifierOne:\n          return TSQuantifierZeroOrOne;\n        case TSQuantifierZeroOrMore:\n        case TSQuantifierOneOrMore:\n          return TSQuantifierZeroOrMore;\n      };\n      break;\n    case TSQuantifierZeroOrOne:\n      switch (right) {\n        case TSQuantifierZero:\n        case TSQuantifierZeroOrOne:\n        case TSQuantifierOne:\n          return TSQuantifierZeroOrOne;\n          break;\n        case TSQuantifierZeroOrMore:\n        case TSQuantifierOneOrMore:\n          return TSQuantifierZeroOrMore;\n          break;\n      };\n      break;\n    case TSQuantifierZeroOrMore:\n      return TSQuantifierZeroOrMore;\n    case TSQuantifierOne:\n      switch (right) {\n        case TSQuantifierZero:\n        case TSQuantifierZeroOrOne:\n          return TSQuantifierZeroOrOne;\n        case TSQuantifierZeroOrMore:\n          return TSQuantifierZeroOrMore;\n        case TSQuantifierOne:\n          return TSQuantifierOne;\n        case TSQuantifierOneOrMore:\n          return TSQuantifierOneOrMore;\n      };\n      break;\n    case TSQuantifierOneOrMore:\n      switch (right) {\n        case TSQuantifierZero:\n        case TSQuantifierZeroOrOne:\n        case TSQuantifierZeroOrMore:\n          return TSQuantifierZeroOrMore;\n        case TSQuantifierOne:\n        case TSQuantifierOneOrMore:\n          return TSQuantifierOneOrMore;\n      };\n      break;\n  }\n  return TSQuantifierZero; // to make compiler happy, but all cases should be covered above!\n}\n\nstatic TSQuantifier quantifier_add(\n  TSQuantifier left,\n  TSQuantifier right\n) {\n  switch (left)\n  {\n    case TSQuantifierZero:\n      return right;\n    case TSQuantifierZeroOrOne:\n      switch (right) {\n        case TSQuantifierZero:\n          return TSQuantifierZeroOrOne;\n        case TSQuantifierZeroOrOne:\n        case TSQuantifierZeroOrMore:\n          return TSQuantifierZeroOrMore;\n        case TSQuantifierOne:\n        case TSQuantifierOneOrMore:\n          return TSQuantifierOneOrMore;\n      };\n      break;\n    case TSQuantifierZeroOrMore:\n      switch (right) {\n        case TSQuantifierZero:\n          return TSQuantifierZeroOrMore;\n        case TSQuantifierZeroOrOne:\n        case TSQuantifierZeroOrMore:\n          return TSQuantifierZeroOrMore;\n        case TSQuantifierOne:\n        case TSQuantifierOneOrMore:\n          return TSQuantifierOneOrMore;\n      };\n      break;\n    case TSQuantifierOne:\n      switch (right) {\n        case TSQuantifierZero:\n          return TSQuantifierOne;\n        case TSQuantifierZeroOrOne:\n        case TSQuantifierZeroOrMore:\n        case TSQuantifierOne:\n        case TSQuantifierOneOrMore:\n          return TSQuantifierOneOrMore;\n      };\n      break;\n    case TSQuantifierOneOrMore:\n      return TSQuantifierOneOrMore;\n  }\n  return TSQuantifierZero; // to make compiler happy, but all cases should be covered above!\n}\n\n// Create new capture quantifiers structure\nstatic CaptureQuantifiers capture_quantifiers_new(void) {\n  return (CaptureQuantifiers) array_new();\n}\n\n// Delete capture quantifiers structure\nstatic void capture_quantifiers_delete(\n  CaptureQuantifiers *self\n) {\n  array_delete(self);\n}\n\n// Clear capture quantifiers structure\nstatic void capture_quantifiers_clear(\n  CaptureQuantifiers *self\n) {\n  array_clear(self);\n}\n\n// Replace capture quantifiers with the given quantifiers\nstatic void capture_quantifiers_replace(\n  CaptureQuantifiers *self,\n  CaptureQuantifiers *quantifiers\n) {\n  array_clear(self);\n  array_push_all(self, quantifiers);\n}\n\n// Return capture quantifier for the given capture id\nstatic TSQuantifier capture_quantifier_for_id(\n  const CaptureQuantifiers *self,\n  uint16_t id\n) {\n  return (self->size <= id) ? TSQuantifierZero : (TSQuantifier) *array_get(self, id);\n}\n\n// Add the given quantifier to the current value for id\nstatic void capture_quantifiers_add_for_id(\n  CaptureQuantifiers *self,\n  uint16_t id,\n  TSQuantifier quantifier\n) {\n  if (self->size <= id) {\n    array_grow_by(self, id + 1 - self->size);\n  }\n  uint8_t *own_quantifier = array_get(self, id);\n  *own_quantifier = (uint8_t) quantifier_add((TSQuantifier) *own_quantifier, quantifier);\n}\n\n// Point-wise add the given quantifiers to the current values\nstatic void capture_quantifiers_add_all(\n  CaptureQuantifiers *self,\n  CaptureQuantifiers *quantifiers\n) {\n  if (self->size < quantifiers->size) {\n    array_grow_by(self, quantifiers->size - self->size);\n  }\n  for (uint16_t id = 0; id < (uint16_t)quantifiers->size; id++) {\n    uint8_t *quantifier = array_get(quantifiers, id);\n    uint8_t *own_quantifier = array_get(self, id);\n    *own_quantifier = (uint8_t) quantifier_add((TSQuantifier) *own_quantifier, (TSQuantifier) *quantifier);\n  }\n}\n\n// Join the given quantifier with the current values\nstatic void capture_quantifiers_mul(\n  CaptureQuantifiers *self,\n  TSQuantifier quantifier\n) {\n  for (uint16_t id = 0; id < (uint16_t)self->size; id++) {\n    uint8_t *own_quantifier = array_get(self, id);\n    *own_quantifier = (uint8_t) quantifier_mul((TSQuantifier) *own_quantifier, quantifier);\n  }\n}\n\n// Point-wise join the quantifiers from a list of alternatives with the current values\nstatic void capture_quantifiers_join_all(\n  CaptureQuantifiers *self,\n  CaptureQuantifiers *quantifiers\n) {\n  if (self->size < quantifiers->size) {\n    array_grow_by(self, quantifiers->size - self->size);\n  }\n  for (uint32_t id = 0; id < quantifiers->size; id++) {\n    uint8_t *quantifier = array_get(quantifiers, id);\n    uint8_t *own_quantifier = array_get(self, id);\n    *own_quantifier = (uint8_t) quantifier_join((TSQuantifier) *own_quantifier, (TSQuantifier) *quantifier);\n  }\n  for (uint32_t id = quantifiers->size; id < self->size; id++) {\n    uint8_t *own_quantifier = array_get(self, id);\n    *own_quantifier = (uint8_t) quantifier_join((TSQuantifier) *own_quantifier, TSQuantifierZero);\n  }\n}\n\n/**************\n * SymbolTable\n **************/\n\nstatic SymbolTable symbol_table_new(void) {\n  return (SymbolTable) {\n    .characters = array_new(),\n    .slices = array_new(),\n  };\n}\n\nstatic void symbol_table_delete(SymbolTable *self) {\n  array_delete(&self->characters);\n  array_delete(&self->slices);\n}\n\nstatic int symbol_table_id_for_name(\n  const SymbolTable *self,\n  const char *name,\n  uint32_t length\n) {\n  for (unsigned i = 0; i < self->slices.size; i++) {\n    Slice slice = *array_get(&self->slices, i);\n    if (\n      slice.length == length &&\n      !strncmp(array_get(&self->characters, slice.offset), name, length)\n    ) return i;\n  }\n  return -1;\n}\n\nstatic const char *symbol_table_name_for_id(\n  const SymbolTable *self,\n  uint16_t id,\n  uint32_t *length\n) {\n  Slice slice = *(array_get(&self->slices,id));\n  *length = slice.length;\n  return array_get(&self->characters, slice.offset);\n}\n\nstatic uint16_t symbol_table_insert_name(\n  SymbolTable *self,\n  const char *name,\n  uint32_t length\n) {\n  int id = symbol_table_id_for_name(self, name, length);\n  if (id >= 0) return (uint16_t)id;\n  Slice slice = {\n    .offset = self->characters.size,\n    .length = length,\n  };\n  array_grow_by(&self->characters, length + 1);\n  memcpy(array_get(&self->characters, slice.offset), name, length);\n  *array_get(&self->characters, self->characters.size - 1) = 0;\n  array_push(&self->slices, slice);\n  return self->slices.size - 1;\n}\n\n/************\n * QueryStep\n ************/\n\nstatic QueryStep query_step__new(\n  TSSymbol symbol,\n  uint16_t depth,\n  bool is_immediate\n) {\n  QueryStep step = {\n    .symbol = symbol,\n    .depth = depth,\n    .field = 0,\n    .alternative_index = NONE,\n    .negated_field_list_id = 0,\n    .contains_captures = false,\n    .is_last_child = false,\n    .is_named = false,\n    .is_pass_through = false,\n    .is_dead_end = false,\n    .root_pattern_guaranteed = false,\n    .is_immediate = is_immediate,\n    .alternative_is_immediate = false,\n  };\n  for (unsigned i = 0; i < MAX_STEP_CAPTURE_COUNT; i++) {\n    step.capture_ids[i] = NONE;\n  }\n  return step;\n}\n\nstatic void query_step__add_capture(QueryStep *self, uint16_t capture_id) {\n  for (unsigned i = 0; i < MAX_STEP_CAPTURE_COUNT; i++) {\n    if (self->capture_ids[i] == NONE) {\n      self->capture_ids[i] = capture_id;\n      break;\n    }\n  }\n}\n\nstatic void query_step__remove_capture(QueryStep *self, uint16_t capture_id) {\n  for (unsigned i = 0; i < MAX_STEP_CAPTURE_COUNT; i++) {\n    if (self->capture_ids[i] == capture_id) {\n      self->capture_ids[i] = NONE;\n      while (i + 1 < MAX_STEP_CAPTURE_COUNT) {\n        if (self->capture_ids[i + 1] == NONE) break;\n        self->capture_ids[i] = self->capture_ids[i + 1];\n        self->capture_ids[i + 1] = NONE;\n        i++;\n      }\n      break;\n    }\n  }\n}\n\n/**********************\n * StatePredecessorMap\n **********************/\n\nstatic inline StatePredecessorMap state_predecessor_map_new(\n  const TSLanguage *language\n) {\n  return (StatePredecessorMap) {\n    .contents = ts_calloc(\n      (size_t)language->state_count * (MAX_STATE_PREDECESSOR_COUNT + 1),\n      sizeof(TSStateId)\n    ),\n  };\n}\n\nstatic inline void state_predecessor_map_delete(StatePredecessorMap *self) {\n  ts_free(self->contents);\n}\n\nstatic inline void state_predecessor_map_add(\n  StatePredecessorMap *self,\n  TSStateId state,\n  TSStateId predecessor\n) {\n  size_t index = (size_t)state * (MAX_STATE_PREDECESSOR_COUNT + 1);\n  TSStateId *count = &self->contents[index];\n  if (\n    *count == 0 ||\n    (*count < MAX_STATE_PREDECESSOR_COUNT && self->contents[index + *count] != predecessor)\n  ) {\n    (*count)++;\n    self->contents[index + *count] = predecessor;\n  }\n}\n\nstatic inline const TSStateId *state_predecessor_map_get(\n  const StatePredecessorMap *self,\n  TSStateId state,\n  unsigned *count\n) {\n  size_t index = (size_t)state * (MAX_STATE_PREDECESSOR_COUNT + 1);\n  *count = self->contents[index];\n  return &self->contents[index + 1];\n}\n\n/****************\n * AnalysisState\n ****************/\n\nstatic unsigned analysis_state__recursion_depth(const AnalysisState *self) {\n  unsigned result = 0;\n  for (unsigned i = 0; i < self->depth; i++) {\n    TSSymbol symbol = self->stack[i].parent_symbol;\n    for (unsigned j = 0; j < i; j++) {\n      if (self->stack[j].parent_symbol == symbol) {\n        result++;\n        break;\n      }\n    }\n  }\n  return result;\n}\n\nstatic inline int analysis_state__compare(\n  AnalysisState *const *self,\n  AnalysisState *const *other\n) {\n  if ((*self)->depth < (*other)->depth) return 1;\n  for (unsigned i = 0; i < (*self)->depth; i++) {\n    if (i >= (*other)->depth) return -1;\n    AnalysisStateEntry s1 = (*self)->stack[i];\n    AnalysisStateEntry s2 = (*other)->stack[i];\n    if (s1.child_index < s2.child_index) return -1;\n    if (s1.child_index > s2.child_index) return 1;\n    if (s1.parent_symbol < s2.parent_symbol) return -1;\n    if (s1.parent_symbol > s2.parent_symbol) return 1;\n    if (s1.parse_state < s2.parse_state) return -1;\n    if (s1.parse_state > s2.parse_state) return 1;\n    if (s1.field_id < s2.field_id) return -1;\n    if (s1.field_id > s2.field_id) return 1;\n  }\n  if ((*self)->step_index < (*other)->step_index) return -1;\n  if ((*self)->step_index > (*other)->step_index) return 1;\n  return 0;\n}\n\nstatic inline AnalysisStateEntry *analysis_state__top(AnalysisState *self) {\n  if (self->depth == 0) {\n    return &self->stack[0];\n  }\n  return &self->stack[self->depth - 1];\n}\n\nstatic inline bool analysis_state__has_supertype(AnalysisState *self, TSSymbol symbol) {\n  for (unsigned i = 0; i < self->depth; i++) {\n    if (self->stack[i].parent_symbol == symbol) return true;\n  }\n  return false;\n}\n\n/******************\n * AnalysisStateSet\n ******************/\n\n// Obtains an `AnalysisState` instance, either by consuming one from this set's object pool, or by\n// cloning one from scratch.\nstatic inline AnalysisState *analysis_state_pool__clone_or_reuse(\n  AnalysisStateSet *self,\n  AnalysisState *borrowed_item\n) {\n  AnalysisState *new_item;\n  if (self->size) {\n    new_item = array_pop(self);\n  } else {\n    new_item = ts_malloc(sizeof(AnalysisState));\n  }\n  *new_item = *borrowed_item;\n  return new_item;\n}\n\n// Inserts a clone of the passed-in item at the appropriate position to maintain ordering in this\n// set. The set does not contain duplicates, so if the item is already present, it will not be\n// inserted, and no clone will be made.\n//\n// The caller retains ownership of the passed-in memory. However, the clone that is created by this\n// function will be managed by the state set.\nstatic inline void analysis_state_set__insert_sorted(\n  AnalysisStateSet *self,\n  AnalysisStateSet *pool,\n  AnalysisState *borrowed_item\n) {\n  unsigned index, exists;\n  array_search_sorted_with(self, analysis_state__compare, &borrowed_item, &index, &exists);\n  if (!exists) {\n    AnalysisState *new_item = analysis_state_pool__clone_or_reuse(pool, borrowed_item);\n    array_insert(self, index, new_item);\n  }\n}\n\n// Inserts a clone of the passed-in item at the end position of this list.\n//\n// IMPORTANT: The caller MUST ENSURE that this item is larger (by the comparison function\n// `analysis_state__compare`) than largest item already in this set. If items are inserted in the\n// wrong order, the set will not function properly for future use.\n//\n// The caller retains ownership of the passed-in memory. However, the clone that is created by this\n// function will be managed by the state set.\nstatic inline void analysis_state_set__push(\n  AnalysisStateSet *self,\n  AnalysisStateSet *pool,\n  AnalysisState *borrowed_item\n) {\n  AnalysisState *new_item = analysis_state_pool__clone_or_reuse(pool, borrowed_item);\n  array_push(self, new_item);\n}\n\n// Removes all items from this set, returning it to an empty state.\nstatic inline void analysis_state_set__clear(AnalysisStateSet *self, AnalysisStateSet *pool) {\n  array_push_all(pool, self);\n  array_clear(self);\n}\n\n// Releases all memory that is managed with this state set, including any items currently present.\n// After calling this function, the set is no longer suitable for use.\nstatic inline void analysis_state_set__delete(AnalysisStateSet *self) {\n  for (unsigned i = 0; i < self->size; i++) {\n    ts_free(self->contents[i]);\n  }\n  array_delete(self);\n}\n\n/****************\n * QueryAnalyzer\n ****************/\n\nstatic inline QueryAnalysis query_analysis__new(void) {\n  return (QueryAnalysis) {\n    .states = array_new(),\n    .next_states = array_new(),\n    .deeper_states = array_new(),\n    .state_pool = array_new(),\n    .final_step_indices = array_new(),\n    .finished_parent_symbols = array_new(),\n    .did_abort = false,\n  };\n}\n\nstatic inline void query_analysis__delete(QueryAnalysis *self) {\n  analysis_state_set__delete(&self->states);\n  analysis_state_set__delete(&self->next_states);\n  analysis_state_set__delete(&self->deeper_states);\n  analysis_state_set__delete(&self->state_pool);\n  array_delete(&self->final_step_indices);\n  array_delete(&self->finished_parent_symbols);\n}\n\n/***********************\n * AnalysisSubgraphNode\n ***********************/\n\nstatic inline int analysis_subgraph_node__compare(const AnalysisSubgraphNode *self, const AnalysisSubgraphNode *other) {\n  if (self->state < other->state) return -1;\n  if (self->state > other->state) return 1;\n  if (self->child_index < other->child_index) return -1;\n  if (self->child_index > other->child_index) return 1;\n  if (self->done < other->done) return -1;\n  if (self->done > other->done) return 1;\n  if (self->production_id < other->production_id) return -1;\n  if (self->production_id > other->production_id) return 1;\n  return 0;\n}\n\n/*********\n * Query\n *********/\n\n// The `pattern_map` contains a mapping from TSSymbol values to indices in the\n// `steps` array. For a given syntax node, the `pattern_map` makes it possible\n// to quickly find the starting steps of all of the patterns whose root matches\n// that node. Each entry has two fields: a `pattern_index`, which identifies one\n// of the patterns in the query, and a `step_index`, which indicates the start\n// offset of that pattern's steps within the `steps` array.\n//\n// The entries are sorted by the patterns' root symbols, and lookups use a\n// binary search. This ensures that the cost of this initial lookup step\n// scales logarithmically with the number of patterns in the query.\n//\n// This returns `true` if the symbol is present and `false` otherwise.\n// If the symbol is not present `*result` is set to the index where the\n// symbol should be inserted.\nstatic inline bool ts_query__pattern_map_search(\n  const TSQuery *self,\n  TSSymbol needle,\n  uint32_t *result\n) {\n  uint32_t base_index = self->wildcard_root_pattern_count;\n  uint32_t size = self->pattern_map.size - base_index;\n  if (size == 0) {\n    *result = base_index;\n    return false;\n  }\n  while (size > 1) {\n    uint32_t half_size = size / 2;\n    uint32_t mid_index = base_index + half_size;\n    TSSymbol mid_symbol = array_get(&self->steps,\n      array_get(&self->pattern_map, mid_index)->step_index\n    )->symbol;\n    if (needle > mid_symbol) base_index = mid_index;\n    size -= half_size;\n  }\n\n  TSSymbol symbol = array_get(&self->steps,\n    array_get(&self->pattern_map, base_index)->step_index\n  )->symbol;\n\n  if (needle > symbol) {\n    base_index++;\n    if (base_index < self->pattern_map.size) {\n      symbol = array_get(&self->steps,\n        array_get(&self->pattern_map, base_index)->step_index\n      )->symbol;\n    }\n  }\n\n  *result = base_index;\n  return needle == symbol;\n}\n\n// Insert a new pattern's start index into the pattern map, maintaining\n// the pattern map's ordering invariant.\nstatic inline void ts_query__pattern_map_insert(\n  TSQuery *self,\n  TSSymbol symbol,\n  PatternEntry new_entry\n) {\n  uint32_t index;\n  ts_query__pattern_map_search(self, symbol, &index);\n\n  // Ensure that the entries are sorted not only by symbol, but also\n  // by pattern_index. This way, states for earlier patterns will be\n  // initiated first, which allows the ordering of the states array\n  // to be maintained more efficiently.\n  while (index < self->pattern_map.size) {\n    PatternEntry *entry = array_get(&self->pattern_map, index);\n    if (\n      array_get(&self->steps, entry->step_index)->symbol == symbol &&\n      entry->pattern_index < new_entry.pattern_index\n    ) {\n      index++;\n    } else {\n      break;\n    }\n  }\n\n  array_insert(&self->pattern_map, index, new_entry);\n}\n\n// Walk the subgraph for this non-terminal, tracking all of the possible\n// sequences of progress within the pattern.\nstatic void ts_query__perform_analysis(\n  TSQuery *self,\n  const AnalysisSubgraphArray *subgraphs,\n  QueryAnalysis *analysis\n) {\n  unsigned recursion_depth_limit = 0;\n  unsigned prev_final_step_count = 0;\n  array_clear(&analysis->final_step_indices);\n  array_clear(&analysis->finished_parent_symbols);\n\n  for (unsigned iteration = 0;; iteration++) {\n    if (iteration == MAX_ANALYSIS_ITERATION_COUNT) {\n      analysis->did_abort = true;\n      break;\n    }\n\n    #ifdef DEBUG_ANALYZE_QUERY\n      printf(\"Iteration: %u. Final step indices:\", iteration);\n      for (unsigned j = 0; j < analysis->final_step_indices.size; j++) {\n        printf(\" %4u\", *array_get(&analysis->final_step_indices, j));\n      }\n      printf(\"\\n\");\n      for (unsigned j = 0; j < analysis->states.size; j++) {\n        AnalysisState *state = *array_get(&analysis->states, j);\n        printf(\"  %3u: step: %u, stack: [\", j, state->step_index);\n        for (unsigned k = 0; k < state->depth; k++) {\n          printf(\n            \" {%s, child: %u, state: %4u\",\n            self->language->symbol_names[state->stack[k].parent_symbol],\n            state->stack[k].child_index,\n            state->stack[k].parse_state\n          );\n          if (state->stack[k].field_id) printf(\", field: %s\", self->language->field_names[state->stack[k].field_id]);\n          if (state->stack[k].done) printf(\", DONE\");\n          printf(\"}\");\n        }\n        printf(\" ]\\n\");\n      }\n    #endif\n\n    // If no further progress can be made within the current recursion depth limit, then\n    // bump the depth limit by one, and continue to process the states the exceeded the\n    // limit. But only allow this if progress has been made since the last time the depth\n    // limit was increased.\n    if (analysis->states.size == 0) {\n      if (\n        analysis->deeper_states.size > 0 &&\n        analysis->final_step_indices.size > prev_final_step_count\n      ) {\n        #ifdef DEBUG_ANALYZE_QUERY\n          printf(\"Increase recursion depth limit to %u\\n\", recursion_depth_limit + 1);\n        #endif\n\n        prev_final_step_count = analysis->final_step_indices.size;\n        recursion_depth_limit++;\n        AnalysisStateSet _states = analysis->states;\n        analysis->states = analysis->deeper_states;\n        analysis->deeper_states = _states;\n        continue;\n      }\n\n      break;\n    }\n\n    analysis_state_set__clear(&analysis->next_states, &analysis->state_pool);\n    for (unsigned j = 0; j < analysis->states.size; j++) {\n      AnalysisState * const state = *array_get(&analysis->states, j);\n\n      // For efficiency, it's important to avoid processing the same analysis state more\n      // than once. To achieve this, keep the states in order of ascending position within\n      // their hypothetical syntax trees. In each iteration of this loop, start by advancing\n      // the states that have made the least progress. Avoid advancing states that have already\n      // made more progress.\n      if (analysis->next_states.size > 0) {\n        int comparison = analysis_state__compare(\n          &state,\n          array_back(&analysis->next_states)\n        );\n        if (comparison == 0) {\n          analysis_state_set__insert_sorted(&analysis->next_states, &analysis->state_pool, state);\n          continue;\n        } else if (comparison > 0) {\n          #ifdef DEBUG_ANALYZE_QUERY\n            printf(\"Terminate iteration at state %u\\n\", j);\n          #endif\n          while (j < analysis->states.size) {\n            analysis_state_set__push(\n              &analysis->next_states,\n              &analysis->state_pool,\n              *array_get(&analysis->states, j)\n            );\n            j++;\n          }\n          break;\n        }\n      }\n\n      const TSStateId parse_state = analysis_state__top(state)->parse_state;\n      const TSSymbol parent_symbol = analysis_state__top(state)->parent_symbol;\n      const TSFieldId parent_field_id = analysis_state__top(state)->field_id;\n      const unsigned child_index = analysis_state__top(state)->child_index;\n      const QueryStep * const step = array_get(&self->steps, state->step_index);\n\n      unsigned subgraph_index, exists;\n      array_search_sorted_by(subgraphs, .symbol, parent_symbol, &subgraph_index, &exists);\n      if (!exists) continue;\n      const AnalysisSubgraph *subgraph = array_get(subgraphs, subgraph_index);\n\n      // Follow every possible path in the parse table, but only visit states that\n      // are part of the subgraph for the current symbol.\n      LookaheadIterator lookahead_iterator = ts_language_lookaheads(self->language, parse_state);\n      while (ts_lookahead_iterator__next(&lookahead_iterator)) {\n        TSSymbol sym = lookahead_iterator.symbol;\n\n        AnalysisSubgraphNode successor = {\n          .state = parse_state,\n          .child_index = child_index,\n        };\n        if (lookahead_iterator.action_count) {\n          const TSParseAction *action = &lookahead_iterator.actions[lookahead_iterator.action_count - 1];\n          if (action->type == TSParseActionTypeShift) {\n            if (!action->shift.extra) {\n              successor.state = action->shift.state;\n              successor.child_index++;\n            }\n          } else {\n            continue;\n          }\n        } else if (lookahead_iterator.next_state != 0) {\n          successor.state = lookahead_iterator.next_state;\n          successor.child_index++;\n        } else {\n          continue;\n        }\n\n        unsigned node_index;\n        array_search_sorted_with(\n          &subgraph->nodes,\n          analysis_subgraph_node__compare, &successor,\n          &node_index, &exists\n        );\n        while (node_index < subgraph->nodes.size) {\n          AnalysisSubgraphNode *node = array_get(&subgraph->nodes, node_index);\n          node_index++;\n          if (node->state != successor.state || node->child_index != successor.child_index) break;\n\n          // Use the subgraph to determine what alias and field will eventually be applied\n          // to this child node.\n          TSSymbol alias = ts_language_alias_at(self->language, node->production_id, child_index);\n          TSSymbol visible_symbol = alias\n            ? alias\n            : self->language->symbol_metadata[sym].visible\n              ? self->language->public_symbol_map[sym]\n              : 0;\n          TSFieldId field_id = parent_field_id;\n          if (!field_id) {\n            const TSFieldMapEntry *field_map, *field_map_end;\n            ts_language_field_map(self->language, node->production_id, &field_map, &field_map_end);\n            for (; field_map != field_map_end; field_map++) {\n              if (!field_map->inherited && field_map->child_index == child_index) {\n                field_id = field_map->field_id;\n                break;\n              }\n            }\n          }\n\n          // Create a new state that has advanced past this hypothetical subtree.\n          AnalysisState next_state = *state;\n          AnalysisStateEntry *next_state_top = analysis_state__top(&next_state);\n          next_state_top->child_index = successor.child_index;\n          next_state_top->parse_state = successor.state;\n          if (node->done) next_state_top->done = true;\n\n          // Determine if this hypothetical child node would match the current step\n          // of the query pattern.\n          bool does_match = false;\n\n          // ERROR nodes can appear anywhere, so if the step is\n          // looking for an ERROR node, consider it potentially matchable.\n          if (step->symbol == ts_builtin_sym_error) {\n            does_match = true;\n          } else if (visible_symbol) {\n            does_match = true;\n            if (step->symbol == WILDCARD_SYMBOL) {\n              if (\n                step->is_named &&\n                !self->language->symbol_metadata[visible_symbol].named\n              ) does_match = false;\n            } else if (step->symbol != visible_symbol) {\n              does_match = false;\n            }\n            if (step->field && step->field != field_id) {\n              does_match = false;\n            }\n            if (\n              step->supertype_symbol &&\n              !analysis_state__has_supertype(state, step->supertype_symbol)\n            ) does_match = false;\n          }\n\n          // If this child is hidden, then descend into it and walk through its children.\n          // If the top entry of the stack is at the end of its rule, then that entry can\n          // be replaced. Otherwise, push a new entry onto the stack.\n          else if (sym >= self->language->token_count) {\n            if (!next_state_top->done) {\n              if (next_state.depth + 1 >= MAX_ANALYSIS_STATE_DEPTH) {\n                #ifdef DEBUG_ANALYZE_QUERY\n                  printf(\"Exceeded depth limit for state %u\\n\", j);\n                #endif\n\n                analysis->did_abort = true;\n                continue;\n              }\n\n              next_state.depth++;\n              next_state_top = analysis_state__top(&next_state);\n            }\n\n            *next_state_top = (AnalysisStateEntry) {\n              .parse_state = parse_state,\n              .parent_symbol = sym,\n              .child_index = 0,\n              .field_id = field_id,\n              .done = false,\n            };\n\n            if (analysis_state__recursion_depth(&next_state) > recursion_depth_limit) {\n              analysis_state_set__insert_sorted(\n                &analysis->deeper_states,\n                &analysis->state_pool,\n                &next_state\n              );\n              continue;\n            }\n          }\n\n          // Pop from the stack when this state reached the end of its current syntax node.\n          while (next_state.depth > 0 && next_state_top->done) {\n            next_state.depth--;\n            next_state_top = analysis_state__top(&next_state);\n          }\n\n          // If this hypothetical child did match the current step of the query pattern,\n          // then advance to the next step at the current depth. This involves skipping\n          // over any descendant steps of the current child.\n          const QueryStep *next_step = step;\n          if (does_match) {\n            for (;;) {\n              next_state.step_index++;\n              next_step = array_get(&self->steps, next_state.step_index);\n              if (\n                next_step->depth == PATTERN_DONE_MARKER ||\n                next_step->depth <= step->depth\n              ) break;\n            }\n          } else if (successor.state == parse_state) {\n            continue;\n          }\n\n          for (;;) {\n            // Skip pass-through states. Although these states have alternatives, they are only\n            // used to implement repetitions, and query analysis does not need to process\n            // repetitions in order to determine whether steps are possible and definite.\n            if (next_step->is_pass_through) {\n              next_state.step_index++;\n              next_step++;\n              continue;\n            }\n\n            // If the pattern is finished or hypothetical parent node is complete, then\n            // record that matching can terminate at this step of the pattern. Otherwise,\n            // add this state to the list of states to process on the next iteration.\n            if (!next_step->is_dead_end) {\n              bool did_finish_pattern = array_get(&self->steps, next_state.step_index)->depth != step->depth;\n              if (did_finish_pattern) {\n                array_insert_sorted_by(&analysis->finished_parent_symbols, , state->root_symbol);\n              } else if (next_state.depth == 0) {\n                array_insert_sorted_by(&analysis->final_step_indices, , next_state.step_index);\n              } else {\n                analysis_state_set__insert_sorted(&analysis->next_states, &analysis->state_pool, &next_state);\n              }\n            }\n\n            // If the state has advanced to a step with an alternative step, then add another state\n            // at that alternative step. This process is simpler than the process of actually matching a\n            // pattern during query execution, because for the purposes of query analysis, there is no\n            // need to process repetitions.\n            if (\n              does_match &&\n              next_step->alternative_index != NONE &&\n              next_step->alternative_index > next_state.step_index\n            ) {\n              next_state.step_index = next_step->alternative_index;\n              next_step = array_get(&self->steps, next_state.step_index);\n            } else {\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    AnalysisStateSet _states = analysis->states;\n    analysis->states = analysis->next_states;\n    analysis->next_states = _states;\n  }\n}\n\nstatic bool ts_query__analyze_patterns(TSQuery *self, unsigned *error_offset) {\n  Array(uint16_t) non_rooted_pattern_start_steps = array_new();\n  for (unsigned i = 0; i < self->pattern_map.size; i++) {\n    PatternEntry *pattern = array_get(&self->pattern_map, i);\n    if (!pattern->is_rooted) {\n      QueryStep *step = array_get(&self->steps, pattern->step_index);\n      if (step->symbol != WILDCARD_SYMBOL) {\n        array_push(&non_rooted_pattern_start_steps, i);\n      }\n    }\n  }\n\n  // Walk forward through all of the steps in the query, computing some\n  // basic information about each step. Mark all of the steps that contain\n  // captures, and record the indices of all of the steps that have child steps.\n  Array(uint32_t) parent_step_indices = array_new();\n  bool all_patterns_are_valid = true;\n  for (unsigned i = 0; i < self->steps.size; i++) {\n    QueryStep *step = array_get(&self->steps, i);\n    if (step->depth == PATTERN_DONE_MARKER) {\n      step->parent_pattern_guaranteed = true;\n      step->root_pattern_guaranteed = true;\n      continue;\n    }\n\n    bool has_children = false;\n    bool is_wildcard = step->symbol == WILDCARD_SYMBOL;\n    step->contains_captures = step->capture_ids[0] != NONE;\n    for (unsigned j = i + 1; j < self->steps.size; j++) {\n      QueryStep *next_step = array_get(&self->steps, j);\n      if (\n        next_step->depth == PATTERN_DONE_MARKER ||\n        next_step->depth <= step->depth\n      ) break;\n      if (next_step->capture_ids[0] != NONE) {\n        step->contains_captures = true;\n      }\n      if (!is_wildcard) {\n        next_step->root_pattern_guaranteed = true;\n        next_step->parent_pattern_guaranteed = true;\n      }\n      has_children = true;\n    }\n\n    if (has_children) {\n      if (!is_wildcard) {\n        array_push(&parent_step_indices, i);\n      } else if (step->supertype_symbol && self->language->abi_version >= LANGUAGE_VERSION_WITH_RESERVED_WORDS) {\n        // Look at the child steps to see if any aren't valid subtypes for this supertype.\n        uint32_t subtype_length;\n        const TSSymbol *subtypes = ts_language_subtypes(\n          self->language,\n          step->supertype_symbol,\n          &subtype_length\n        );\n\n        for (unsigned j = i + 1; j < self->steps.size; j++) {\n          QueryStep *child_step = array_get(&self->steps, j);\n          if (child_step->depth == PATTERN_DONE_MARKER || child_step->depth <= step->depth) {\n            break;\n          }\n          if (child_step->depth == step->depth + 1 && child_step->symbol != WILDCARD_SYMBOL) {\n            bool is_valid_subtype = false;\n            for (uint32_t k = 0; k < subtype_length; k++) {\n              if (child_step->symbol == subtypes[k]) {\n                is_valid_subtype = true;\n                break;\n              }\n            }\n\n            if (!is_valid_subtype) {\n              for (unsigned offset_idx = 0; offset_idx < self->step_offsets.size; offset_idx++) {\n                StepOffset *step_offset = array_get(&self->step_offsets, offset_idx);\n                if (step_offset->step_index >= j) {\n                  *error_offset = step_offset->byte_offset;\n                  all_patterns_are_valid = false;\n                  goto supertype_cleanup;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // For every parent symbol in the query, initialize an 'analysis subgraph'.\n  // This subgraph lists all of the states in the parse table that are directly\n  // involved in building subtrees for this symbol.\n  //\n  // In addition to the parent symbols in the query, construct subgraphs for all\n  // of the hidden symbols in the grammar, because these might occur within\n  // one of the parent nodes, such that their children appear to belong to the\n  // parent.\n  AnalysisSubgraphArray subgraphs = array_new();\n  for (unsigned i = 0; i < parent_step_indices.size; i++) {\n    uint32_t parent_step_index = *array_get(&parent_step_indices, i);\n    TSSymbol parent_symbol = array_get(&self->steps, parent_step_index)->symbol;\n    AnalysisSubgraph subgraph = { .symbol = parent_symbol };\n    array_insert_sorted_by(&subgraphs, .symbol, subgraph);\n  }\n  for (TSSymbol sym = (uint16_t)self->language->token_count; sym < (uint16_t)self->language->symbol_count; sym++) {\n    if (!ts_language_symbol_metadata(self->language, sym).visible) {\n      AnalysisSubgraph subgraph = { .symbol = sym };\n      array_insert_sorted_by(&subgraphs, .symbol, subgraph);\n    }\n  }\n\n  // Scan the parse table to find the data needed to populate these subgraphs.\n  // Collect three things during this scan:\n  //   1) All of the parse states where one of these symbols can start.\n  //   2) All of the parse states where one of these symbols can end, along\n  //      with information about the node that would be created.\n  //   3) A list of predecessor states for each state.\n  StatePredecessorMap predecessor_map = state_predecessor_map_new(self->language);\n  for (TSStateId state = 1; state < (uint16_t)self->language->state_count; state++) {\n    unsigned subgraph_index, exists;\n    LookaheadIterator lookahead_iterator = ts_language_lookaheads(self->language, state);\n    while (ts_lookahead_iterator__next(&lookahead_iterator)) {\n      if (lookahead_iterator.action_count) {\n        for (unsigned i = 0; i < lookahead_iterator.action_count; i++) {\n          const TSParseAction *action = &lookahead_iterator.actions[i];\n          if (action->type == TSParseActionTypeReduce) {\n            const TSSymbol *aliases, *aliases_end;\n            ts_language_aliases_for_symbol(\n              self->language,\n              action->reduce.symbol,\n              &aliases,\n              &aliases_end\n            );\n            for (const TSSymbol *symbol = aliases; symbol < aliases_end; symbol++) {\n              array_search_sorted_by(\n                &subgraphs,\n                .symbol,\n                *symbol,\n                &subgraph_index,\n                &exists\n              );\n              if (exists) {\n                AnalysisSubgraph *subgraph = array_get(&subgraphs, subgraph_index);\n                if (subgraph->nodes.size == 0 || array_back(&subgraph->nodes)->state != state) {\n                  array_push(&subgraph->nodes, ((AnalysisSubgraphNode) {\n                    .state = state,\n                    .production_id = action->reduce.production_id,\n                    .child_index = action->reduce.child_count,\n                    .done = true,\n                  }));\n                }\n              }\n            }\n          } else if (action->type == TSParseActionTypeShift && !action->shift.extra) {\n            TSStateId next_state = action->shift.state;\n            state_predecessor_map_add(&predecessor_map, next_state, state);\n          }\n        }\n      } else if (lookahead_iterator.next_state != 0) {\n        if (lookahead_iterator.next_state != state) {\n          state_predecessor_map_add(&predecessor_map, lookahead_iterator.next_state, state);\n        }\n        if (ts_language_state_is_primary(self->language, state)) {\n          const TSSymbol *aliases, *aliases_end;\n          ts_language_aliases_for_symbol(\n            self->language,\n            lookahead_iterator.symbol,\n            &aliases,\n            &aliases_end\n          );\n          for (const TSSymbol *symbol = aliases; symbol < aliases_end; symbol++) {\n            array_search_sorted_by(\n              &subgraphs,\n              .symbol,\n              *symbol,\n              &subgraph_index,\n              &exists\n            );\n            if (exists) {\n              AnalysisSubgraph *subgraph = array_get(&subgraphs, subgraph_index);\n              if (\n                subgraph->start_states.size == 0 ||\n                *array_back(&subgraph->start_states) != state\n              )\n              array_push(&subgraph->start_states, state);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // For each subgraph, compute the preceding states by walking backward\n  // from the end states using the predecessor map.\n  Array(AnalysisSubgraphNode) next_nodes = array_new();\n  for (unsigned i = 0; i < subgraphs.size; i++) {\n    AnalysisSubgraph *subgraph = array_get(&subgraphs, i);\n    if (subgraph->nodes.size == 0) {\n      array_delete(&subgraph->start_states);\n      array_erase(&subgraphs, i);\n      i--;\n      continue;\n    }\n    array_assign(&next_nodes, &subgraph->nodes);\n    while (next_nodes.size > 0) {\n      AnalysisSubgraphNode node = array_pop(&next_nodes);\n      if (node.child_index > 1) {\n        unsigned predecessor_count;\n        const TSStateId *predecessors = state_predecessor_map_get(\n          &predecessor_map,\n          node.state,\n          &predecessor_count\n        );\n        for (unsigned j = 0; j < predecessor_count; j++) {\n          AnalysisSubgraphNode predecessor_node = {\n            .state = predecessors[j],\n            .child_index = node.child_index - 1,\n            .production_id = node.production_id,\n            .done = false,\n          };\n          unsigned index, exists;\n          array_search_sorted_with(\n            &subgraph->nodes, analysis_subgraph_node__compare, &predecessor_node,\n            &index, &exists\n          );\n          if (!exists) {\n            array_insert(&subgraph->nodes, index, predecessor_node);\n            array_push(&next_nodes, predecessor_node);\n          }\n        }\n      }\n    }\n  }\n\n  #ifdef DEBUG_ANALYZE_QUERY\n    printf(\"\\nSubgraphs:\\n\");\n    for (unsigned i = 0; i < subgraphs.size; i++) {\n      AnalysisSubgraph *subgraph = array_get(&subgraphs, i);\n      printf(\"  %u, %s:\\n\", subgraph->symbol, ts_language_symbol_name(self->language, subgraph->symbol));\n      for (unsigned j = 0; j < subgraph->start_states.size; j++) {\n        printf(\n          \"    {state: %u}\\n\",\n          *array_get(&subgraph->start_states, j)\n        );\n      }\n      for (unsigned j = 0; j < subgraph->nodes.size; j++) {\n        AnalysisSubgraphNode *node = array_get(&subgraph->nodes, j);\n        printf(\n          \"    {state: %u, child_index: %u, production_id: %u, done: %d}\\n\",\n          node->state, node->child_index, node->production_id, node->done\n        );\n      }\n      printf(\"\\n\");\n    }\n  #endif\n\n  // For each non-terminal pattern, determine if the pattern can successfully match,\n  // and identify all of the possible children within the pattern where matching could fail.\n  QueryAnalysis analysis = query_analysis__new();\n  for (unsigned i = 0; i < parent_step_indices.size; i++) {\n    uint16_t parent_step_index = *array_get(&parent_step_indices, i);\n    uint16_t parent_depth = array_get(&self->steps, parent_step_index)->depth;\n    TSSymbol parent_symbol = array_get(&self->steps, parent_step_index)->symbol;\n    if (parent_symbol == ts_builtin_sym_error) continue;\n\n    // Find the subgraph that corresponds to this pattern's root symbol. If the pattern's\n    // root symbol is a terminal, then return an error.\n    unsigned subgraph_index, exists;\n    array_search_sorted_by(&subgraphs, .symbol, parent_symbol, &subgraph_index, &exists);\n    if (!exists) {\n      unsigned first_child_step_index = parent_step_index + 1;\n      uint32_t j, child_exists;\n      array_search_sorted_by(&self->step_offsets, .step_index, first_child_step_index, &j, &child_exists);\n      ts_assert(child_exists);\n      *error_offset = array_get(&self->step_offsets, j)->byte_offset;\n      all_patterns_are_valid = false;\n      break;\n    }\n\n    // Initialize an analysis state at every parse state in the table where\n    // this parent symbol can occur.\n    AnalysisSubgraph *subgraph = array_get(&subgraphs, subgraph_index);\n    analysis_state_set__clear(&analysis.states, &analysis.state_pool);\n    analysis_state_set__clear(&analysis.deeper_states, &analysis.state_pool);\n    for (unsigned j = 0; j < subgraph->start_states.size; j++) {\n      TSStateId parse_state = *array_get(&subgraph->start_states, j);\n      analysis_state_set__push(&analysis.states, &analysis.state_pool, &((AnalysisState) {\n        .step_index = parent_step_index + 1,\n        .stack = {\n          [0] = {\n            .parse_state = parse_state,\n            .parent_symbol = parent_symbol,\n            .child_index = 0,\n            .field_id = 0,\n            .done = false,\n          },\n        },\n        .depth = 1,\n        .root_symbol = parent_symbol,\n      }));\n    }\n\n    #ifdef DEBUG_ANALYZE_QUERY\n      printf(\n        \"\\nWalk states for %s:\\n\",\n        ts_language_symbol_name(self->language, (*array_get(&analysis.states, 0))->stack[0].parent_symbol)\n      );\n    #endif\n\n    analysis.did_abort = false;\n    ts_query__perform_analysis(self, &subgraphs, &analysis);\n\n    // If this pattern could not be fully analyzed, then every step should\n    // be considered fallible.\n    if (analysis.did_abort) {\n      for (unsigned j = parent_step_index + 1; j < self->steps.size; j++) {\n        QueryStep *step = array_get(&self->steps, j);\n        if (\n          step->depth <= parent_depth ||\n          step->depth == PATTERN_DONE_MARKER\n        ) break;\n        if (!step->is_dead_end) {\n          step->parent_pattern_guaranteed = false;\n          step->root_pattern_guaranteed = false;\n        }\n      }\n      continue;\n    }\n\n    // If this pattern cannot match, store the pattern index so that it can be\n    // returned to the caller.\n    if (analysis.finished_parent_symbols.size == 0) {\n      uint16_t impossible_step_index;\n      if (analysis.final_step_indices.size > 0) {\n        impossible_step_index = *array_back(&analysis.final_step_indices);\n      } else {\n        // If there isn't a final step, then that means the parent step itself is unreachable.\n        impossible_step_index = parent_step_index;\n      }\n      uint32_t j, impossible_exists;\n      array_search_sorted_by(&self->step_offsets, .step_index, impossible_step_index, &j, &impossible_exists);\n      if (j >= self->step_offsets.size) j = self->step_offsets.size - 1;\n      *error_offset = array_get(&self->step_offsets, j)->byte_offset;\n      all_patterns_are_valid = false;\n      break;\n    }\n\n    // Mark as fallible any step where a match terminated.\n    // Later, this property will be propagated to all of the step's predecessors.\n    for (unsigned j = 0; j < analysis.final_step_indices.size; j++) {\n      uint32_t final_step_index = *array_get(&analysis.final_step_indices, j);\n      QueryStep *step = array_get(&self->steps, final_step_index);\n      if (\n        step->depth != PATTERN_DONE_MARKER &&\n        step->depth > parent_depth &&\n        !step->is_dead_end\n      ) {\n        step->parent_pattern_guaranteed = false;\n        step->root_pattern_guaranteed = false;\n      }\n    }\n  }\n\n  // Mark as indefinite any step with captures that are used in predicates.\n  Array(uint16_t) predicate_capture_ids = array_new();\n  for (unsigned i = 0; i < self->patterns.size; i++) {\n    QueryPattern *pattern = array_get(&self->patterns, i);\n\n    // Gather all of the captures that are used in predicates for this pattern.\n    array_clear(&predicate_capture_ids);\n    for (\n      unsigned start = pattern->predicate_steps.offset,\n      end = start + pattern->predicate_steps.length,\n      j = start; j < end; j++\n    ) {\n      TSQueryPredicateStep *step = array_get(&self->predicate_steps, j);\n      if (step->type == TSQueryPredicateStepTypeCapture) {\n        uint16_t value_id = step->value_id;\n        array_insert_sorted_by(&predicate_capture_ids, , value_id);\n      }\n    }\n\n    // Find all of the steps that have these captures.\n    for (\n      unsigned start = pattern->steps.offset,\n      end = start + pattern->steps.length,\n      j = start; j < end; j++\n    ) {\n      QueryStep *step = array_get(&self->steps, j);\n      for (unsigned k = 0; k < MAX_STEP_CAPTURE_COUNT; k++) {\n        uint16_t capture_id = step->capture_ids[k];\n        if (capture_id == NONE) break;\n        unsigned index, exists;\n        array_search_sorted_by(&predicate_capture_ids, , capture_id, &index, &exists);\n        if (exists) {\n          step->root_pattern_guaranteed = false;\n          break;\n        }\n      }\n    }\n  }\n\n  // Propagate fallibility. If a pattern is fallible at a given step, then it is\n  // fallible at all of its preceding steps.\n  bool done = self->steps.size == 0;\n  while (!done) {\n    done = true;\n    for (unsigned i = self->steps.size - 1; i > 0; i--) {\n      QueryStep *step = array_get(&self->steps, i);\n      if (step->depth == PATTERN_DONE_MARKER) continue;\n\n      // Determine if this step is definite or has definite alternatives.\n      bool parent_pattern_guaranteed = false;\n      for (;;) {\n        if (step->root_pattern_guaranteed) {\n          parent_pattern_guaranteed = true;\n          break;\n        }\n        if (step->alternative_index == NONE || step->alternative_index < i) {\n          break;\n        }\n        step = array_get(&self->steps, step->alternative_index);\n      }\n\n      // If not, mark its predecessor as indefinite.\n      if (!parent_pattern_guaranteed) {\n        QueryStep *prev_step = array_get(&self->steps, i - 1);\n        if (\n          !prev_step->is_dead_end &&\n          prev_step->depth != PATTERN_DONE_MARKER &&\n          prev_step->root_pattern_guaranteed\n        ) {\n          prev_step->root_pattern_guaranteed = false;\n          done = false;\n        }\n      }\n    }\n  }\n\n  #ifdef DEBUG_ANALYZE_QUERY\n    printf(\"Steps:\\n\");\n    for (unsigned i = 0; i < self->steps.size; i++) {\n      QueryStep *step = array_get(&self->steps, i);\n      if (step->depth == PATTERN_DONE_MARKER) {\n        printf(\"  %u: DONE\\n\", i);\n      } else {\n        printf(\n          \"  %u: {symbol: %s, field: %s, depth: %u, parent_pattern_guaranteed: %d, root_pattern_guaranteed: %d}\\n\",\n          i,\n          (step->symbol == WILDCARD_SYMBOL)\n            ? \"ANY\"\n            : ts_language_symbol_name(self->language, step->symbol),\n          (step->field ? ts_language_field_name_for_id(self->language, step->field) : \"-\"),\n          step->depth,\n          step->parent_pattern_guaranteed,\n          step->root_pattern_guaranteed\n        );\n      }\n    }\n  #endif\n\n  // Determine which repetition symbols in this language have the possibility\n  // of matching non-rooted patterns in this query. These repetition symbols\n  // prevent certain optimizations with range restrictions.\n  analysis.did_abort = false;\n  for (uint32_t i = 0; i < non_rooted_pattern_start_steps.size; i++) {\n    uint16_t pattern_entry_index = *array_get(&non_rooted_pattern_start_steps, i);\n    PatternEntry *pattern_entry = array_get(&self->pattern_map, pattern_entry_index);\n\n    analysis_state_set__clear(&analysis.states, &analysis.state_pool);\n    analysis_state_set__clear(&analysis.deeper_states, &analysis.state_pool);\n    for (unsigned j = 0; j < subgraphs.size; j++) {\n      AnalysisSubgraph *subgraph = array_get(&subgraphs, j);\n      TSSymbolMetadata metadata = ts_language_symbol_metadata(self->language, subgraph->symbol);\n      if (metadata.visible || metadata.named) continue;\n\n      for (uint32_t k = 0; k < subgraph->start_states.size; k++) {\n        TSStateId parse_state = *array_get(&subgraph->start_states, k);\n        analysis_state_set__push(&analysis.states, &analysis.state_pool, &((AnalysisState) {\n          .step_index = pattern_entry->step_index,\n          .stack = {\n            [0] = {\n              .parse_state = parse_state,\n              .parent_symbol = subgraph->symbol,\n              .child_index = 0,\n              .field_id = 0,\n              .done = false,\n            },\n          },\n          .root_symbol = subgraph->symbol,\n          .depth = 1,\n        }));\n      }\n    }\n\n    #ifdef DEBUG_ANALYZE_QUERY\n      printf(\"\\nWalk states for rootless pattern step %u:\\n\", pattern_entry->step_index);\n    #endif\n\n    ts_query__perform_analysis(\n      self,\n      &subgraphs,\n      &analysis\n    );\n\n    if (analysis.finished_parent_symbols.size > 0) {\n      array_get(&self->patterns, pattern_entry->pattern_index)->is_non_local = true;\n    }\n\n    for (unsigned k = 0; k < analysis.finished_parent_symbols.size; k++) {\n      TSSymbol symbol = *array_get(&analysis.finished_parent_symbols, k);\n      array_insert_sorted_by(&self->repeat_symbols_with_rootless_patterns, , symbol);\n    }\n  }\n\n  #ifdef DEBUG_ANALYZE_QUERY\n    if (self->repeat_symbols_with_rootless_patterns.size > 0) {\n      printf(\"\\nRepetition symbols with rootless patterns:\\n\");\n      printf(\"aborted analysis: %d\\n\", analysis.did_abort);\n      for (unsigned i = 0; i < self->repeat_symbols_with_rootless_patterns.size; i++) {\n        TSSymbol symbol = *array_get(&self->repeat_symbols_with_rootless_patterns, i);\n        printf(\"  %u, %s\\n\", symbol, ts_language_symbol_name(self->language, symbol));\n      }\n      printf(\"\\n\");\n    }\n  #endif\n\n  // Cleanup\n  for (unsigned i = 0; i < subgraphs.size; i++) {\n    array_delete(&array_get(&subgraphs, i)->start_states);\n    array_delete(&array_get(&subgraphs, i)->nodes);\n  }\n  array_delete(&subgraphs);\n  query_analysis__delete(&analysis);\n  array_delete(&next_nodes);\n  array_delete(&predicate_capture_ids);\n  state_predecessor_map_delete(&predecessor_map);\n\nsupertype_cleanup:\n  array_delete(&non_rooted_pattern_start_steps);\n  array_delete(&parent_step_indices);\n\n  return all_patterns_are_valid;\n}\n\nstatic void ts_query__add_negated_fields(\n  TSQuery *self,\n  uint16_t step_index,\n  TSFieldId *field_ids,\n  uint16_t field_count\n) {\n  QueryStep *step = array_get(&self->steps, step_index);\n\n  // The negated field array stores a list of field lists, separated by zeros.\n  // Try to find the start index of an existing list that matches this new list.\n  bool failed_match = false;\n  unsigned match_count = 0;\n  unsigned start_i = 0;\n  for (unsigned i = 0; i < self->negated_fields.size; i++) {\n    TSFieldId existing_field_id = *array_get(&self->negated_fields, i);\n\n    // At each zero value, terminate the match attempt. If we've exactly\n    // matched the new field list, then reuse this index. Otherwise,\n    // start over the matching process.\n    if (existing_field_id == 0) {\n      if (match_count == field_count) {\n        step->negated_field_list_id = start_i;\n        return;\n      } else {\n        start_i = i + 1;\n        match_count = 0;\n        failed_match = false;\n      }\n    }\n\n    // If the existing list matches our new list so far, then advance\n    // to the next element of the new list.\n    else if (\n      match_count < field_count &&\n      existing_field_id == field_ids[match_count] &&\n      !failed_match\n    ) {\n      match_count++;\n    }\n\n    // Otherwise, this existing list has failed to match.\n    else {\n      match_count = 0;\n      failed_match = true;\n    }\n  }\n\n  step->negated_field_list_id = self->negated_fields.size;\n  array_extend(&self->negated_fields, field_count, field_ids);\n  array_push(&self->negated_fields, 0);\n}\n\nstatic TSQueryError ts_query__parse_string_literal(\n  TSQuery *self,\n  Stream *stream\n) {\n  const char *string_start = stream->input;\n  if (stream->next != '\"') return TSQueryErrorSyntax;\n  stream_advance(stream);\n  const char *prev_position = stream->input;\n\n  bool is_escaped = false;\n  array_clear(&self->string_buffer);\n  for (;;) {\n    if (is_escaped) {\n      is_escaped = false;\n      switch (stream->next) {\n        case 'n':\n          array_push(&self->string_buffer, '\\n');\n          break;\n        case 'r':\n          array_push(&self->string_buffer, '\\r');\n          break;\n        case 't':\n          array_push(&self->string_buffer, '\\t');\n          break;\n        case '0':\n          array_push(&self->string_buffer, '\\0');\n          break;\n        default:\n          array_extend(&self->string_buffer, stream->next_size, stream->input);\n          break;\n      }\n      prev_position = stream->input + stream->next_size;\n    } else {\n      if (stream->next == '\\\\') {\n        array_extend(&self->string_buffer, (uint32_t)(stream->input - prev_position), prev_position);\n        prev_position = stream->input + 1;\n        is_escaped = true;\n      } else if (stream->next == '\"') {\n        array_extend(&self->string_buffer, (uint32_t)(stream->input - prev_position), prev_position);\n        stream_advance(stream);\n        return TSQueryErrorNone;\n      } else if (stream->next == '\\n') {\n        stream_reset(stream, string_start);\n        return TSQueryErrorSyntax;\n      }\n    }\n    if (!stream_advance(stream)) {\n      stream_reset(stream, string_start);\n      return TSQueryErrorSyntax;\n    }\n  }\n}\n\n// Parse a single predicate associated with a pattern, adding it to the\n// query's internal `predicate_steps` array. Predicates are arbitrary\n// S-expressions associated with a pattern which are meant to be handled at\n// a higher level of abstraction, such as the Rust/JavaScript bindings. They\n// can contain '@'-prefixed capture names, double-quoted strings, and bare\n// symbols, which also represent strings.\nstatic TSQueryError ts_query__parse_predicate(\n  TSQuery *self,\n  Stream *stream\n) {\n  if (!stream_is_ident_start(stream)) return TSQueryErrorSyntax;\n  const char *predicate_name = stream->input;\n  stream_scan_identifier(stream);\n  if (stream->next != '?' && stream->next != '!') {\n    return TSQueryErrorSyntax;\n  }\n  stream_advance(stream);\n  uint32_t length = (uint32_t)(stream->input - predicate_name);\n  uint16_t id = symbol_table_insert_name(\n    &self->predicate_values,\n    predicate_name,\n    length\n  );\n  array_push(&self->predicate_steps, ((TSQueryPredicateStep) {\n    .type = TSQueryPredicateStepTypeString,\n    .value_id = id,\n  }));\n  stream_skip_whitespace(stream);\n\n  for (;;) {\n    if (stream->next == ')') {\n      stream_advance(stream);\n      stream_skip_whitespace(stream);\n      array_push(&self->predicate_steps, ((TSQueryPredicateStep) {\n        .type = TSQueryPredicateStepTypeDone,\n        .value_id = 0,\n      }));\n      break;\n    }\n\n    // Parse an '@'-prefixed capture name\n    else if (stream->next == '@') {\n      stream_advance(stream);\n\n      // Parse the capture name\n      if (!stream_is_ident_start(stream)) return TSQueryErrorSyntax;\n      const char *capture_name = stream->input;\n      stream_scan_identifier(stream);\n      uint32_t capture_length = (uint32_t)(stream->input - capture_name);\n\n      // Add the capture id to the first step of the pattern\n      int capture_id = symbol_table_id_for_name(\n        &self->captures,\n        capture_name,\n        capture_length\n      );\n      if (capture_id == -1) {\n        stream_reset(stream, capture_name);\n        return TSQueryErrorCapture;\n      }\n\n      array_push(&self->predicate_steps, ((TSQueryPredicateStep) {\n        .type = TSQueryPredicateStepTypeCapture,\n        .value_id = capture_id,\n      }));\n    }\n\n    // Parse a string literal\n    else if (stream->next == '\"') {\n      TSQueryError e = ts_query__parse_string_literal(self, stream);\n      if (e) return e;\n      uint16_t query_id = symbol_table_insert_name(\n        &self->predicate_values,\n        self->string_buffer.contents,\n        self->string_buffer.size\n      );\n      array_push(&self->predicate_steps, ((TSQueryPredicateStep) {\n        .type = TSQueryPredicateStepTypeString,\n        .value_id = query_id,\n      }));\n    }\n\n    // Parse a bare symbol\n    else if (stream_is_ident_start(stream)) {\n      const char *symbol_start = stream->input;\n      stream_scan_identifier(stream);\n      uint32_t symbol_length = (uint32_t)(stream->input - symbol_start);\n      uint16_t query_id = symbol_table_insert_name(\n        &self->predicate_values,\n        symbol_start,\n        symbol_length\n      );\n      array_push(&self->predicate_steps, ((TSQueryPredicateStep) {\n        .type = TSQueryPredicateStepTypeString,\n        .value_id = query_id,\n      }));\n    }\n\n    else {\n      return TSQueryErrorSyntax;\n    }\n\n    stream_skip_whitespace(stream);\n  }\n\n  return 0;\n}\n\n// Read one S-expression pattern from the stream, and incorporate it into\n// the query's internal state machine representation. For nested patterns,\n// this function calls itself recursively.\n//\n// The caller is responsible for passing in a dedicated CaptureQuantifiers.\n// These should not be shared between different calls to ts_query__parse_pattern!\nstatic TSQueryError ts_query__parse_pattern(\n  TSQuery *self,\n  Stream *stream,\n  uint32_t depth,\n  bool is_immediate,\n  CaptureQuantifiers *capture_quantifiers\n) {\n  if (stream->next == 0) return TSQueryErrorSyntax;\n  if (stream->next == ')' || stream->next == ']') return PARENT_DONE;\n\n  const uint32_t starting_step_index = self->steps.size;\n\n  // Store the byte offset of each step in the query.\n  if (\n    self->step_offsets.size == 0 ||\n    array_back(&self->step_offsets)->step_index != starting_step_index\n  ) {\n    array_push(&self->step_offsets, ((StepOffset) {\n      .step_index = starting_step_index,\n      .byte_offset = stream_offset(stream),\n    }));\n  }\n\n  // An open bracket is the start of an alternation.\n  if (stream->next == '[') {\n    stream_advance(stream);\n    stream_skip_whitespace(stream);\n\n    // Parse each branch, and add a placeholder step in between the branches.\n    Array(uint32_t) branch_step_indices = array_new();\n    CaptureQuantifiers branch_capture_quantifiers = capture_quantifiers_new();\n    for (;;) {\n      uint32_t start_index = self->steps.size;\n      TSQueryError e = ts_query__parse_pattern(\n        self,\n        stream,\n        depth,\n        is_immediate,\n        &branch_capture_quantifiers\n      );\n\n      if (e == PARENT_DONE) {\n        if (stream->next == ']' && branch_step_indices.size > 0) {\n          stream_advance(stream);\n          break;\n        }\n        e = TSQueryErrorSyntax;\n      }\n      if (e) {\n        capture_quantifiers_delete(&branch_capture_quantifiers);\n        array_delete(&branch_step_indices);\n        return e;\n      }\n\n      if (start_index == starting_step_index) {\n        capture_quantifiers_replace(capture_quantifiers, &branch_capture_quantifiers);\n      } else {\n        capture_quantifiers_join_all(capture_quantifiers, &branch_capture_quantifiers);\n      }\n\n      array_push(&branch_step_indices, start_index);\n      array_push(&self->steps, query_step__new(0, depth, false));\n      capture_quantifiers_clear(&branch_capture_quantifiers);\n    }\n    (void)array_pop(&self->steps);\n\n    // For all of the branches except for the last one, add the subsequent branch as an\n    // alternative, and link the end of the branch to the current end of the steps.\n    for (unsigned i = 0; i < branch_step_indices.size - 1; i++) {\n      uint32_t step_index = *array_get(&branch_step_indices, i);\n      uint32_t next_step_index = *array_get(&branch_step_indices, i + 1);\n      QueryStep *start_step = array_get(&self->steps, step_index);\n      QueryStep *end_step = array_get(&self->steps, next_step_index - 1);\n      start_step->alternative_index = next_step_index;\n      end_step->alternative_index = self->steps.size;\n      end_step->is_dead_end = true;\n    }\n\n    capture_quantifiers_delete(&branch_capture_quantifiers);\n    array_delete(&branch_step_indices);\n  }\n\n  // An open parenthesis can be the start of three possible constructs:\n  // * A grouped sequence\n  // * A predicate\n  // * A named node\n  else if (stream->next == '(') {\n    stream_advance(stream);\n    stream_skip_whitespace(stream);\n\n    // If this parenthesis is followed by a node, then it represents a grouped sequence.\n    if (stream->next == '(' || stream->next == '\"' || stream->next == '[') {\n      bool child_is_immediate = is_immediate;\n      CaptureQuantifiers child_capture_quantifiers = capture_quantifiers_new();\n      for (;;) {\n        if (stream->next == '.') {\n          child_is_immediate = true;\n          stream_advance(stream);\n          stream_skip_whitespace(stream);\n        }\n        TSQueryError e = ts_query__parse_pattern(\n          self,\n          stream,\n          depth,\n          child_is_immediate,\n          &child_capture_quantifiers\n        );\n        if (e == PARENT_DONE) {\n          if (stream->next == ')') {\n            stream_advance(stream);\n            break;\n          }\n          e = TSQueryErrorSyntax;\n        }\n        if (e) {\n          capture_quantifiers_delete(&child_capture_quantifiers);\n          return e;\n        }\n\n        capture_quantifiers_add_all(capture_quantifiers, &child_capture_quantifiers);\n        capture_quantifiers_clear(&child_capture_quantifiers);\n        child_is_immediate = false;\n      }\n\n      capture_quantifiers_delete(&child_capture_quantifiers);\n    }\n\n    // A dot/pound character indicates the start of a predicate.\n    else if (stream->next == '.' || stream->next == '#') {\n      stream_advance(stream);\n      return ts_query__parse_predicate(self, stream);\n    }\n\n    // Otherwise, this parenthesis is the start of a named node.\n    else {\n      TSSymbol symbol;\n      bool is_missing = false;\n      const char *node_name = stream->input;\n\n      // Parse a normal node name\n      if (stream_is_ident_start(stream)) {\n        stream_scan_identifier(stream);\n        uint32_t length = (uint32_t)(stream->input - node_name);\n\n        // Parse the wildcard symbol\n        if (length == 1 && node_name[0] == '_') {\n          symbol = WILDCARD_SYMBOL;\n        } else if (!strncmp(node_name, \"MISSING\", length)) {\n          is_missing = true;\n          stream_skip_whitespace(stream);\n\n          if (stream_is_ident_start(stream)) {\n            const char *missing_node_name = stream->input;\n            stream_scan_identifier(stream);\n            uint32_t missing_node_length = (uint32_t)(stream->input - missing_node_name);\n            symbol = ts_language_symbol_for_name(\n              self->language,\n              missing_node_name,\n              missing_node_length,\n              true\n            );\n            if (!symbol) {\n              stream_reset(stream, missing_node_name);\n              return TSQueryErrorNodeType;\n            }\n          }\n\n          else if (stream->next == '\"') {\n            const char *string_start = stream->input;\n            TSQueryError e = ts_query__parse_string_literal(self, stream);\n            if (e) return e;\n\n            symbol = ts_language_symbol_for_name(\n              self->language,\n              self->string_buffer.contents,\n              self->string_buffer.size,\n              false\n            );\n            if (!symbol) {\n              stream_reset(stream, string_start + 1);\n              return TSQueryErrorNodeType;\n            }\n          }\n\n          else if (stream->next == ')') {\n            symbol = WILDCARD_SYMBOL;\n          }\n\n          else {\n            stream_reset(stream, stream->input);\n            return TSQueryErrorSyntax;\n          }\n        }\n\n        else {\n          symbol = ts_language_symbol_for_name(\n            self->language,\n            node_name,\n            length,\n            true\n          );\n          if (!symbol) {\n            stream_reset(stream, node_name);\n            return TSQueryErrorNodeType;\n          }\n        }\n      } else {\n        return TSQueryErrorSyntax;\n      }\n\n      // Add a step for the node.\n      array_push(&self->steps, query_step__new(symbol, depth, is_immediate));\n      QueryStep *step = array_back(&self->steps);\n      if (ts_language_symbol_metadata(self->language, symbol).supertype) {\n        step->supertype_symbol = step->symbol;\n        step->symbol = WILDCARD_SYMBOL;\n      }\n      if (is_missing) {\n        step->is_missing = true;\n      }\n      if (symbol == WILDCARD_SYMBOL) {\n        step->is_named = true;\n      }\n\n      // Parse a supertype symbol\n      if (stream->next == '/') {\n        if (!step->supertype_symbol) {\n          stream_reset(stream, node_name - 1); // reset to the start of the node\n          return TSQueryErrorStructure;\n        }\n\n        stream_advance(stream);\n\n        const char *subtype_node_name = stream->input;\n\n        if (stream_is_ident_start(stream)) { // Named node\n          stream_scan_identifier(stream);\n          uint32_t length = (uint32_t)(stream->input - subtype_node_name);\n          step->symbol = ts_language_symbol_for_name(\n            self->language,\n            subtype_node_name,\n            length,\n            true\n          );\n        } else if (stream->next == '\"') { // Anonymous leaf node\n          TSQueryError e = ts_query__parse_string_literal(self, stream);\n          if (e) return e;\n          step->symbol = ts_language_symbol_for_name(\n            self->language,\n            self->string_buffer.contents,\n            self->string_buffer.size,\n            false\n          );\n        } else {\n          return TSQueryErrorSyntax;\n        }\n\n        if (!step->symbol) {\n          stream_reset(stream, subtype_node_name);\n          return TSQueryErrorNodeType;\n        }\n\n        // Get all the possible subtypes for the given supertype,\n        // and check if the given subtype is valid.\n        if (self->language->abi_version >= LANGUAGE_VERSION_WITH_RESERVED_WORDS) {\n          uint32_t subtype_length;\n          const TSSymbol *subtypes = ts_language_subtypes(\n            self->language,\n            step->supertype_symbol,\n            &subtype_length\n          );\n\n          bool subtype_is_valid = false;\n          for (uint32_t i = 0; i < subtype_length; i++) {\n            if (subtypes[i] == step->symbol) {\n              subtype_is_valid = true;\n              break;\n            }\n          }\n\n          // This subtype is not valid for the given supertype.\n          if (!subtype_is_valid) {\n            stream_reset(stream, node_name - 1); // reset to the start of the node\n            return TSQueryErrorStructure;\n          }\n        }\n      }\n\n      stream_skip_whitespace(stream);\n\n      // Parse the child patterns\n      bool child_is_immediate = false;\n      uint16_t last_child_step_index = 0;\n      uint16_t negated_field_count = 0;\n      TSFieldId negated_field_ids[MAX_NEGATED_FIELD_COUNT];\n      CaptureQuantifiers child_capture_quantifiers = capture_quantifiers_new();\n      for (;;) {\n        // Parse a negated field assertion\n        if (stream->next == '!') {\n          stream_advance(stream);\n          stream_skip_whitespace(stream);\n          if (!stream_is_ident_start(stream)) {\n            capture_quantifiers_delete(&child_capture_quantifiers);\n            return TSQueryErrorSyntax;\n          }\n          const char *field_name = stream->input;\n          stream_scan_identifier(stream);\n          uint32_t length = (uint32_t)(stream->input - field_name);\n          stream_skip_whitespace(stream);\n\n          TSFieldId field_id = ts_language_field_id_for_name(\n            self->language,\n            field_name,\n            length\n          );\n          if (!field_id) {\n            stream->input = field_name;\n            capture_quantifiers_delete(&child_capture_quantifiers);\n            return TSQueryErrorField;\n          }\n\n          // Keep the field ids sorted.\n          if (negated_field_count < MAX_NEGATED_FIELD_COUNT) {\n            negated_field_ids[negated_field_count] = field_id;\n            negated_field_count++;\n          }\n\n          continue;\n        }\n\n        // Parse a sibling anchor\n        if (stream->next == '.') {\n          child_is_immediate = true;\n          stream_advance(stream);\n          stream_skip_whitespace(stream);\n        }\n\n        uint16_t step_index = self->steps.size;\n        TSQueryError e = ts_query__parse_pattern(\n          self,\n          stream,\n          depth + 1,\n          child_is_immediate,\n          &child_capture_quantifiers\n        );\n        // In the event we only parsed a predicate, meaning no new steps were added,\n        // then subtract one so we're not indexing past the end of the array\n        if (step_index == self->steps.size) step_index--;\n        if (e == PARENT_DONE) {\n          if (stream->next == ')') {\n            if (child_is_immediate) {\n              if (last_child_step_index == 0) {\n                capture_quantifiers_delete(&child_capture_quantifiers);\n                return TSQueryErrorSyntax;\n              }\n              // Mark this step *and* its alternatives as the last child of the parent.\n              QueryStep *last_child_step = array_get(&self->steps, last_child_step_index);\n              last_child_step->is_last_child = true;\n              if (\n                last_child_step->alternative_index != NONE &&\n                last_child_step->alternative_index < self->steps.size\n              ) {\n                QueryStep *alternative_step = array_get(&self->steps, last_child_step->alternative_index);\n                alternative_step->is_last_child = true;\n                while (\n                  alternative_step->alternative_index != NONE &&\n                  alternative_step->alternative_index < self->steps.size\n                ) {\n                  alternative_step = array_get(&self->steps, alternative_step->alternative_index);\n                  alternative_step->is_last_child = true;\n                }\n              }\n            }\n\n            if (negated_field_count) {\n              ts_query__add_negated_fields(\n                self,\n                starting_step_index,\n                negated_field_ids,\n                negated_field_count\n              );\n            }\n\n            stream_advance(stream);\n            break;\n          }\n          e = TSQueryErrorSyntax;\n        }\n        if (e) {\n          capture_quantifiers_delete(&child_capture_quantifiers);\n          return e;\n        }\n\n        capture_quantifiers_add_all(capture_quantifiers, &child_capture_quantifiers);\n\n        last_child_step_index = step_index;\n        child_is_immediate = false;\n        capture_quantifiers_clear(&child_capture_quantifiers);\n      }\n      capture_quantifiers_delete(&child_capture_quantifiers);\n    }\n  }\n\n  // Parse a wildcard pattern\n  else if (stream->next == '_') {\n    stream_advance(stream);\n    stream_skip_whitespace(stream);\n\n    // Add a step that matches any kind of node\n    array_push(&self->steps, query_step__new(WILDCARD_SYMBOL, depth, is_immediate));\n  }\n\n  // Parse a double-quoted anonymous leaf node expression\n  else if (stream->next == '\"') {\n    const char *string_start = stream->input;\n    TSQueryError e = ts_query__parse_string_literal(self, stream);\n    if (e) return e;\n\n    // Add a step for the node\n    TSSymbol symbol = ts_language_symbol_for_name(\n      self->language,\n      self->string_buffer.contents,\n      self->string_buffer.size,\n      false\n    );\n    if (!symbol) {\n      stream_reset(stream, string_start + 1);\n      return TSQueryErrorNodeType;\n    }\n    array_push(&self->steps, query_step__new(symbol, depth, is_immediate));\n  }\n\n  // Parse a field-prefixed pattern\n  else if (stream_is_ident_start(stream)) {\n    // Parse the field name\n    const char *field_name = stream->input;\n    stream_scan_identifier(stream);\n    uint32_t length = (uint32_t)(stream->input - field_name);\n    stream_skip_whitespace(stream);\n\n    if (stream->next != ':') {\n      stream_reset(stream, field_name);\n      return TSQueryErrorSyntax;\n    }\n    stream_advance(stream);\n    stream_skip_whitespace(stream);\n\n    // Parse the pattern\n    CaptureQuantifiers field_capture_quantifiers = capture_quantifiers_new();\n    TSQueryError e = ts_query__parse_pattern(\n      self,\n      stream,\n      depth,\n      is_immediate,\n      &field_capture_quantifiers\n    );\n    if (e) {\n      capture_quantifiers_delete(&field_capture_quantifiers);\n      if (e == PARENT_DONE) e = TSQueryErrorSyntax;\n      return e;\n    }\n\n    // Add the field name to the first step of the pattern\n    TSFieldId field_id = ts_language_field_id_for_name(\n      self->language,\n      field_name,\n      length\n    );\n    if (!field_id) {\n      stream->input = field_name;\n      return TSQueryErrorField;\n    }\n\n    uint32_t step_index = starting_step_index;\n    QueryStep *step = array_get(&self->steps, step_index);\n    for (;;) {\n      step->field = field_id;\n      if (\n        step->alternative_index != NONE &&\n        step->alternative_index > step_index &&\n        step->alternative_index < self->steps.size\n      ) {\n        step_index = step->alternative_index;\n        step = array_get(&self->steps, step_index);\n      } else {\n        break;\n      }\n    }\n\n    capture_quantifiers_add_all(capture_quantifiers, &field_capture_quantifiers);\n    capture_quantifiers_delete(&field_capture_quantifiers);\n  }\n\n  else {\n    return TSQueryErrorSyntax;\n  }\n\n  stream_skip_whitespace(stream);\n\n  // Parse suffixes modifiers for this pattern\n  TSQuantifier quantifier = TSQuantifierOne;\n  for (;;) {\n    // Parse the one-or-more operator.\n    if (stream->next == '+') {\n      quantifier = quantifier_join(TSQuantifierOneOrMore, quantifier);\n\n      stream_advance(stream);\n      stream_skip_whitespace(stream);\n    }\n\n    // Parse the zero-or-more repetition operator.\n    else if (stream->next == '*') {\n      quantifier = quantifier_join(TSQuantifierZeroOrMore, quantifier);\n\n      stream_advance(stream);\n      stream_skip_whitespace(stream);\n    }\n\n    // Parse the optional operator.\n    else if (stream->next == '?') {\n      quantifier = quantifier_join(TSQuantifierZeroOrOne, quantifier);\n\n      stream_advance(stream);\n      stream_skip_whitespace(stream);\n    }\n\n    // Parse an '@'-prefixed capture pattern\n    else if (stream->next == '@') {\n      stream_advance(stream);\n      if (!stream_is_ident_start(stream)) return TSQueryErrorSyntax;\n      const char *capture_name = stream->input;\n      stream_scan_identifier(stream);\n      uint32_t length = (uint32_t)(stream->input - capture_name);\n      stream_skip_whitespace(stream);\n\n      // Add the capture id to the first step of the pattern\n      uint16_t capture_id = symbol_table_insert_name(\n        &self->captures,\n        capture_name,\n        length\n      );\n\n      // Add the capture quantifier\n      capture_quantifiers_add_for_id(capture_quantifiers, capture_id, TSQuantifierOne);\n\n      uint32_t step_index = starting_step_index;\n      for (;;) {\n        QueryStep *step = array_get(&self->steps, step_index);\n        query_step__add_capture(step, capture_id);\n        if (\n          step->alternative_index != NONE &&\n          step->alternative_index > step_index &&\n          step->alternative_index < self->steps.size\n        ) {\n          step_index = step->alternative_index;\n        } else {\n          break;\n        }\n      }\n    }\n\n    // No more suffix modifiers\n    else {\n      break;\n    }\n  }\n\n  QueryStep repeat_step;\n  QueryStep *step;\n  switch (quantifier) {\n    case TSQuantifierOneOrMore:\n      repeat_step = query_step__new(WILDCARD_SYMBOL, depth, false);\n      repeat_step.alternative_index = starting_step_index;\n      repeat_step.is_pass_through = true;\n      repeat_step.alternative_is_immediate = true;\n      array_push(&self->steps, repeat_step);\n      break;\n    case TSQuantifierZeroOrMore:\n      repeat_step = query_step__new(WILDCARD_SYMBOL, depth, false);\n      repeat_step.alternative_index = starting_step_index;\n      repeat_step.is_pass_through = true;\n      repeat_step.alternative_is_immediate = true;\n      array_push(&self->steps, repeat_step);\n\n      // Stop when `step->alternative_index` is `NONE` or it points to\n      // `repeat_step` or beyond. Note that having just been pushed,\n      // `repeat_step` occupies slot `self->steps.size - 1`.\n      step = array_get(&self->steps, starting_step_index);\n      while (step->alternative_index != NONE && step->alternative_index < self->steps.size - 1) {\n        step = array_get(&self->steps, step->alternative_index);\n      }\n      step->alternative_index = self->steps.size;\n      break;\n    case TSQuantifierZeroOrOne:\n      step = array_get(&self->steps, starting_step_index);\n      while (step->alternative_index != NONE && step->alternative_index < self->steps.size) {\n        step = array_get(&self->steps, step->alternative_index);\n      }\n      step->alternative_index = self->steps.size;\n      break;\n    default:\n      break;\n  }\n\n  capture_quantifiers_mul(capture_quantifiers, quantifier);\n\n  return 0;\n}\n\nTSQuery *ts_query_new(\n  const TSLanguage *language,\n  const char *source,\n  uint32_t source_len,\n  uint32_t *error_offset,\n  TSQueryError *error_type\n) {\n  if (\n    !language ||\n    language->abi_version > TREE_SITTER_LANGUAGE_VERSION ||\n    language->abi_version < TREE_SITTER_MIN_COMPATIBLE_LANGUAGE_VERSION\n  ) {\n    *error_type = TSQueryErrorLanguage;\n    return NULL;\n  }\n\n  TSQuery *self = ts_malloc(sizeof(TSQuery));\n  *self = (TSQuery) {\n    .steps = array_new(),\n    .pattern_map = array_new(),\n    .captures = symbol_table_new(),\n    .capture_quantifiers = array_new(),\n    .predicate_values = symbol_table_new(),\n    .predicate_steps = array_new(),\n    .patterns = array_new(),\n    .step_offsets = array_new(),\n    .string_buffer = array_new(),\n    .negated_fields = array_new(),\n    .repeat_symbols_with_rootless_patterns = array_new(),\n    .wildcard_root_pattern_count = 0,\n    .language = ts_language_copy(language),\n  };\n\n  array_push(&self->negated_fields, 0);\n\n  // Parse all of the S-expressions in the given string.\n  Stream stream = stream_new(source, source_len);\n  stream_skip_whitespace(&stream);\n  while (stream.input < stream.end) {\n    uint32_t pattern_index = self->patterns.size;\n    uint32_t start_step_index = self->steps.size;\n    uint32_t start_predicate_step_index = self->predicate_steps.size;\n    array_push(&self->patterns, ((QueryPattern) {\n      .steps = (Slice) {.offset = start_step_index},\n      .predicate_steps = (Slice) {.offset = start_predicate_step_index},\n      .start_byte = stream_offset(&stream),\n      .is_non_local = false,\n    }));\n    CaptureQuantifiers capture_quantifiers = capture_quantifiers_new();\n    *error_type = ts_query__parse_pattern(self, &stream, 0, false, &capture_quantifiers);\n    array_push(&self->steps, query_step__new(0, PATTERN_DONE_MARKER, false));\n\n    QueryPattern *pattern = array_back(&self->patterns);\n    pattern->steps.length = self->steps.size - start_step_index;\n    pattern->predicate_steps.length = self->predicate_steps.size - start_predicate_step_index;\n    pattern->end_byte = stream_offset(&stream);\n\n    // If any pattern could not be parsed, then report the error information\n    // and terminate.\n    if (*error_type) {\n      if (*error_type == PARENT_DONE) *error_type = TSQueryErrorSyntax;\n      *error_offset = stream_offset(&stream);\n      capture_quantifiers_delete(&capture_quantifiers);\n      ts_query_delete(self);\n      return NULL;\n    }\n\n    // Maintain a list of capture quantifiers for each pattern\n    array_push(&self->capture_quantifiers, capture_quantifiers);\n\n    // Maintain a map that can look up patterns for a given root symbol.\n    uint16_t wildcard_root_alternative_index = NONE;\n    for (;;) {\n      QueryStep *step = array_get(&self->steps, start_step_index);\n\n      // If a pattern has a wildcard at its root, but it has a non-wildcard child,\n      // then optimize the matching process by skipping matching the wildcard.\n      // Later, during the matching process, the query cursor will check that\n      // there is a parent node, and capture it if necessary.\n      if (step->symbol == WILDCARD_SYMBOL && step->depth == 0 && !step->field) {\n        QueryStep *second_step = array_get(&self->steps, start_step_index + 1);\n        if (second_step->symbol != WILDCARD_SYMBOL && second_step->depth == 1 && !second_step->is_immediate) {\n          wildcard_root_alternative_index = step->alternative_index;\n          start_step_index += 1;\n          step = second_step;\n        }\n      }\n\n      // Determine whether the pattern has a single root node. This affects\n      // decisions about whether or not to start matching the pattern when\n      // a query cursor has a range restriction or when immediately within an\n      // error node.\n      uint32_t start_depth = step->depth;\n      bool is_rooted = start_depth == 0;\n      for (uint32_t step_index = start_step_index + 1; step_index < self->steps.size; step_index++) {\n        QueryStep *child_step = array_get(&self->steps, step_index);\n        if (child_step->is_dead_end) break;\n        if (child_step->depth == start_depth) {\n          is_rooted = false;\n          break;\n        }\n      }\n\n      ts_query__pattern_map_insert(self, step->symbol, (PatternEntry) {\n        .step_index = start_step_index,\n        .pattern_index = pattern_index,\n        .is_rooted = is_rooted\n      });\n      if (step->symbol == WILDCARD_SYMBOL) {\n        self->wildcard_root_pattern_count++;\n      }\n\n      // If there are alternatives or options at the root of the pattern,\n      // then add multiple entries to the pattern map.\n      if (step->alternative_index != NONE) {\n        start_step_index = step->alternative_index;\n      } else if (wildcard_root_alternative_index != NONE) {\n        start_step_index = wildcard_root_alternative_index;\n        wildcard_root_alternative_index = NONE;\n      } else {\n        break;\n      }\n    }\n  }\n\n  if (!ts_query__analyze_patterns(self, error_offset)) {\n    *error_type = TSQueryErrorStructure;\n    ts_query_delete(self);\n    return NULL;\n  }\n\n  array_delete(&self->string_buffer);\n  return self;\n}\n\nvoid ts_query_delete(TSQuery *self) {\n  if (self) {\n    array_delete(&self->steps);\n    array_delete(&self->pattern_map);\n    array_delete(&self->predicate_steps);\n    array_delete(&self->patterns);\n    array_delete(&self->step_offsets);\n    array_delete(&self->string_buffer);\n    array_delete(&self->negated_fields);\n    array_delete(&self->repeat_symbols_with_rootless_patterns);\n    ts_language_delete(self->language);\n    symbol_table_delete(&self->captures);\n    symbol_table_delete(&self->predicate_values);\n    for (uint32_t index = 0; index < self->capture_quantifiers.size; index++) {\n      CaptureQuantifiers *capture_quantifiers = array_get(&self->capture_quantifiers, index);\n      capture_quantifiers_delete(capture_quantifiers);\n    }\n    array_delete(&self->capture_quantifiers);\n    ts_free(self);\n  }\n}\n\nuint32_t ts_query_pattern_count(const TSQuery *self) {\n  return self->patterns.size;\n}\n\nuint32_t ts_query_capture_count(const TSQuery *self) {\n  return self->captures.slices.size;\n}\n\nuint32_t ts_query_string_count(const TSQuery *self) {\n  return self->predicate_values.slices.size;\n}\n\nconst char *ts_query_capture_name_for_id(\n  const TSQuery *self,\n  uint32_t index,\n  uint32_t *length\n) {\n  return symbol_table_name_for_id(&self->captures, index, length);\n}\n\nTSQuantifier ts_query_capture_quantifier_for_id(\n  const TSQuery *self,\n  uint32_t pattern_index,\n  uint32_t capture_index\n) {\n  CaptureQuantifiers *capture_quantifiers = array_get(&self->capture_quantifiers, pattern_index);\n  return capture_quantifier_for_id(capture_quantifiers, capture_index);\n}\n\nconst char *ts_query_string_value_for_id(\n  const TSQuery *self,\n  uint32_t index,\n  uint32_t *length\n) {\n  return symbol_table_name_for_id(&self->predicate_values, index, length);\n}\n\nconst TSQueryPredicateStep *ts_query_predicates_for_pattern(\n  const TSQuery *self,\n  uint32_t pattern_index,\n  uint32_t *step_count\n) {\n  Slice slice = array_get(&self->patterns, pattern_index)->predicate_steps;\n  *step_count = slice.length;\n  if (slice.length == 0) return NULL;\n  return array_get(&self->predicate_steps, slice.offset);\n}\n\nuint32_t ts_query_start_byte_for_pattern(\n  const TSQuery *self,\n  uint32_t pattern_index\n) {\n  return array_get(&self->patterns, pattern_index)->start_byte;\n}\n\nuint32_t ts_query_end_byte_for_pattern(\n  const TSQuery *self,\n  uint32_t pattern_index\n) {\n  return array_get(&self->patterns, pattern_index)->end_byte;\n}\n\nbool ts_query_is_pattern_rooted(\n  const TSQuery *self,\n  uint32_t pattern_index\n) {\n  for (unsigned i = 0; i < self->pattern_map.size; i++) {\n    PatternEntry *entry = array_get(&self->pattern_map, i);\n    if (entry->pattern_index == pattern_index) {\n      if (!entry->is_rooted) return false;\n    }\n  }\n  return true;\n}\n\nbool ts_query_is_pattern_non_local(\n  const TSQuery *self,\n  uint32_t pattern_index\n) {\n  if (pattern_index < self->patterns.size) {\n    return array_get(&self->patterns, pattern_index)->is_non_local;\n  } else {\n    return false;\n  }\n}\n\nbool ts_query_is_pattern_guaranteed_at_step(\n  const TSQuery *self,\n  uint32_t byte_offset\n) {\n  uint32_t step_index = UINT32_MAX;\n  for (unsigned i = 0; i < self->step_offsets.size; i++) {\n    StepOffset *step_offset = array_get(&self->step_offsets, i);\n    if (step_offset->byte_offset > byte_offset) break;\n    step_index = step_offset->step_index;\n  }\n  if (step_index < self->steps.size) {\n    return array_get(&self->steps, step_index)->root_pattern_guaranteed;\n  } else {\n    return false;\n  }\n}\n\nbool ts_query__step_is_fallible(\n  const TSQuery *self,\n  uint16_t step_index\n) {\n  ts_assert((uint32_t)step_index + 1 < self->steps.size);\n  QueryStep *step = array_get(&self->steps, step_index);\n  QueryStep *next_step = array_get(&self->steps, step_index + 1);\n  return (\n    next_step->depth != PATTERN_DONE_MARKER &&\n    next_step->depth > step->depth &&\n    (!next_step->parent_pattern_guaranteed || step->symbol == WILDCARD_SYMBOL)\n  );\n}\n\nvoid ts_query_disable_capture(\n  TSQuery *self,\n  const char *name,\n  uint32_t length\n) {\n  // Remove capture information for any pattern step that previously\n  // captured with the given name.\n  int id = symbol_table_id_for_name(&self->captures, name, length);\n  if (id != -1) {\n    for (unsigned i = 0; i < self->steps.size; i++) {\n      QueryStep *step = array_get(&self->steps, i);\n      query_step__remove_capture(step, id);\n    }\n  }\n}\n\nvoid ts_query_disable_pattern(\n  TSQuery *self,\n  uint32_t pattern_index\n) {\n  // Remove the given pattern from the pattern map. Its steps will still\n  // be in the `steps` array, but they will never be read.\n  for (unsigned i = 0; i < self->pattern_map.size; i++) {\n    PatternEntry *pattern = array_get(&self->pattern_map, i);\n    if (pattern->pattern_index == pattern_index) {\n      array_erase(&self->pattern_map, i);\n      i--;\n    }\n  }\n}\n\n/***************\n * QueryCursor\n ***************/\n\nTSQueryCursor *ts_query_cursor_new(void) {\n  TSQueryCursor *self = ts_malloc(sizeof(TSQueryCursor));\n  *self = (TSQueryCursor) {\n    .did_exceed_match_limit = false,\n    .ascending = false,\n    .halted = false,\n    .states = array_new(),\n    .finished_states = array_new(),\n    .capture_list_pool = capture_list_pool_new(),\n    .included_range = {\n      .start_point = {0, 0},\n      .end_point = POINT_MAX,\n      .start_byte = 0,\n      .end_byte = UINT32_MAX,\n    },\n    .containing_range = {\n      .start_point = {0, 0},\n      .end_point = POINT_MAX,\n      .start_byte = 0,\n      .end_byte = UINT32_MAX,\n    },\n    .max_start_depth = UINT32_MAX,\n    .operation_count = 0,\n  };\n  array_reserve(&self->states, 8);\n  array_reserve(&self->finished_states, 8);\n  return self;\n}\n\nvoid ts_query_cursor_delete(TSQueryCursor *self) {\n  array_delete(&self->states);\n  array_delete(&self->finished_states);\n  ts_tree_cursor_delete(&self->cursor);\n  capture_list_pool_delete(&self->capture_list_pool);\n  ts_free(self);\n}\n\nbool ts_query_cursor_did_exceed_match_limit(const TSQueryCursor *self) {\n  return self->did_exceed_match_limit;\n}\n\nuint32_t ts_query_cursor_match_limit(const TSQueryCursor *self) {\n  return self->capture_list_pool.max_capture_list_count;\n}\n\nvoid ts_query_cursor_set_match_limit(TSQueryCursor *self, uint32_t limit) {\n  self->capture_list_pool.max_capture_list_count = limit;\n}\n\n#ifdef DEBUG_EXECUTE_QUERY\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define LOG(...)\n#endif\n\nvoid ts_query_cursor_exec(\n  TSQueryCursor *self,\n  const TSQuery *query,\n  TSNode node\n) {\n  if (query) {\n    LOG(\"query steps:\\n\");\n    for (unsigned i = 0; i < query->steps.size; i++) {\n      QueryStep *step = array_get(&query->steps, i);\n      LOG(\"  %u: {\", i);\n      if (step->depth == PATTERN_DONE_MARKER) {\n        LOG(\"DONE\");\n      } else if (step->is_dead_end) {\n        LOG(\"dead_end\");\n      } else if (step->is_pass_through) {\n        LOG(\"pass_through\");\n      } else if (step->symbol != WILDCARD_SYMBOL) {\n        LOG(\"symbol: %s\", query->language->symbol_names[step->symbol]);\n      } else {\n        LOG(\"symbol: *\");\n      }\n      if (step->field) {\n        LOG(\", field: %s\", query->language->field_names[step->field]);\n      }\n      if (step->alternative_index != NONE) {\n        LOG(\", alternative: %u\", step->alternative_index);\n      }\n      LOG(\"},\\n\");\n    }\n  }\n\n  array_clear(&self->states);\n  array_clear(&self->finished_states);\n  ts_tree_cursor_reset(&self->cursor, node);\n  capture_list_pool_reset(&self->capture_list_pool);\n  self->on_visible_node = true;\n  self->next_state_id = 0;\n  self->depth = 0;\n  self->ascending = false;\n  self->halted = false;\n  self->query = query;\n  self->did_exceed_match_limit = false;\n  self->operation_count = 0;\n  self->query_options = NULL;\n  self->query_state = (TSQueryCursorState) {0};\n}\n\nvoid ts_query_cursor_exec_with_options(\n  TSQueryCursor *self,\n  const TSQuery *query,\n  TSNode node,\n  const TSQueryCursorOptions *query_options\n) {\n  ts_query_cursor_exec(self, query, node);\n  if (query_options) {\n    self->query_options = query_options;\n    self->query_state = (TSQueryCursorState) {\n      .payload = query_options->payload\n    };\n  }\n}\n\nbool ts_query_cursor_set_byte_range(\n  TSQueryCursor *self,\n  uint32_t start_byte,\n  uint32_t end_byte\n) {\n  if (end_byte == 0) {\n    end_byte = UINT32_MAX;\n  }\n  if (start_byte > end_byte) {\n    return false;\n  }\n  self->included_range.start_byte = start_byte;\n  self->included_range.end_byte = end_byte;\n  return true;\n}\n\nbool ts_query_cursor_set_point_range(\n  TSQueryCursor *self,\n  TSPoint start_point,\n  TSPoint end_point\n) {\n  if (end_point.row == 0 && end_point.column == 0) {\n    end_point = POINT_MAX;\n  }\n  if (point_gt(start_point, end_point)) {\n    return false;\n  }\n  self->included_range.start_point = start_point;\n  self->included_range.end_point = end_point;\n  return true;\n}\n\nbool ts_query_cursor_set_containing_byte_range(\n  TSQueryCursor *self,\n  uint32_t start_byte,\n  uint32_t end_byte\n) {\n  if (end_byte == 0) {\n    end_byte = UINT32_MAX;\n  }\n  if (start_byte > end_byte) {\n    return false;\n  }\n  self->containing_range.start_byte = start_byte;\n  self->containing_range.end_byte = end_byte;\n  return true;\n}\n\nbool ts_query_cursor_set_containing_point_range(\n  TSQueryCursor *self,\n  TSPoint start_point,\n  TSPoint end_point\n) {\n  if (end_point.row == 0 && end_point.column == 0) {\n    end_point = POINT_MAX;\n  }\n  if (point_gt(start_point, end_point)) {\n    return false;\n  }\n  self->containing_range.start_point = start_point;\n  self->containing_range.end_point = end_point;\n  return true;\n}\n\n// Search through all of the in-progress states, and find the captured\n// node that occurs earliest in the document.\nstatic bool ts_query_cursor__first_in_progress_capture(\n  TSQueryCursor *self,\n  uint32_t *state_index,\n  uint32_t *byte_offset,\n  uint32_t *pattern_index,\n  bool *is_definite\n) {\n  bool result = false;\n  *state_index = UINT32_MAX;\n  *byte_offset = UINT32_MAX;\n  *pattern_index = UINT32_MAX;\n  for (unsigned i = 0; i < self->states.size; i++) {\n    QueryState *state = array_get(&self->states, i);\n    if (state->dead) continue;\n\n    const CaptureList *captures = capture_list_pool_get(\n      &self->capture_list_pool,\n      state->capture_list_id\n    );\n    if (state->consumed_capture_count >= captures->size) {\n      continue;\n    }\n\n    TSNode node = array_get(captures, state->consumed_capture_count)->node;\n    if (\n      ts_node_end_byte(node) <= self->included_range.start_byte ||\n      point_lte(ts_node_end_point(node), self->included_range.start_point)\n    ) {\n      state->consumed_capture_count++;\n      i--;\n      continue;\n    }\n\n    uint32_t node_start_byte = ts_node_start_byte(node);\n    if (\n      !result ||\n      node_start_byte < *byte_offset ||\n      (node_start_byte == *byte_offset && state->pattern_index < *pattern_index)\n    ) {\n      QueryStep *step = array_get(&self->query->steps, state->step_index);\n      if (is_definite) {\n        // We're being a bit conservative here by asserting that the following step\n        // is not immediate, because this capture might end up being discarded if the\n        // following symbol in the tree isn't the required symbol for this step.\n        *is_definite = step->root_pattern_guaranteed && !step->is_immediate;\n      } else if (step->root_pattern_guaranteed) {\n        continue;\n      }\n\n      result = true;\n      *state_index = i;\n      *byte_offset = node_start_byte;\n      *pattern_index = state->pattern_index;\n    }\n  }\n  return result;\n}\n\n// Determine which node is first in a depth-first traversal\nint ts_query_cursor__compare_nodes(TSNode left, TSNode right) {\n  if (left.id != right.id) {\n    uint32_t left_start = ts_node_start_byte(left);\n    uint32_t right_start = ts_node_start_byte(right);\n    if (left_start < right_start) return -1;\n    if (left_start > right_start) return 1;\n    uint32_t left_node_count = ts_node_end_byte(left);\n    uint32_t right_node_count = ts_node_end_byte(right);\n    if (left_node_count > right_node_count) return -1;\n    if (left_node_count < right_node_count) return 1;\n  }\n  return 0;\n}\n\n// Determine if either state contains a superset of the other state's captures.\nvoid ts_query_cursor__compare_captures(\n  TSQueryCursor *self,\n  QueryState *left_state,\n  QueryState *right_state,\n  bool *left_contains_right,\n  bool *right_contains_left\n) {\n  const CaptureList *left_captures = capture_list_pool_get(\n    &self->capture_list_pool,\n    left_state->capture_list_id\n  );\n  const CaptureList *right_captures = capture_list_pool_get(\n    &self->capture_list_pool,\n    right_state->capture_list_id\n  );\n  *left_contains_right = true;\n  *right_contains_left = true;\n  unsigned i = 0, j = 0;\n  for (;;) {\n    if (i < left_captures->size) {\n      if (j < right_captures->size) {\n        TSQueryCapture *left = array_get(left_captures, i);\n        TSQueryCapture *right = array_get(right_captures, j);\n        if (left->node.id == right->node.id && left->index == right->index) {\n          i++;\n          j++;\n        } else {\n          switch (ts_query_cursor__compare_nodes(left->node, right->node)) {\n            case -1:\n              *right_contains_left = false;\n              i++;\n              break;\n            case 1:\n              *left_contains_right = false;\n              j++;\n              break;\n            default:\n              *right_contains_left = false;\n              *left_contains_right = false;\n              i++;\n              j++;\n              break;\n          }\n        }\n      } else {\n        *right_contains_left = false;\n        break;\n      }\n    } else {\n      if (j < right_captures->size) {\n        *left_contains_right = false;\n      }\n      break;\n    }\n  }\n}\n\nstatic void ts_query_cursor__add_state(\n  TSQueryCursor *self,\n  const PatternEntry *pattern\n) {\n  QueryStep *step = array_get(&self->query->steps, pattern->step_index);\n  uint32_t start_depth = self->depth - step->depth;\n\n  // Keep the states array in ascending order of start_depth and pattern_index,\n  // so that it can be processed more efficiently elsewhere. Usually, there is\n  // no work to do here because of two facts:\n  // * States with lower start_depth are naturally added first due to the\n  //   order in which nodes are visited.\n  // * Earlier patterns are naturally added first because of the ordering of the\n  //   pattern_map data structure that's used to initiate matches.\n  //\n  // This loop is only needed in cases where two conditions hold:\n  // * A pattern consists of more than one sibling node, so that its states\n  //   remain in progress after exiting the node that started the match.\n  // * The first node in the pattern matches against multiple nodes at the\n  //   same depth.\n  //\n  // An example of this is the pattern '((comment)* (function))'. If multiple\n  // `comment` nodes appear in a row, then we may initiate a new state for this\n  // pattern while another state for the same pattern is already in progress.\n  // If there are multiple patterns like this in a query, then this loop will\n  // need to execute in order to keep the states ordered by pattern_index.\n  uint32_t index = self->states.size;\n  while (index > 0) {\n    QueryState *prev_state = array_get(&self->states, index - 1);\n    if (prev_state->start_depth < start_depth) break;\n    if (prev_state->start_depth == start_depth) {\n      // Avoid inserting an unnecessary duplicate state, which would be\n      // immediately pruned by the longest-match criteria.\n      if (\n        prev_state->pattern_index == pattern->pattern_index &&\n        prev_state->step_index == pattern->step_index\n      ) return;\n      if (prev_state->pattern_index <= pattern->pattern_index) break;\n    }\n    index--;\n  }\n\n  LOG(\n    \"  start state. pattern:%u, step:%u\\n\",\n    pattern->pattern_index,\n    pattern->step_index\n  );\n  array_insert(&self->states, index, ((QueryState) {\n    .id = UINT32_MAX,\n    .capture_list_id = NONE,\n    .step_index = pattern->step_index,\n    .pattern_index = pattern->pattern_index,\n    .start_depth = start_depth,\n    .consumed_capture_count = 0,\n    .seeking_immediate_match = true,\n    .has_in_progress_alternatives = false,\n    .needs_parent = step->depth == 1,\n    .dead = false,\n  }));\n}\n\n// Acquire a capture list for this state. If there are no capture lists left in the\n// pool, this will steal the capture list from another existing state, and mark that\n// other state as 'dead'.\nstatic CaptureList *ts_query_cursor__prepare_to_capture(\n  TSQueryCursor *self,\n  QueryState *state,\n  unsigned state_index_to_preserve\n) {\n  if (state->capture_list_id == NONE) {\n    state->capture_list_id = capture_list_pool_acquire(&self->capture_list_pool);\n\n    // If there are no capture lists left in the pool, then terminate whichever\n    // state has captured the earliest node in the document, and steal its\n    // capture list.\n    if (state->capture_list_id == NONE) {\n      self->did_exceed_match_limit = true;\n      uint32_t state_index, byte_offset, pattern_index;\n      if (\n        ts_query_cursor__first_in_progress_capture(\n          self,\n          &state_index,\n          &byte_offset,\n          &pattern_index,\n          NULL\n        ) &&\n        state_index != state_index_to_preserve\n      ) {\n        LOG(\n          \"  abandon state. index:%u, pattern:%u, offset:%u.\\n\",\n          state_index, pattern_index, byte_offset\n        );\n        QueryState *other_state = array_get(&self->states, state_index);\n        state->capture_list_id = other_state->capture_list_id;\n        other_state->capture_list_id = NONE;\n        other_state->dead = true;\n        CaptureList *list = capture_list_pool_get_mut(\n          &self->capture_list_pool,\n          state->capture_list_id\n        );\n        array_clear(list);\n        return list;\n      } else {\n        LOG(\"  ran out of capture lists\");\n        return NULL;\n      }\n    }\n  }\n  return capture_list_pool_get_mut(&self->capture_list_pool, state->capture_list_id);\n}\n\nstatic void ts_query_cursor__capture(\n  TSQueryCursor *self,\n  QueryState *state,\n  QueryStep *step,\n  TSNode node\n) {\n  if (state->dead) return;\n  CaptureList *capture_list = ts_query_cursor__prepare_to_capture(self, state, UINT32_MAX);\n  if (!capture_list) {\n    state->dead = true;\n    return;\n  }\n\n  for (unsigned j = 0; j < MAX_STEP_CAPTURE_COUNT; j++) {\n    uint16_t capture_id = step->capture_ids[j];\n    if (step->capture_ids[j] == NONE) break;\n    array_push(capture_list, ((TSQueryCapture) { node, capture_id }));\n    LOG(\n      \"  capture node. type:%s, pattern:%u, capture_id:%u, capture_count:%u\\n\",\n      ts_node_type(node),\n      state->pattern_index,\n      capture_id,\n      capture_list->size\n    );\n  }\n}\n\n// Duplicate the given state and insert the newly-created state immediately after\n// the given state in the `states` array. Ensures that the given state reference is\n// still valid, even if the states array is reallocated.\nstatic QueryState *ts_query_cursor__copy_state(\n  TSQueryCursor *self,\n  QueryState **state_ref\n) {\n  const QueryState *state = *state_ref;\n  uint32_t state_index = (uint32_t)(state - self->states.contents);\n  QueryState copy = *state;\n  copy.capture_list_id = NONE;\n\n  // If the state has captures, copy its capture list.\n  if (state->capture_list_id != NONE) {\n    CaptureList *new_captures = ts_query_cursor__prepare_to_capture(self, &copy, state_index);\n    if (!new_captures) return NULL;\n    const CaptureList *old_captures = capture_list_pool_get(\n      &self->capture_list_pool,\n      state->capture_list_id\n    );\n    array_push_all(new_captures, old_captures);\n  }\n\n  array_insert(&self->states, state_index + 1, copy);\n  *state_ref = array_get(&self->states, state_index);\n  return array_get(&self->states, state_index + 1);\n}\n\nstatic inline bool ts_query_cursor__should_descend(\n  TSQueryCursor *self,\n  bool node_intersects_range\n) {\n\n  if (node_intersects_range && self->depth < self->max_start_depth) {\n    return true;\n  }\n\n  // If there are in-progress matches whose remaining steps occur\n  // deeper in the tree, then descend.\n  for (unsigned i = 0; i < self->states.size; i++) {\n    QueryState *state = array_get(&self->states, i);\n    QueryStep *next_step = array_get(&self->query->steps, state->step_index);\n    if (\n      next_step->depth != PATTERN_DONE_MARKER &&\n      state->start_depth + next_step->depth > self->depth\n    ) {\n      return true;\n    }\n  }\n\n  if (self->depth >= self->max_start_depth) {\n    return false;\n  }\n\n  // If the current node is hidden, then a non-rooted pattern might match\n  // one if its roots inside of this node, and match another of its roots\n  // as part of a sibling node, so we may need to descend.\n  if (!self->on_visible_node) {\n    // Descending into a repetition node outside of the range can be\n    // expensive, because these nodes can have many visible children.\n    // Avoid descending into repetition nodes unless we have already\n    // determined that this query can match rootless patterns inside\n    // of this type of repetition node.\n    Subtree subtree = ts_tree_cursor_current_subtree(&self->cursor);\n    if (ts_subtree_is_repetition(subtree)) {\n      bool exists;\n      uint32_t index;\n      array_search_sorted_by(\n        &self->query->repeat_symbols_with_rootless_patterns,,\n        ts_subtree_symbol(subtree),\n        &index,\n        &exists\n      );\n      return exists;\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nbool range_intersects(const TSRange *a, const TSRange *b) {\n  bool is_empty = a->start_byte == a->end_byte;\n  return (\n    (\n      a->end_byte > b->start_byte ||\n      (is_empty && a->end_byte == b->start_byte)\n    ) &&\n    (\n      point_gt(a->end_point, b->start_point) ||\n      (is_empty && point_eq(a->end_point, b->start_point))\n    ) &&\n    a->start_byte < b->end_byte &&\n    point_lt(a->start_point, b->end_point)\n  );\n}\n\nbool range_within(const TSRange *a, const TSRange *b) {\n  return (\n    a->start_byte >= b->start_byte &&\n    point_gte(a->start_point, b->start_point) &&\n    a->end_byte <= b->end_byte &&\n    point_lte(a->end_point, b->end_point)\n  );\n}\n\n// Walk the tree, processing patterns until at least one pattern finishes,\n// If one or more patterns finish, return `true` and store their states in the\n// `finished_states` array. Multiple patterns can finish on the same node. If\n// there are no more matches, return `false`.\nstatic inline bool ts_query_cursor__advance(\n  TSQueryCursor *self,\n  bool stop_on_definite_step\n) {\n  bool did_match = false;\n  for (;;) {\n    if (self->halted) {\n      while (self->states.size > 0) {\n        QueryState state = array_pop(&self->states);\n        capture_list_pool_release(\n          &self->capture_list_pool,\n          state.capture_list_id\n        );\n      }\n    }\n\n    if (++self->operation_count == OP_COUNT_PER_QUERY_CALLBACK_CHECK) {\n      self->operation_count = 0;\n    }\n\n    if (self->query_options && self->query_options->progress_callback) {\n      self->query_state.current_byte_offset = ts_node_start_byte(ts_tree_cursor_current_node(&self->cursor));\n    }\n    if (\n      did_match ||\n      self->halted ||\n      (\n        self->operation_count == 0 &&\n        (\n          (self->query_options && self->query_options->progress_callback && self->query_options->progress_callback(&self->query_state))\n        )\n      )\n    ) {\n      return did_match;\n    }\n\n    // Exit the current node.\n    if (self->ascending) {\n      if (self->on_visible_node) {\n        LOG(\n          \"leave node. depth:%u, type:%s\\n\",\n          self->depth,\n          ts_node_type(ts_tree_cursor_current_node(&self->cursor))\n        );\n\n        // After leaving a node, remove any states that cannot make further progress.\n        uint32_t deleted_count = 0;\n        for (unsigned i = 0, n = self->states.size; i < n; i++) {\n          QueryState *state = array_get(&self->states, i);\n          QueryStep *step = array_get(&self->query->steps, state->step_index);\n\n          // If a state completed its pattern inside of this node, but was deferred from finishing\n          // in order to search for longer matches, mark it as finished.\n          if (\n            step->depth == PATTERN_DONE_MARKER &&\n            (state->start_depth > self->depth || self->depth == 0)\n          ) {\n            LOG(\"  finish pattern %u\\n\", state->pattern_index);\n            array_push(&self->finished_states, *state);\n            did_match = true;\n            deleted_count++;\n          }\n\n          // If a state needed to match something within this node, then remove that state\n          // as it has failed to match.\n          else if (\n            step->depth != PATTERN_DONE_MARKER &&\n            (uint32_t)state->start_depth + (uint32_t)step->depth > self->depth\n          ) {\n            LOG(\n              \"  failed to match. pattern:%u, step:%u\\n\",\n              state->pattern_index,\n              state->step_index\n            );\n            capture_list_pool_release(\n              &self->capture_list_pool,\n              state->capture_list_id\n            );\n            deleted_count++;\n          }\n\n          else if (deleted_count > 0) {\n            *array_get(&self->states, i - deleted_count) = *state;\n          }\n        }\n        self->states.size -= deleted_count;\n      }\n\n      // Leave this node by stepping to its next sibling or to its parent.\n      switch (ts_tree_cursor_goto_next_sibling_internal(&self->cursor)) {\n        case TreeCursorStepVisible:\n          if (!self->on_visible_node) {\n            self->depth++;\n            self->on_visible_node = true;\n          }\n          self->ascending = false;\n          break;\n        case TreeCursorStepHidden:\n          if (self->on_visible_node) {\n            self->depth--;\n            self->on_visible_node = false;\n          }\n          self->ascending = false;\n          break;\n        default:\n          if (ts_tree_cursor_goto_parent(&self->cursor)) {\n            self->depth--;\n          } else {\n            LOG(\"halt at root\\n\");\n            self->halted = true;\n          }\n      }\n    }\n\n    // Enter a new node.\n    else {\n      TSNode node = ts_tree_cursor_current_node(&self->cursor);\n      TSNode parent_node = ts_tree_cursor_parent_node(&self->cursor);\n\n      bool parent_intersects_range =\n        ts_node_is_null(parent_node) ||\n        range_intersects(&(TSRange) {\n          .start_point = ts_node_start_point(parent_node),\n          .end_point = ts_node_end_point(parent_node),\n          .start_byte = ts_node_start_byte(parent_node),\n          .end_byte = ts_node_end_byte(parent_node),\n        }, &self->included_range);\n      TSRange node_range = (TSRange) {\n        .start_point = ts_node_start_point(node),\n        .end_point = ts_node_end_point(node),\n        .start_byte = ts_node_start_byte(node),\n        .end_byte = ts_node_end_byte(node),\n      };\n      bool node_intersects_range =\n        parent_intersects_range && range_intersects(&node_range, &self->included_range);\n      bool node_intersects_containing_range =\n        range_intersects(&node_range, &self->containing_range);\n      bool node_within_containing_range =\n        range_within(&node_range, &self->containing_range);\n\n      if (node_within_containing_range && self->on_visible_node) {\n        TSSymbol symbol = ts_node_symbol(node);\n        bool is_named = ts_node_is_named(node);\n        bool is_missing = ts_node_is_missing(node);\n        bool has_later_siblings;\n        bool has_later_named_siblings;\n        bool can_have_later_siblings_with_this_field;\n        TSFieldId field_id = 0;\n        TSSymbol supertypes[8] = {0};\n        unsigned supertype_count = 8;\n        ts_tree_cursor_current_status(\n          &self->cursor,\n          &field_id,\n          &has_later_siblings,\n          &has_later_named_siblings,\n          &can_have_later_siblings_with_this_field,\n          supertypes,\n          &supertype_count\n        );\n        LOG(\n          \"enter node. depth:%u, type:%s, field:%s, row:%u state_count:%u, finished_state_count:%u\\n\",\n          self->depth,\n          ts_node_type(node),\n          ts_language_field_name_for_id(self->query->language, field_id),\n          ts_node_start_point(node).row,\n          self->states.size,\n          self->finished_states.size\n        );\n\n        bool node_is_error = symbol == ts_builtin_sym_error;\n        bool parent_is_error =\n          !ts_node_is_null(parent_node) &&\n          ts_node_symbol(parent_node) == ts_builtin_sym_error;\n\n        // Add new states for any patterns whose root node is a wildcard.\n        if (!node_is_error) {\n          for (unsigned i = 0; i < self->query->wildcard_root_pattern_count; i++) {\n            PatternEntry *pattern = array_get(&self->query->pattern_map, i);\n\n            // If this node matches the first step of the pattern, then add a new\n            // state at the start of this pattern.\n            QueryStep *step = array_get(&self->query->steps, pattern->step_index);\n            uint32_t start_depth = self->depth - step->depth;\n            if (\n              (pattern->is_rooted ?\n                node_intersects_range :\n                (parent_intersects_range && !parent_is_error)) &&\n              (!step->field || field_id == step->field) &&\n              (!step->supertype_symbol || supertype_count > 0) &&\n              (start_depth <= self->max_start_depth)\n            ) {\n              ts_query_cursor__add_state(self, pattern);\n            }\n          }\n        }\n\n        // Add new states for any patterns whose root node matches this node.\n        unsigned i;\n        if (ts_query__pattern_map_search(self->query, symbol, &i)) {\n          PatternEntry *pattern = array_get(&self->query->pattern_map, i);\n\n          QueryStep *step = array_get(&self->query->steps, pattern->step_index);\n          uint32_t start_depth = self->depth - step->depth;\n          do {\n            // If this node matches the first step of the pattern, then add a new\n            // state at the start of this pattern.\n            if (\n              (pattern->is_rooted ?\n                node_intersects_range :\n                (parent_intersects_range && !parent_is_error)) &&\n              (!step->field || field_id == step->field) &&\n              (start_depth <= self->max_start_depth)\n            ) {\n              ts_query_cursor__add_state(self, pattern);\n            }\n\n            // Advance to the next pattern whose root node matches this node.\n            i++;\n            if (i == self->query->pattern_map.size) break;\n            pattern = array_get(&self->query->pattern_map, i);\n            step = array_get(&self->query->steps, pattern->step_index);\n          } while (step->symbol == symbol);\n        }\n\n        // Update all of the in-progress states with current node.\n        for (unsigned j = 0, copy_count = 0; j < self->states.size; j += 1 + copy_count) {\n          QueryState *state = array_get(&self->states, j);\n          QueryStep *step = array_get(&self->query->steps, state->step_index);\n          state->has_in_progress_alternatives = false;\n          copy_count = 0;\n\n          // Check that the node matches all of the criteria for the next\n          // step of the pattern.\n          if ((uint32_t)state->start_depth + (uint32_t)step->depth != self->depth) continue;\n\n          // Determine if this node matches this step of the pattern, and also\n          // if this node can have later siblings that match this step of the\n          // pattern.\n          bool node_does_match = false;\n          if (step->symbol == WILDCARD_SYMBOL) {\n            if (step->is_missing) {\n              node_does_match = is_missing;\n            } else {\n              node_does_match = !node_is_error && (is_named || !step->is_named);\n            }\n          } else {\n            node_does_match = symbol == step->symbol && (!step->is_missing || is_missing);\n          }\n          bool later_sibling_can_match = has_later_siblings;\n          if ((step->is_immediate && is_named) || state->seeking_immediate_match) {\n            later_sibling_can_match = false;\n          }\n          if (step->is_last_child && has_later_named_siblings) {\n            node_does_match = false;\n          }\n          if (step->supertype_symbol) {\n            bool has_supertype = false;\n            for (unsigned k = 0; k < supertype_count; k++) {\n              if (supertypes[k] == step->supertype_symbol) {\n                has_supertype = true;\n                break;\n              }\n            }\n            if (!has_supertype) node_does_match = false;\n          }\n          if (step->field) {\n            if (step->field == field_id) {\n              if (!can_have_later_siblings_with_this_field) {\n                later_sibling_can_match = false;\n              }\n            } else {\n              node_does_match = false;\n            }\n          }\n\n          if (step->negated_field_list_id) {\n            TSFieldId *negated_field_ids = array_get(&self->query->negated_fields, step->negated_field_list_id);\n            for (;;) {\n              TSFieldId negated_field_id = *negated_field_ids;\n              if (negated_field_id) {\n                negated_field_ids++;\n                if (ts_node_child_by_field_id(node, negated_field_id).id) {\n                  node_does_match = false;\n                  break;\n                }\n              } else {\n                break;\n              }\n            }\n          }\n\n          // Remove states immediately if it is ever clear that they cannot match.\n          if (!node_does_match) {\n            if (!later_sibling_can_match) {\n              LOG(\n                \"  discard state. pattern:%u, step:%u\\n\",\n                state->pattern_index,\n                state->step_index\n              );\n              capture_list_pool_release(\n                &self->capture_list_pool,\n                state->capture_list_id\n              );\n              array_erase(&self->states, j);\n              j--;\n            }\n            continue;\n          }\n\n          // Some patterns can match their root node in multiple ways, capturing different\n          // children. If this pattern step could match later children within the same\n          // parent, then this query state cannot simply be updated in place. It must be\n          // split into two states: one that matches this node, and one which skips over\n          // this node, to preserve the possibility of matching later siblings.\n          if (later_sibling_can_match && (\n            step->contains_captures ||\n            ts_query__step_is_fallible(self->query, state->step_index)\n          )) {\n            if (ts_query_cursor__copy_state(self, &state)) {\n              LOG(\n                \"  split state for capture. pattern:%u, step:%u\\n\",\n                state->pattern_index,\n                state->step_index\n              );\n              copy_count++;\n            }\n          }\n\n          // If this pattern started with a wildcard, such that the pattern map\n          // actually points to the *second* step of the pattern, then check\n          // that the node has a parent, and capture the parent node if necessary.\n          if (state->needs_parent) {\n            TSNode parent = ts_tree_cursor_parent_node(&self->cursor);\n            if (ts_node_is_null(parent)) {\n              LOG(\"  missing parent node\\n\");\n              state->dead = true;\n            } else {\n              state->needs_parent = false;\n              QueryStep *skipped_wildcard_step = step;\n              do {\n                skipped_wildcard_step--;\n              } while (\n                skipped_wildcard_step->is_dead_end ||\n                skipped_wildcard_step->is_pass_through ||\n                skipped_wildcard_step->depth > 0\n              );\n              if (skipped_wildcard_step->capture_ids[0] != NONE) {\n                LOG(\"  capture wildcard parent\\n\");\n                ts_query_cursor__capture(\n                  self,\n                  state,\n                  skipped_wildcard_step,\n                  parent\n                );\n              }\n            }\n          }\n\n          // If the current node is captured in this pattern, add it to the capture list.\n          if (step->capture_ids[0] != NONE) {\n            ts_query_cursor__capture(self, state, step, node);\n          }\n\n          if (state->dead) {\n            array_erase(&self->states, j);\n            j--;\n            continue;\n          }\n\n          // Advance this state to the next step of its pattern.\n          state->step_index++;\n          LOG(\n            \"  advance state. pattern:%u, step:%u\\n\",\n            state->pattern_index,\n            state->step_index\n          );\n\n          QueryStep *next_step = array_get(&self->query->steps, state->step_index);\n\n          // For a given step, if the current symbol is the wildcard symbol, `_`, and it is **not**\n          // named, meaning it should capture anonymous nodes, **and** the next step is immediate,\n          // we reuse the `seeking_immediate_match` flag to indicate that we are looking for an\n          // immediate match due to an unnamed wildcard symbol.\n          //\n          // The reason for this is that typically, anchors will not consider anonymous nodes,\n          // but we're special casing the wildcard symbol to allow for any immediate matches,\n          // regardless of whether they are named or not.\n          if (step->symbol == WILDCARD_SYMBOL && !step->is_named && next_step->is_immediate) {\n              state->seeking_immediate_match = true;\n          } else {\n              state->seeking_immediate_match = false;\n          }\n\n          if (stop_on_definite_step && next_step->root_pattern_guaranteed) did_match = true;\n\n          // If this state's next step has an alternative step, then copy the state in order\n          // to pursue both alternatives. The alternative step itself may have an alternative,\n          // so this is an interactive process.\n          unsigned end_index = j + 1;\n          for (unsigned k = j; k < end_index; k++) {\n            QueryState *child_state = array_get(&self->states, k);\n            QueryStep *child_step = array_get(&self->query->steps, child_state->step_index);\n            if (child_step->alternative_index != NONE) {\n              // A \"dead-end\" step exists only to add a non-sequential jump into the step sequence,\n              // via its alternative index. When a state reaches a dead-end step, it jumps straight\n              // to the step's alternative.\n              if (child_step->is_dead_end) {\n                child_state->step_index = child_step->alternative_index;\n                k--;\n                continue;\n              }\n\n              // A \"pass-through\" step exists only to add a branch into the step sequence,\n              // via its alternative_index. When a state reaches a pass-through step, it splits\n              // in order to process the alternative step, and then it advances to the next step.\n              if (child_step->is_pass_through) {\n                child_state->step_index++;\n                k--;\n              }\n\n              QueryState *copy = ts_query_cursor__copy_state(self, &child_state);\n              if (copy) {\n                LOG(\n                  \"  split state for branch. pattern:%u, from_step:%u, to_step:%u, immediate:%d, capture_count: %u\\n\",\n                  copy->pattern_index,\n                  copy->step_index,\n                  next_step->alternative_index,\n                  next_step->alternative_is_immediate,\n                  capture_list_pool_get(&self->capture_list_pool, copy->capture_list_id)->size\n                );\n                end_index++;\n                copy_count++;\n                copy->step_index = child_step->alternative_index;\n                if (child_step->alternative_is_immediate) {\n                  copy->seeking_immediate_match = true;\n                }\n              }\n            }\n          }\n        }\n\n        for (unsigned j = 0; j < self->states.size; j++) {\n          QueryState *state = array_get(&self->states, j);\n          if (state->dead) {\n            array_erase(&self->states, j);\n            j--;\n            continue;\n          }\n\n          // Enforce the longest-match criteria. When a query pattern contains optional or\n          // repeated nodes, this is necessary to avoid multiple redundant states, where\n          // one state has a strict subset of another state's captures.\n          bool did_remove = false;\n          for (unsigned k = j + 1; k < self->states.size; k++) {\n            QueryState *other_state = array_get(&self->states, k);\n\n            // Query states are kept in ascending order of start_depth and pattern_index.\n            // Since the longest-match criteria is only used for deduping matches of the same\n            // pattern and root node, we only need to perform pairwise comparisons within a\n            // small slice of the states array.\n            if (\n              other_state->start_depth != state->start_depth ||\n              other_state->pattern_index != state->pattern_index\n            ) break;\n\n            bool left_contains_right, right_contains_left;\n            ts_query_cursor__compare_captures(\n              self,\n              state,\n              other_state,\n              &left_contains_right,\n              &right_contains_left\n            );\n            if (left_contains_right) {\n              if (state->step_index == other_state->step_index) {\n                LOG(\n                  \"  drop shorter state. pattern: %u, step_index: %u\\n\",\n                  state->pattern_index,\n                  state->step_index\n                );\n                capture_list_pool_release(&self->capture_list_pool, other_state->capture_list_id);\n                array_erase(&self->states, k);\n                k--;\n                continue;\n              }\n              other_state->has_in_progress_alternatives = true;\n            }\n            if (right_contains_left) {\n              if (state->step_index == other_state->step_index) {\n                LOG(\n                  \"  drop shorter state. pattern: %u, step_index: %u\\n\",\n                  state->pattern_index,\n                  state->step_index\n                );\n                capture_list_pool_release(&self->capture_list_pool, state->capture_list_id);\n                array_erase(&self->states, j);\n                j--;\n                did_remove = true;\n                break;\n              }\n              state->has_in_progress_alternatives = true;\n            }\n          }\n\n          // If the state is at the end of its pattern, remove it from the list\n          // of in-progress states and add it to the list of finished states.\n          if (!did_remove) {\n            LOG(\n              \"  keep state. pattern: %u, start_depth: %u, step_index: %u, capture_count: %u\\n\",\n              state->pattern_index,\n              state->start_depth,\n              state->step_index,\n              capture_list_pool_get(&self->capture_list_pool, state->capture_list_id)->size\n            );\n            QueryStep *next_step = array_get(&self->query->steps, state->step_index);\n            if (next_step->depth == PATTERN_DONE_MARKER) {\n              if (state->has_in_progress_alternatives) {\n                LOG(\"  defer finishing pattern %u\\n\", state->pattern_index);\n              } else {\n                LOG(\"  finish pattern %u\\n\", state->pattern_index);\n                array_push(&self->finished_states, *state);\n                array_erase(&self->states, (uint32_t)(state - self->states.contents));\n                did_match = true;\n                j--;\n              }\n            }\n          }\n        }\n      }\n\n      if (node_intersects_containing_range && ts_query_cursor__should_descend(self, node_intersects_range)) {\n        switch (ts_tree_cursor_goto_first_child_internal(&self->cursor)) {\n          case TreeCursorStepVisible:\n            self->depth++;\n            self->on_visible_node = true;\n            continue;\n          case TreeCursorStepHidden:\n            self->on_visible_node = false;\n            continue;\n          default:\n            break;\n        }\n      }\n\n      self->ascending = true;\n    }\n  }\n}\n\nbool ts_query_cursor_next_match(\n  TSQueryCursor *self,\n  TSQueryMatch *match\n) {\n  if (self->finished_states.size == 0) {\n    if (!ts_query_cursor__advance(self, false)) {\n      return false;\n    }\n  }\n\n  QueryState *state = array_get(&self->finished_states, 0);\n  if (state->id == UINT32_MAX) state->id = self->next_state_id++;\n  match->id = state->id;\n  match->pattern_index = state->pattern_index;\n  const CaptureList *captures = capture_list_pool_get(\n    &self->capture_list_pool,\n    state->capture_list_id\n  );\n  match->captures = captures->contents;\n  match->capture_count = captures->size;\n  capture_list_pool_release(&self->capture_list_pool, state->capture_list_id);\n  array_erase(&self->finished_states, 0);\n  return true;\n}\n\nvoid ts_query_cursor_remove_match(\n  TSQueryCursor *self,\n  uint32_t match_id\n) {\n  for (unsigned i = 0; i < self->finished_states.size; i++) {\n    const QueryState *state = array_get(&self->finished_states, i);\n    if (state->id == match_id) {\n      capture_list_pool_release(\n        &self->capture_list_pool,\n        state->capture_list_id\n      );\n      array_erase(&self->finished_states, i);\n      return;\n    }\n  }\n\n  // Remove unfinished query states as well to prevent future\n  // captures for a match being removed.\n  for (unsigned i = 0; i < self->states.size; i++) {\n    const QueryState *state = array_get(&self->states, i);\n    if (state->id == match_id) {\n      capture_list_pool_release(\n        &self->capture_list_pool,\n        state->capture_list_id\n      );\n      array_erase(&self->states, i);\n      return;\n    }\n  }\n}\n\nbool ts_query_cursor_next_capture(\n  TSQueryCursor *self,\n  TSQueryMatch *match,\n  uint32_t *capture_index\n) {\n  // The goal here is to return captures in order, even though they may not\n  // be discovered in order, because patterns can overlap. Search for matches\n  // until there is a finished capture that is before any unfinished capture.\n  for (;;) {\n    // First, find the earliest capture in an unfinished match.\n    uint32_t first_unfinished_capture_byte;\n    uint32_t first_unfinished_pattern_index;\n    uint32_t first_unfinished_state_index;\n    bool first_unfinished_state_is_definite = false;\n    bool found_unfinished_state = ts_query_cursor__first_in_progress_capture(\n      self,\n      &first_unfinished_state_index,\n      &first_unfinished_capture_byte,\n      &first_unfinished_pattern_index,\n      &first_unfinished_state_is_definite\n    );\n\n    // Then find the earliest capture in a finished match. It must occur\n    // before the first capture in an *unfinished* match.\n    QueryState *first_finished_state = NULL;\n    uint32_t first_finished_capture_byte = first_unfinished_capture_byte;\n    uint32_t first_finished_pattern_index = first_unfinished_pattern_index;\n    for (unsigned i = 0; i < self->finished_states.size;) {\n      QueryState *state = array_get(&self->finished_states, i);\n      const CaptureList *captures = capture_list_pool_get(\n        &self->capture_list_pool,\n        state->capture_list_id\n      );\n\n      // Remove states whose captures are all consumed.\n      if (state->consumed_capture_count >= captures->size) {\n        capture_list_pool_release(\n          &self->capture_list_pool,\n          state->capture_list_id\n        );\n        array_erase(&self->finished_states, i);\n        continue;\n      }\n\n      TSNode node = array_get(captures, state->consumed_capture_count)->node;\n\n      bool node_precedes_range = (\n        ts_node_end_byte(node) <= self->included_range.start_byte ||\n        point_lte(ts_node_end_point(node), self->included_range.start_point)\n      );\n      bool node_follows_range = (\n        ts_node_start_byte(node) >= self->included_range.end_byte ||\n        point_gte(ts_node_start_point(node), self->included_range.end_point)\n      );\n      bool node_outside_of_range = node_precedes_range || node_follows_range;\n\n      // Skip captures that are outside of the cursor's range.\n      if (node_outside_of_range) {\n        state->consumed_capture_count++;\n        continue;\n      }\n\n      uint32_t node_start_byte = ts_node_start_byte(node);\n      if (\n        node_start_byte < first_finished_capture_byte ||\n        (\n          node_start_byte == first_finished_capture_byte &&\n          state->pattern_index < first_finished_pattern_index\n        )\n      ) {\n        first_finished_state = state;\n        first_finished_capture_byte = node_start_byte;\n        first_finished_pattern_index = state->pattern_index;\n      }\n      i++;\n    }\n\n    // If there is finished capture that is clearly before any unfinished\n    // capture, then return its match, and its capture index. Internally\n    // record the fact that the capture has been 'consumed'.\n    QueryState *state;\n    if (first_finished_state) {\n      state = first_finished_state;\n    } else if (first_unfinished_state_is_definite) {\n      state = array_get(&self->states, first_unfinished_state_index);\n    } else {\n      state = NULL;\n    }\n\n    if (state) {\n      if (state->id == UINT32_MAX) state->id = self->next_state_id++;\n      match->id = state->id;\n      match->pattern_index = state->pattern_index;\n      const CaptureList *captures = capture_list_pool_get(\n        &self->capture_list_pool,\n        state->capture_list_id\n      );\n      match->captures = captures->contents;\n      match->capture_count = captures->size;\n      *capture_index = state->consumed_capture_count;\n      state->consumed_capture_count++;\n      return true;\n    }\n\n    if (capture_list_pool_is_empty(&self->capture_list_pool) && found_unfinished_state) {\n      LOG(\n        \"  abandon state. index:%u, pattern:%u, offset:%u.\\n\",\n        first_unfinished_state_index,\n        first_unfinished_pattern_index,\n        first_unfinished_capture_byte\n      );\n      capture_list_pool_release(\n        &self->capture_list_pool,\n        array_get(&self->states, first_unfinished_state_index)->capture_list_id\n      );\n      array_erase(&self->states, first_unfinished_state_index);\n    }\n\n    // If there are no finished matches that are ready to be returned, then\n    // continue finding more matches.\n    if (\n      !ts_query_cursor__advance(self, true) &&\n      self->finished_states.size == 0\n    ) return false;\n  }\n}\n\nvoid ts_query_cursor_set_max_start_depth(\n  TSQueryCursor *self,\n  uint32_t max_start_depth\n) {\n  self->max_start_depth = max_start_depth;\n}\n\n#undef LOG\n",
    "#include \"tree_sitter/api.h\"\n#include \"./tree_cursor.h\"\n#include \"./language.h\"\n#include \"./tree.h\"\n\ntypedef struct {\n  Subtree parent;\n  const TSTree *tree;\n  Length position;\n  uint32_t child_index;\n  uint32_t structural_child_index;\n  uint32_t descendant_index;\n  const TSSymbol *alias_sequence;\n} CursorChildIterator;\n\n// CursorChildIterator\n\nstatic inline bool ts_tree_cursor_is_entry_visible(const TreeCursor *self, uint32_t index) {\n  TreeCursorEntry *entry = array_get(&self->stack, index);\n  if (index == 0 || ts_subtree_visible(*entry->subtree)) {\n    return true;\n  } else if (!ts_subtree_extra(*entry->subtree)) {\n    TreeCursorEntry *parent_entry = array_get(&self->stack, index - 1);\n    return ts_language_alias_at(\n      self->tree->language,\n      parent_entry->subtree->ptr->production_id,\n      entry->structural_child_index\n    );\n  } else {\n    return false;\n  }\n}\n\nstatic inline CursorChildIterator ts_tree_cursor_iterate_children(const TreeCursor *self) {\n  TreeCursorEntry *last_entry = array_back(&self->stack);\n  if (ts_subtree_child_count(*last_entry->subtree) == 0) {\n    return (CursorChildIterator) {NULL_SUBTREE, self->tree, length_zero(), 0, 0, 0, NULL};\n  }\n  const TSSymbol *alias_sequence = ts_language_alias_sequence(\n    self->tree->language,\n    last_entry->subtree->ptr->production_id\n  );\n\n  uint32_t descendant_index = last_entry->descendant_index;\n  if (ts_tree_cursor_is_entry_visible(self, self->stack.size - 1)) {\n    descendant_index += 1;\n  }\n\n  return (CursorChildIterator) {\n    .tree = self->tree,\n    .parent = *last_entry->subtree,\n    .position = last_entry->position,\n    .child_index = 0,\n    .structural_child_index = 0,\n    .descendant_index = descendant_index,\n    .alias_sequence = alias_sequence,\n  };\n}\n\nstatic inline bool ts_tree_cursor_child_iterator_next(\n  CursorChildIterator *self,\n  TreeCursorEntry *result,\n  bool *visible\n) {\n  if (!self->parent.ptr || self->child_index == self->parent.ptr->child_count) return false;\n  const Subtree *child = &ts_subtree_children(self->parent)[self->child_index];\n  *result = (TreeCursorEntry) {\n    .subtree = child,\n    .position = self->position,\n    .child_index = self->child_index,\n    .structural_child_index = self->structural_child_index,\n    .descendant_index = self->descendant_index,\n  };\n  *visible = ts_subtree_visible(*child);\n  bool extra = ts_subtree_extra(*child);\n  if (!extra) {\n    if (self->alias_sequence) {\n      *visible |= self->alias_sequence[self->structural_child_index];\n    }\n    self->structural_child_index++;\n  }\n\n  self->descendant_index += ts_subtree_visible_descendant_count(*child);\n  if (*visible) {\n    self->descendant_index += 1;\n  }\n\n  self->position = length_add(self->position, ts_subtree_size(*child));\n  self->child_index++;\n\n  if (self->child_index < self->parent.ptr->child_count) {\n    Subtree next_child = ts_subtree_children(self->parent)[self->child_index];\n    self->position = length_add(self->position, ts_subtree_padding(next_child));\n  }\n\n  return true;\n}\n\n// Return a position that, when `b` is added to it, yields `a`. This\n// can only be computed if `b` has zero rows. Otherwise, this function\n// returns `LENGTH_UNDEFINED`, and the caller needs to recompute\n// the position some other way.\nstatic inline Length length_backtrack(Length a, Length b) {\n  if (length_is_undefined(a) || b.extent.row != 0) {\n    return LENGTH_UNDEFINED;\n  }\n\n  Length result;\n  result.bytes = a.bytes - b.bytes;\n  result.extent.row = a.extent.row;\n  result.extent.column = a.extent.column - b.extent.column;\n  return result;\n}\n\nstatic inline bool ts_tree_cursor_child_iterator_previous(\n  CursorChildIterator *self,\n  TreeCursorEntry *result,\n  bool *visible\n) {\n  // this is mostly a reverse `ts_tree_cursor_child_iterator_next` taking into\n  // account unsigned underflow\n  if (!self->parent.ptr || (int8_t)self->child_index == -1) return false;\n  const Subtree *child = &ts_subtree_children(self->parent)[self->child_index];\n  *result = (TreeCursorEntry) {\n    .subtree = child,\n    .position = self->position,\n    .child_index = self->child_index,\n    .structural_child_index = self->structural_child_index,\n  };\n  *visible = ts_subtree_visible(*child);\n  bool extra = ts_subtree_extra(*child);\n\n  self->position = length_backtrack(self->position, ts_subtree_padding(*child));\n  self->child_index--;\n\n  if (!extra && self->alias_sequence) {\n    *visible |= self->alias_sequence[self->structural_child_index];\n    if (self->structural_child_index > 0) {\n      self->structural_child_index--;\n    }\n  }\n\n  // unsigned can underflow so compare it to child_count\n  if (self->child_index < self->parent.ptr->child_count) {\n    Subtree previous_child = ts_subtree_children(self->parent)[self->child_index];\n    Length size = ts_subtree_size(previous_child);\n    self->position = length_backtrack(self->position, size);\n  }\n\n  return true;\n}\n\n// TSTreeCursor - lifecycle\n\nTSTreeCursor ts_tree_cursor_new(TSNode node) {\n  TSTreeCursor self = {NULL, NULL, {0, 0, 0}};\n  ts_tree_cursor_init((TreeCursor *)&self, node);\n  return self;\n}\n\nvoid ts_tree_cursor_reset(TSTreeCursor *_self, TSNode node) {\n  ts_tree_cursor_init((TreeCursor *)_self, node);\n}\n\nvoid ts_tree_cursor_init(TreeCursor *self, TSNode node) {\n  self->tree = node.tree;\n  self->root_alias_symbol = node.context[3];\n  array_clear(&self->stack);\n  array_push(&self->stack, ((TreeCursorEntry) {\n    .subtree = (const Subtree *)node.id,\n    .position = {\n      ts_node_start_byte(node),\n      ts_node_start_point(node)\n    },\n    .child_index = 0,\n    .structural_child_index = 0,\n    .descendant_index = 0,\n  }));\n}\n\nvoid ts_tree_cursor_delete(TSTreeCursor *_self) {\n  TreeCursor *self = (TreeCursor *)_self;\n  array_delete(&self->stack);\n}\n\n// TSTreeCursor - walking the tree\n\nTreeCursorStep ts_tree_cursor_goto_first_child_internal(TSTreeCursor *_self) {\n  TreeCursor *self = (TreeCursor *)_self;\n  bool visible;\n  TreeCursorEntry entry;\n  CursorChildIterator iterator = ts_tree_cursor_iterate_children(self);\n  while (ts_tree_cursor_child_iterator_next(&iterator, &entry, &visible)) {\n    if (visible) {\n      array_push(&self->stack, entry);\n      return TreeCursorStepVisible;\n    }\n    if (ts_subtree_visible_child_count(*entry.subtree) > 0) {\n      array_push(&self->stack, entry);\n      return TreeCursorStepHidden;\n    }\n  }\n  return TreeCursorStepNone;\n}\n\nbool ts_tree_cursor_goto_first_child(TSTreeCursor *self) {\n  for (;;) {\n    switch (ts_tree_cursor_goto_first_child_internal(self)) {\n      case TreeCursorStepHidden:\n        continue;\n      case TreeCursorStepVisible:\n        return true;\n      default:\n        return false;\n    }\n  }\n}\n\nTreeCursorStep ts_tree_cursor_goto_last_child_internal(TSTreeCursor *_self) {\n  TreeCursor *self = (TreeCursor *)_self;\n  bool visible;\n  TreeCursorEntry entry;\n  CursorChildIterator iterator = ts_tree_cursor_iterate_children(self);\n  if (!iterator.parent.ptr || iterator.parent.ptr->child_count == 0) return TreeCursorStepNone;\n\n  TreeCursorEntry last_entry = {0};\n  TreeCursorStep last_step = TreeCursorStepNone;\n  while (ts_tree_cursor_child_iterator_next(&iterator, &entry, &visible)) {\n    if (visible) {\n      last_entry = entry;\n      last_step = TreeCursorStepVisible;\n    }\n    else if (ts_subtree_visible_child_count(*entry.subtree) > 0) {\n      last_entry = entry;\n      last_step = TreeCursorStepHidden;\n    }\n  }\n  if (last_entry.subtree) {\n    array_push(&self->stack, last_entry);\n    return last_step;\n  }\n\n  return TreeCursorStepNone;\n}\n\nbool ts_tree_cursor_goto_last_child(TSTreeCursor *self) {\n  for (;;) {\n    switch (ts_tree_cursor_goto_last_child_internal(self)) {\n      case TreeCursorStepHidden:\n        continue;\n      case TreeCursorStepVisible:\n        return true;\n      default:\n        return false;\n    }\n  }\n}\n\nstatic inline int64_t ts_tree_cursor_goto_first_child_for_byte_and_point(\n  TSTreeCursor *_self,\n  uint32_t goal_byte,\n  TSPoint goal_point\n) {\n  TreeCursor *self = (TreeCursor *)_self;\n  uint32_t initial_size = self->stack.size;\n  uint32_t visible_child_index = 0;\n\n  bool did_descend;\n  do {\n    did_descend = false;\n\n    bool visible;\n    TreeCursorEntry entry;\n    CursorChildIterator iterator = ts_tree_cursor_iterate_children(self);\n    while (ts_tree_cursor_child_iterator_next(&iterator, &entry, &visible)) {\n      Length entry_end = length_add(entry.position, ts_subtree_size(*entry.subtree));\n      bool at_goal = entry_end.bytes > goal_byte && point_gt(entry_end.extent, goal_point);\n      uint32_t visible_child_count = ts_subtree_visible_child_count(*entry.subtree);\n      if (at_goal) {\n        if (visible) {\n          array_push(&self->stack, entry);\n          return visible_child_index;\n        }\n        if (visible_child_count > 0) {\n          array_push(&self->stack, entry);\n          did_descend = true;\n          break;\n        }\n      } else if (visible) {\n        visible_child_index++;\n      } else {\n        visible_child_index += visible_child_count;\n      }\n    }\n  } while (did_descend);\n\n  self->stack.size = initial_size;\n  return -1;\n}\n\nint64_t ts_tree_cursor_goto_first_child_for_byte(TSTreeCursor *self, uint32_t goal_byte) {\n  return ts_tree_cursor_goto_first_child_for_byte_and_point(self, goal_byte, POINT_ZERO);\n}\n\nint64_t ts_tree_cursor_goto_first_child_for_point(TSTreeCursor *self, TSPoint goal_point) {\n  return ts_tree_cursor_goto_first_child_for_byte_and_point(self, 0, goal_point);\n}\n\nTreeCursorStep ts_tree_cursor_goto_sibling_internal(\n  TSTreeCursor *_self,\n  bool (*advance)(CursorChildIterator *, TreeCursorEntry *, bool *)\n) {\n  TreeCursor *self = (TreeCursor *)_self;\n  uint32_t initial_size = self->stack.size;\n\n  while (self->stack.size > 1) {\n    TreeCursorEntry entry = array_pop(&self->stack);\n    CursorChildIterator iterator = ts_tree_cursor_iterate_children(self);\n    iterator.child_index = entry.child_index;\n    iterator.structural_child_index = entry.structural_child_index;\n    iterator.position = entry.position;\n    iterator.descendant_index = entry.descendant_index;\n\n    bool visible = false;\n    advance(&iterator, &entry, &visible);\n    if (visible && self->stack.size + 1 < initial_size) break;\n\n    while (advance(&iterator, &entry, &visible)) {\n      if (visible) {\n        array_push(&self->stack, entry);\n        return TreeCursorStepVisible;\n      }\n\n      if (ts_subtree_visible_child_count(*entry.subtree)) {\n        array_push(&self->stack, entry);\n        return TreeCursorStepHidden;\n      }\n    }\n  }\n\n  self->stack.size = initial_size;\n  return TreeCursorStepNone;\n}\n\nTreeCursorStep ts_tree_cursor_goto_next_sibling_internal(TSTreeCursor *_self) {\n  return ts_tree_cursor_goto_sibling_internal(_self, ts_tree_cursor_child_iterator_next);\n}\n\nbool ts_tree_cursor_goto_next_sibling(TSTreeCursor *self) {\n  switch (ts_tree_cursor_goto_next_sibling_internal(self)) {\n    case TreeCursorStepHidden:\n      ts_tree_cursor_goto_first_child(self);\n      return true;\n    case TreeCursorStepVisible:\n      return true;\n    default:\n      return false;\n  }\n}\n\nTreeCursorStep ts_tree_cursor_goto_previous_sibling_internal(TSTreeCursor *_self) {\n  // since subtracting across row loses column information, we may have to\n  // restore it\n  TreeCursor *self = (TreeCursor *)_self;\n\n  // for that, save current position before traversing\n  TreeCursorStep step = ts_tree_cursor_goto_sibling_internal(\n      _self, ts_tree_cursor_child_iterator_previous);\n  if (step == TreeCursorStepNone)\n    return step;\n\n  // if length is already valid, there's no need to recompute it\n  if (!length_is_undefined(array_back(&self->stack)->position))\n    return step;\n\n  // restore position from the parent node\n  const TreeCursorEntry *parent = array_get(&self->stack, self->stack.size - 2);\n  Length position = parent->position;\n  uint32_t child_index = array_back(&self->stack)->child_index;\n  const Subtree *children = ts_subtree_children((*(parent->subtree)));\n\n  if (child_index > 0) {\n    // skip first child padding since its position should match the position of the parent\n    position = length_add(position, ts_subtree_size(children[0]));\n    for (uint32_t i = 1; i < child_index; ++i) {\n      position = length_add(position, ts_subtree_total_size(children[i]));\n    }\n    position = length_add(position, ts_subtree_padding(children[child_index]));\n  }\n\n  array_back(&self->stack)->position = position;\n\n  return step;\n}\n\nbool ts_tree_cursor_goto_previous_sibling(TSTreeCursor *self) {\n  switch (ts_tree_cursor_goto_previous_sibling_internal(self)) {\n    case TreeCursorStepHidden:\n      ts_tree_cursor_goto_last_child(self);\n      return true;\n    case TreeCursorStepVisible:\n      return true;\n    default:\n      return false;\n  }\n}\n\nbool ts_tree_cursor_goto_parent(TSTreeCursor *_self) {\n  TreeCursor *self = (TreeCursor *)_self;\n  for (unsigned i = self->stack.size - 2; i + 1 > 0; i--) {\n    if (ts_tree_cursor_is_entry_visible(self, i)) {\n      self->stack.size = i + 1;\n      return true;\n    }\n  }\n  return false;\n}\n\nvoid ts_tree_cursor_goto_descendant(\n  TSTreeCursor *_self,\n  uint32_t goal_descendant_index\n) {\n  TreeCursor *self = (TreeCursor *)_self;\n\n  // Ascend to the lowest ancestor that contains the goal node.\n  for (;;) {\n    uint32_t i = self->stack.size - 1;\n    TreeCursorEntry *entry = array_get(&self->stack, i);\n    uint32_t next_descendant_index =\n      entry->descendant_index +\n      (ts_tree_cursor_is_entry_visible(self, i) ? 1 : 0) +\n      ts_subtree_visible_descendant_count(*entry->subtree);\n    if (\n      (entry->descendant_index <= goal_descendant_index) &&\n      (next_descendant_index > goal_descendant_index)\n    ) {\n      break;\n    } else if (self->stack.size <= 1) {\n      return;\n    } else {\n      self->stack.size--;\n    }\n  }\n\n  // Descend to the goal node.\n  bool did_descend = true;\n  do {\n    did_descend = false;\n    bool visible;\n    TreeCursorEntry entry;\n    CursorChildIterator iterator = ts_tree_cursor_iterate_children(self);\n    if (iterator.descendant_index > goal_descendant_index) {\n      return;\n    }\n\n    while (ts_tree_cursor_child_iterator_next(&iterator, &entry, &visible)) {\n      if (iterator.descendant_index > goal_descendant_index) {\n        array_push(&self->stack, entry);\n        if (visible && entry.descendant_index == goal_descendant_index) {\n          return;\n        } else {\n          did_descend = true;\n          break;\n        }\n      }\n    }\n  } while (did_descend);\n}\n\nuint32_t ts_tree_cursor_current_descendant_index(const TSTreeCursor *_self) {\n  const TreeCursor *self = (const TreeCursor *)_self;\n  TreeCursorEntry *last_entry = array_back(&self->stack);\n  return last_entry->descendant_index;\n}\n\nTSNode ts_tree_cursor_current_node(const TSTreeCursor *_self) {\n  const TreeCursor *self = (const TreeCursor *)_self;\n  TreeCursorEntry *last_entry = array_back(&self->stack);\n  bool is_extra = ts_subtree_extra(*last_entry->subtree);\n  TSSymbol alias_symbol = is_extra ? 0 : self->root_alias_symbol;\n  if (self->stack.size > 1 && !is_extra) {\n    TreeCursorEntry *parent_entry = array_get(&self->stack, self->stack.size - 2);\n    alias_symbol = ts_language_alias_at(\n      self->tree->language,\n      parent_entry->subtree->ptr->production_id,\n      last_entry->structural_child_index\n    );\n  }\n  return ts_node_new(\n    self->tree,\n    last_entry->subtree,\n    last_entry->position,\n    alias_symbol\n  );\n}\n\n// Private - Get various facts about the current node that are needed\n// when executing tree queries.\nvoid ts_tree_cursor_current_status(\n  const TSTreeCursor *_self,\n  TSFieldId *field_id,\n  bool *has_later_siblings,\n  bool *has_later_named_siblings,\n  bool *can_have_later_siblings_with_this_field,\n  TSSymbol *supertypes,\n  unsigned *supertype_count\n) {\n  const TreeCursor *self = (const TreeCursor *)_self;\n  unsigned max_supertypes = *supertype_count;\n  *field_id = 0;\n  *supertype_count = 0;\n  *has_later_siblings = false;\n  *has_later_named_siblings = false;\n  *can_have_later_siblings_with_this_field = false;\n\n  // Walk up the tree, visiting the current node and its invisible ancestors,\n  // because fields can refer to nodes through invisible *wrapper* nodes,\n  for (unsigned i = self->stack.size - 1; i > 0; i--) {\n    TreeCursorEntry *entry = array_get(&self->stack, i);\n    TreeCursorEntry *parent_entry = array_get(&self->stack, i - 1);\n\n    const TSSymbol *alias_sequence = ts_language_alias_sequence(\n      self->tree->language,\n      parent_entry->subtree->ptr->production_id\n    );\n\n    #define subtree_symbol(subtree, structural_child_index) \\\n      ((                                                    \\\n        !ts_subtree_extra(subtree) &&                       \\\n        alias_sequence &&                                   \\\n        alias_sequence[structural_child_index]              \\\n      ) ?                                                   \\\n        alias_sequence[structural_child_index] :            \\\n        ts_subtree_symbol(subtree))\n\n    // Stop walking up when a visible ancestor is found.\n    TSSymbol entry_symbol = subtree_symbol(\n      *entry->subtree,\n      entry->structural_child_index\n    );\n    TSSymbolMetadata entry_metadata = ts_language_symbol_metadata(\n      self->tree->language,\n      entry_symbol\n    );\n    if (i != self->stack.size - 1 && entry_metadata.visible) break;\n\n    // Record any supertypes\n    if (entry_metadata.supertype && *supertype_count < max_supertypes) {\n      supertypes[*supertype_count] = entry_symbol;\n      (*supertype_count)++;\n    }\n\n    // Determine if the current node has later siblings.\n    if (!*has_later_siblings) {\n      unsigned sibling_count = parent_entry->subtree->ptr->child_count;\n      unsigned structural_child_index = entry->structural_child_index;\n      if (!ts_subtree_extra(*entry->subtree)) structural_child_index++;\n      for (unsigned j = entry->child_index + 1; j < sibling_count; j++) {\n        Subtree sibling = ts_subtree_children(*parent_entry->subtree)[j];\n        TSSymbolMetadata sibling_metadata = ts_language_symbol_metadata(\n          self->tree->language,\n          subtree_symbol(sibling, structural_child_index)\n        );\n        if (sibling_metadata.visible) {\n          *has_later_siblings = true;\n          if (*has_later_named_siblings) break;\n          if (sibling_metadata.named) {\n            *has_later_named_siblings = true;\n            break;\n          }\n        } else if (ts_subtree_visible_child_count(sibling) > 0) {\n          *has_later_siblings = true;\n          if (*has_later_named_siblings) break;\n          if (sibling.ptr->named_child_count > 0) {\n            *has_later_named_siblings = true;\n            break;\n          }\n        }\n        if (!ts_subtree_extra(sibling)) structural_child_index++;\n      }\n    }\n\n    #undef subtree_symbol\n\n    if (!ts_subtree_extra(*entry->subtree)) {\n      const TSFieldMapEntry *field_map, *field_map_end;\n      ts_language_field_map(\n        self->tree->language,\n        parent_entry->subtree->ptr->production_id,\n        &field_map, &field_map_end\n      );\n\n      // Look for a field name associated with the current node.\n      if (!*field_id) {\n        for (const TSFieldMapEntry *map = field_map; map < field_map_end; map++) {\n          if (!map->inherited && map->child_index == entry->structural_child_index) {\n            *field_id = map->field_id;\n            break;\n          }\n        }\n      }\n\n      // Determine if the current node can have later siblings with the same field name.\n      if (*field_id) {\n        for (const TSFieldMapEntry *map = field_map; map < field_map_end; map++) {\n          if (\n            map->field_id == *field_id &&\n            map->child_index > entry->structural_child_index\n          ) {\n            *can_have_later_siblings_with_this_field = true;\n            break;\n          }\n        }\n      }\n    }\n  }\n}\n\nuint32_t ts_tree_cursor_current_depth(const TSTreeCursor *_self) {\n  const TreeCursor *self = (const TreeCursor *)_self;\n  uint32_t depth = 0;\n  for (unsigned i = 1; i < self->stack.size; i++) {\n    if (ts_tree_cursor_is_entry_visible(self, i)) {\n      depth++;\n    }\n  }\n  return depth;\n}\n\nTSNode ts_tree_cursor_parent_node(const TSTreeCursor *_self) {\n  const TreeCursor *self = (const TreeCursor *)_self;\n  for (int i = (int)self->stack.size - 2; i >= 0; i--) {\n    TreeCursorEntry *entry = array_get(&self->stack, i);\n    bool is_visible = true;\n    TSSymbol alias_symbol = 0;\n    if (i > 0) {\n      TreeCursorEntry *parent_entry = array_get(&self->stack, i - 1);\n      alias_symbol = ts_language_alias_at(\n        self->tree->language,\n        parent_entry->subtree->ptr->production_id,\n        entry->structural_child_index\n      );\n      is_visible = (alias_symbol != 0) || ts_subtree_visible(*entry->subtree);\n    }\n    if (is_visible) {\n      return ts_node_new(\n        self->tree,\n        entry->subtree,\n        entry->position,\n        alias_symbol\n      );\n    }\n  }\n  return ts_node_new(NULL, NULL, length_zero(), 0);\n}\n\nTSFieldId ts_tree_cursor_current_field_id(const TSTreeCursor *_self) {\n  const TreeCursor *self = (const TreeCursor *)_self;\n\n  // Walk up the tree, visiting the current node and its invisible ancestors.\n  for (unsigned i = self->stack.size - 1; i > 0; i--) {\n    TreeCursorEntry *entry = array_get(&self->stack, i);\n    TreeCursorEntry *parent_entry = array_get(&self->stack, i - 1);\n\n    // Stop walking up when another visible node is found.\n    if (\n      i != self->stack.size - 1 &&\n      ts_tree_cursor_is_entry_visible(self, i)\n    ) break;\n\n    if (ts_subtree_extra(*entry->subtree)) break;\n\n    const TSFieldMapEntry *field_map, *field_map_end;\n    ts_language_field_map(\n      self->tree->language,\n      parent_entry->subtree->ptr->production_id,\n      &field_map, &field_map_end\n    );\n    for (const TSFieldMapEntry *map = field_map; map < field_map_end; map++) {\n      if (!map->inherited && map->child_index == entry->structural_child_index) {\n        return map->field_id;\n      }\n    }\n  }\n  return 0;\n}\n\nconst char *ts_tree_cursor_current_field_name(const TSTreeCursor *_self) {\n  TSFieldId id = ts_tree_cursor_current_field_id(_self);\n  if (id) {\n    const TreeCursor *self = (const TreeCursor *)_self;\n    return self->tree->language->field_names[id];\n  } else {\n    return NULL;\n  }\n}\n\nTSTreeCursor ts_tree_cursor_copy(const TSTreeCursor *_cursor) {\n  const TreeCursor *cursor = (const TreeCursor *)_cursor;\n  TSTreeCursor res = {NULL, NULL, {0, 0}};\n  TreeCursor *copy = (TreeCursor *)&res;\n  copy->tree = cursor->tree;\n  copy->root_alias_symbol = cursor->root_alias_symbol;\n  array_init(&copy->stack);\n  array_push_all(&copy->stack, &cursor->stack);\n  return res;\n}\n\nvoid ts_tree_cursor_reset_to(TSTreeCursor *_dst, const TSTreeCursor *_src) {\n  const TreeCursor *cursor = (const TreeCursor *)_src;\n  TreeCursor *copy = (TreeCursor *)_dst;\n  copy->tree = cursor->tree;\n  copy->root_alias_symbol = cursor->root_alias_symbol;\n  array_clear(&copy->stack);\n  array_push_all(&copy->stack, &cursor->stack);\n}\n",
    "#ifndef TREE_SITTER_REDUCE_ACTION_H_\n#define TREE_SITTER_REDUCE_ACTION_H_\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include \"./array.h\"\n#include \"tree_sitter/api.h\"\n\ntypedef struct {\n  uint32_t count;\n  TSSymbol symbol;\n  int dynamic_precedence;\n  unsigned short production_id;\n} ReduceAction;\n\ntypedef Array(ReduceAction) ReduceActionSet;\n\nstatic inline void ts_reduce_action_set_add(ReduceActionSet *self,\n                                            ReduceAction new_action) {\n  for (uint32_t i = 0; i < self->size; i++) {\n    ReduceAction action = self->contents[i];\n    if (action.symbol == new_action.symbol && action.count == new_action.count)\n      return;\n  }\n  array_push(self, new_action);\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif  // TREE_SITTER_REDUCE_ACTION_H_\n",
    "#ifndef TREE_SITTER_TREE_CURSOR_H_\n#define TREE_SITTER_TREE_CURSOR_H_\n\n#include \"./subtree.h\"\n\ntypedef struct {\n  const Subtree *subtree;\n  Length position;\n  uint32_t child_index;\n  uint32_t structural_child_index;\n  uint32_t descendant_index;\n} TreeCursorEntry;\n\ntypedef struct {\n  const TSTree *tree;\n  Array(TreeCursorEntry) stack;\n  TSSymbol root_alias_symbol;\n} TreeCursor;\n\ntypedef enum {\n  TreeCursorStepNone,\n  TreeCursorStepHidden,\n  TreeCursorStepVisible,\n} TreeCursorStep;\n\nvoid ts_tree_cursor_init(TreeCursor *self, TSNode node);\nvoid ts_tree_cursor_current_status(\n  const TSTreeCursor *_self,\n  TSFieldId *field_id,\n  bool *has_later_siblings,\n  bool *has_later_named_siblings,\n  bool *can_have_later_siblings_with_this_field,\n  TSSymbol *supertypes,\n  unsigned *supertype_count\n);\n\nTreeCursorStep ts_tree_cursor_goto_first_child_internal(TSTreeCursor *_self);\nTreeCursorStep ts_tree_cursor_goto_next_sibling_internal(TSTreeCursor *_self);\n\nstatic inline Subtree ts_tree_cursor_current_subtree(const TSTreeCursor *_self) {\n  const TreeCursor *self = (const TreeCursor *)_self;\n  TreeCursorEntry *last_entry = array_back(&self->stack);\n  return *last_entry->subtree;\n}\n\nTSNode ts_tree_cursor_parent_node(const TSTreeCursor *_self);\n\n#endif  // TREE_SITTER_TREE_CURSOR_H_\n",
    "#include \"array.h\"\n#include \"point.h\"\n\n#include <emscripten.h>\n#include <tree_sitter/api.h>\n\n/*****************************/\n/* Section - Data marshaling */\n/*****************************/\n\nstatic const uint32_t INPUT_BUFFER_SIZE = 10 * 1024;\n\nconst void *TRANSFER_BUFFER[12] = {\n  NULL, NULL, NULL, NULL,\n  NULL, NULL, NULL, NULL,\n  NULL, NULL, NULL, NULL,\n};\n\nstatic const int SIZE_OF_CURSOR = 4;\nstatic const int SIZE_OF_NODE = 5;\nstatic const int SIZE_OF_POINT = 2;\nstatic const int SIZE_OF_RANGE = 2 + (2 * SIZE_OF_POINT);\nstatic const int SIZE_OF_CAPTURE = 1 + SIZE_OF_NODE;\n\nvoid *ts_init() {\n  TRANSFER_BUFFER[0] = (const void *)TREE_SITTER_LANGUAGE_VERSION;\n  TRANSFER_BUFFER[1] = (const void *)TREE_SITTER_MIN_COMPATIBLE_LANGUAGE_VERSION;\n  return (void*)TRANSFER_BUFFER;\n}\n\nstatic uint32_t code_unit_to_byte(uint32_t unit) {\n  return unit << 1;\n}\n\nstatic uint32_t byte_to_code_unit(uint32_t byte) {\n  return byte >> 1;\n}\n\nstatic inline void marshal_node(const void **buffer, TSNode node) {\n  buffer[0] = node.id;\n  buffer[1] = (const void *)byte_to_code_unit(node.context[0]);\n  buffer[2] = (const void *)node.context[1];\n  buffer[3] = (const void *)byte_to_code_unit(node.context[2]);\n  buffer[4] = (const void *)node.context[3];\n}\n\nstatic inline TSNode unmarshal_node_at(const TSTree *tree, uint32_t index) {\n  TSNode node;\n  const void **buffer = TRANSFER_BUFFER + index * SIZE_OF_NODE;\n  node.id = buffer[0];\n  node.context[0] = code_unit_to_byte((uint32_t)buffer[1]);\n  node.context[1] = (uint32_t)buffer[2];\n  node.context[2] = code_unit_to_byte((uint32_t)buffer[3]);\n  node.context[3] = (uint32_t)buffer[4];\n  node.tree = tree;\n  return node;\n}\n\nstatic inline TSNode unmarshal_node(const TSTree *tree) {\n  return unmarshal_node_at(tree, 0);\n}\n\nstatic inline void marshal_cursor(const TSTreeCursor *cursor) {\n  TRANSFER_BUFFER[0] = cursor->id;\n  TRANSFER_BUFFER[1] = (const void *)cursor->context[0];\n  TRANSFER_BUFFER[2] = (const void *)cursor->context[1];\n  TRANSFER_BUFFER[3] = (const void *)cursor->context[2];\n}\n\nstatic inline TSTreeCursor unmarshal_cursor(const void **buffer, const TSTree *tree) {\n  TSTreeCursor cursor;\n  cursor.id = buffer[0];\n  cursor.context[0] = (uint32_t)buffer[1];\n  cursor.context[1] = (uint32_t)buffer[2];\n  cursor.context[2] = (uint32_t)buffer[3];\n  cursor.tree = tree;\n  return cursor;\n}\n\nstatic void marshal_point(TSPoint point) {\n  TRANSFER_BUFFER[0] = (const void *)point.row;\n  TRANSFER_BUFFER[1] = (const void *)byte_to_code_unit(point.column);\n}\n\nstatic TSPoint unmarshal_point(const void **address) {\n  TSPoint point;\n  point.row = (uint32_t)address[0];\n  point.column = code_unit_to_byte((uint32_t)address[1]);\n  return point;\n}\n\nstatic void marshal_range(TSRange *range) {\n  range->start_byte = byte_to_code_unit(range->start_byte);\n  range->end_byte = byte_to_code_unit(range->end_byte);\n  range->start_point.column = byte_to_code_unit(range->start_point.column);\n  range->end_point.column = byte_to_code_unit(range->end_point.column);\n}\n\nstatic void unmarshal_range(TSRange *range) {\n  range->start_byte = code_unit_to_byte(range->start_byte);\n  range->end_byte = code_unit_to_byte(range->end_byte);\n  range->start_point.column = code_unit_to_byte(range->start_point.column);\n  range->end_point.column = code_unit_to_byte(range->end_point.column);\n}\n\nstatic TSInputEdit unmarshal_edit() {\n  TSInputEdit edit;\n  const void **address = TRANSFER_BUFFER;\n  edit.start_point = unmarshal_point(address); address += SIZE_OF_POINT;\n  edit.old_end_point = unmarshal_point(address); address += SIZE_OF_POINT;\n  edit.new_end_point = unmarshal_point(address); address += SIZE_OF_POINT;\n  edit.start_byte = code_unit_to_byte((uint32_t)*address); address += 1;\n  edit.old_end_byte = code_unit_to_byte((uint32_t)*address); address += 1;\n  edit.new_end_byte = code_unit_to_byte((uint32_t)*address); address += 1;\n  return edit;\n}\n\nstatic void marshal_language_metadata(const TSLanguageMetadata *metadata) {\n  if (metadata == NULL) {\n    TRANSFER_BUFFER[0] = 0;\n    return;\n  }\n  TRANSFER_BUFFER[0] = (const void*)3;\n  TRANSFER_BUFFER[1] = (const void*)(uint32_t)metadata->major_version;\n  TRANSFER_BUFFER[2] = (const void*)(uint32_t)metadata->minor_version;\n  TRANSFER_BUFFER[3] = (const void*)(uint32_t)metadata->patch_version;\n}\n\n/********************/\n/* Section - Parser */\n/********************/\n\nextern void tree_sitter_parse_callback(\n  char *input_buffer,\n  uint32_t index,\n  uint32_t row,\n  uint32_t column,\n  uint32_t *length_read\n);\n\nextern void tree_sitter_log_callback(\n  bool is_lex_message,\n  const char *message\n);\n\nextern bool tree_sitter_progress_callback(\n  uint32_t current_offset,\n  bool has_error\n);\n\nextern bool tree_sitter_query_progress_callback(\n  uint32_t current_offset\n);\n\nstatic const char *call_parse_callback(\n  void *payload,\n  uint32_t byte,\n  TSPoint position,\n  uint32_t *bytes_read\n) {\n  char *buffer = (char *)payload;\n  tree_sitter_parse_callback(\n    buffer,\n    byte_to_code_unit(byte),\n    position.row,\n    byte_to_code_unit(position.column),\n    bytes_read\n  );\n  *bytes_read = code_unit_to_byte(*bytes_read);\n  if (*bytes_read >= INPUT_BUFFER_SIZE) {\n    *bytes_read = INPUT_BUFFER_SIZE - 2;\n  }\n  return buffer;\n}\n\nstatic void call_log_callback(\n  void *payload,\n  TSLogType log_type,\n  const char *message\n) {\n  tree_sitter_log_callback(log_type == TSLogTypeLex, message);\n}\n\nstatic bool progress_callback(\n  TSParseState *state\n) {\n  return tree_sitter_progress_callback(state->current_byte_offset, state->has_error);\n}\n\nstatic bool query_progress_callback(\n  TSQueryCursorState *state\n) {\n  return tree_sitter_query_progress_callback(state->current_byte_offset);\n}\n\nvoid ts_parser_new_wasm() {\n  TSParser *parser = ts_parser_new();\n  char *input_buffer = calloc(INPUT_BUFFER_SIZE, sizeof(char));\n  TRANSFER_BUFFER[0] = parser;\n  TRANSFER_BUFFER[1] = input_buffer;\n}\n\nvoid ts_parser_enable_logger_wasm(TSParser *self, bool should_log) {\n  TSLogger logger = {self, should_log ? call_log_callback : NULL};\n  ts_parser_set_logger(self, logger);\n}\n\nTSTree *ts_parser_parse_wasm(\n  TSParser *self,\n  char *input_buffer,\n  const TSTree *old_tree,\n  TSRange *ranges,\n  uint32_t range_count\n) {\n  TSInput input = {\n    input_buffer,\n    call_parse_callback,\n    TSInputEncodingUTF16LE,\n    NULL,\n  };\n  if (range_count) {\n    for (unsigned i = 0; i < range_count; i++) {\n      unmarshal_range(&ranges[i]);\n    }\n    ts_parser_set_included_ranges(self, ranges, range_count);\n    free(ranges);\n  } else {\n    ts_parser_set_included_ranges(self, NULL, 0);\n  }\n\n  TSParseOptions options = {.payload = NULL, .progress_callback = progress_callback};\n\n  return ts_parser_parse_with_options(self, old_tree, input, options);\n}\n\nvoid ts_parser_included_ranges_wasm(TSParser *self) {\n  uint32_t range_count = 0;\n  const TSRange *ranges = ts_parser_included_ranges(self, &range_count);\n  TSRange *copied_ranges = malloc(sizeof(TSRange) * range_count);\n  memcpy(copied_ranges, ranges, sizeof(TSRange) * range_count);\n  for (unsigned i = 0; i < range_count; i++) {\n    marshal_range(&copied_ranges[i]);\n  }\n  TRANSFER_BUFFER[0] = range_count ? (const void *)range_count : NULL;\n  TRANSFER_BUFFER[1] = copied_ranges;\n}\n\n/**********************/\n/* Section - Language */\n/**********************/\n\nint ts_language_type_is_named_wasm(const TSLanguage *self, TSSymbol typeId) {\n  const TSSymbolType symbolType = ts_language_symbol_type(self, typeId);\n  return symbolType == TSSymbolTypeRegular;\n}\n\nint ts_language_type_is_visible_wasm(const TSLanguage *self, TSSymbol typeId) {\n  const TSSymbolType symbolType = ts_language_symbol_type(self, typeId);\n  return symbolType <= TSSymbolTypeAnonymous;\n}\n\nvoid ts_language_metadata_wasm(const TSLanguage *self) {\n  const TSLanguageMetadata *metadata = ts_language_metadata(self);\n  marshal_language_metadata(metadata);\n}\n\nvoid ts_language_supertypes_wasm(const TSLanguage *self) {\n  uint32_t length;\n  const TSSymbol *supertypes = ts_language_supertypes(self, &length);\n  TRANSFER_BUFFER[0] = (const void *)length;\n  TRANSFER_BUFFER[1] = supertypes;\n}\n\nvoid ts_language_subtypes_wasm(const TSLanguage *self, TSSymbol supertype) {\n  uint32_t length;\n  const TSSymbol *subtypes = ts_language_subtypes(self, supertype, &length);\n  TRANSFER_BUFFER[0] = (const void *)length;\n  TRANSFER_BUFFER[1] = subtypes;\n}\n\n/******************/\n/* Section - Tree */\n/******************/\n\nvoid ts_tree_root_node_wasm(const TSTree *tree) {\n  marshal_node(TRANSFER_BUFFER, ts_tree_root_node(tree));\n}\n\nvoid ts_tree_root_node_with_offset_wasm(const TSTree *tree) {\n  // read int and point from transfer buffer\n  const void **address = TRANSFER_BUFFER + SIZE_OF_NODE;\n  uint32_t offset = code_unit_to_byte((uint32_t)address[0]);\n  TSPoint extent = unmarshal_point(address + 1);\n  TSNode node = ts_tree_root_node_with_offset(tree, offset, extent);\n  marshal_node(TRANSFER_BUFFER, node);\n}\n\nvoid ts_tree_edit_wasm(TSTree *tree) {\n  TSInputEdit edit = unmarshal_edit();\n  ts_tree_edit(tree, &edit);\n}\n\nvoid ts_tree_included_ranges_wasm(const TSTree *tree) {\n  uint32_t range_count;\n  TSRange *ranges = ts_tree_included_ranges(tree, &range_count);\n  for (unsigned i = 0; i < range_count; i++) {\n    marshal_range(&ranges[i]);\n  }\n  TRANSFER_BUFFER[0] = (range_count ? (const void *)range_count : NULL);\n  TRANSFER_BUFFER[1] = (const void *)ranges;\n}\n\nvoid ts_tree_get_changed_ranges_wasm(TSTree *tree, TSTree *other) {\n  unsigned range_count;\n  TSRange *ranges = ts_tree_get_changed_ranges(tree, other, &range_count);\n  for (unsigned i = 0; i < range_count; i++) {\n    marshal_range(&ranges[i]);\n  }\n  TRANSFER_BUFFER[0] = (const void *)range_count;\n  TRANSFER_BUFFER[1] = (const void *)ranges;\n}\n\n/************************/\n/* Section - TreeCursor */\n/************************/\n\nvoid ts_tree_cursor_new_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  TSTreeCursor cursor = ts_tree_cursor_new(node);\n  marshal_cursor(&cursor);\n}\n\nvoid ts_tree_cursor_copy_wasm(const TSTree *tree) {\n  TSTreeCursor cursor = unmarshal_cursor(TRANSFER_BUFFER, tree);\n  TSTreeCursor copy = ts_tree_cursor_copy(&cursor);\n  marshal_cursor(&copy);\n}\n\nvoid ts_tree_cursor_delete_wasm(const TSTree *tree) {\n  TSTreeCursor cursor = unmarshal_cursor(TRANSFER_BUFFER, tree);\n  ts_tree_cursor_delete(&cursor);\n}\n\nvoid ts_tree_cursor_reset_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  TSTreeCursor cursor = unmarshal_cursor(&TRANSFER_BUFFER[SIZE_OF_NODE], tree);\n  ts_tree_cursor_reset(&cursor, node);\n  marshal_cursor(&cursor);\n}\n\nvoid ts_tree_cursor_reset_to_wasm(const TSTree *_dst, const TSTree *_src) {\n  TSTreeCursor cursor = unmarshal_cursor(TRANSFER_BUFFER, _dst);\n  TSTreeCursor src = unmarshal_cursor(&TRANSFER_BUFFER[SIZE_OF_CURSOR], _src);\n  ts_tree_cursor_reset_to(&cursor, &src);\n  marshal_cursor(&cursor);\n}\n\nbool ts_tree_cursor_goto_first_child_wasm(const TSTree *tree) {\n  TSTreeCursor cursor = unmarshal_cursor(TRANSFER_BUFFER, tree);\n  bool result = ts_tree_cursor_goto_first_child(&cursor);\n  marshal_cursor(&cursor);\n  return result;\n}\n\nbool ts_tree_cursor_goto_last_child_wasm(const TSTree *tree) {\n  TSTreeCursor cursor = unmarshal_cursor(TRANSFER_BUFFER, tree);\n  bool result = ts_tree_cursor_goto_last_child(&cursor);\n  marshal_cursor(&cursor);\n  return result;\n}\n\nbool ts_tree_cursor_goto_first_child_for_index_wasm(const TSTree *tree) {\n  TSTreeCursor cursor = unmarshal_cursor(TRANSFER_BUFFER, tree);\n  const void **address = TRANSFER_BUFFER + 3;\n  uint32_t index = code_unit_to_byte((uint32_t)address[0]);\n  bool result = ts_tree_cursor_goto_first_child_for_byte(&cursor, index);\n  marshal_cursor(&cursor);\n  return result;\n}\n\nbool ts_tree_cursor_goto_first_child_for_position_wasm(const TSTree *tree) {\n  TSTreeCursor cursor = unmarshal_cursor(TRANSFER_BUFFER, tree);\n  const void **address = TRANSFER_BUFFER + 3;\n  TSPoint point = unmarshal_point(address);\n  bool result = ts_tree_cursor_goto_first_child_for_point(&cursor, point);\n  marshal_cursor(&cursor);\n  return result;\n}\n\nbool ts_tree_cursor_goto_next_sibling_wasm(const TSTree *tree) {\n  TSTreeCursor cursor = unmarshal_cursor(TRANSFER_BUFFER, tree);\n  bool result = ts_tree_cursor_goto_next_sibling(&cursor);\n  marshal_cursor(&cursor);\n  return result;\n}\n\nbool ts_tree_cursor_goto_previous_sibling_wasm(const TSTree *tree) {\n  TSTreeCursor cursor = unmarshal_cursor(TRANSFER_BUFFER, tree);\n  bool result = ts_tree_cursor_goto_previous_sibling(&cursor);\n  marshal_cursor(&cursor);\n  return result;\n}\n\nvoid ts_tree_cursor_goto_descendant_wasm(const TSTree *tree, uint32_t goal_descendant_index) {\n  TSTreeCursor cursor = unmarshal_cursor(TRANSFER_BUFFER, tree);\n  ts_tree_cursor_goto_descendant(&cursor, goal_descendant_index);\n  marshal_cursor(&cursor);\n}\n\nbool ts_tree_cursor_goto_parent_wasm(const TSTree *tree) {\n  TSTreeCursor cursor = unmarshal_cursor(TRANSFER_BUFFER, tree);\n  bool result = ts_tree_cursor_goto_parent(&cursor);\n  marshal_cursor(&cursor);\n  return result;\n}\n\nuint16_t ts_tree_cursor_current_node_type_id_wasm(const TSTree *tree) {\n  TSTreeCursor cursor = unmarshal_cursor(TRANSFER_BUFFER, tree);\n  TSNode node = ts_tree_cursor_current_node(&cursor);\n  return ts_node_symbol(node);\n}\n\nuint16_t ts_tree_cursor_current_node_state_id_wasm(const TSTree *tree) {\n  TSTreeCursor cursor = unmarshal_cursor(TRANSFER_BUFFER, tree);\n  TSNode node = ts_tree_cursor_current_node(&cursor);\n  return ts_node_parse_state(node);\n}\n\nbool ts_tree_cursor_current_node_is_named_wasm(const TSTree *tree) {\n  TSTreeCursor cursor = unmarshal_cursor(TRANSFER_BUFFER, tree);\n  TSNode node = ts_tree_cursor_current_node(&cursor);\n  return ts_node_is_named(node);\n}\n\nbool ts_tree_cursor_current_node_is_missing_wasm(const TSTree *tree) {\n  TSTreeCursor cursor = unmarshal_cursor(TRANSFER_BUFFER, tree);\n  TSNode node = ts_tree_cursor_current_node(&cursor);\n  return ts_node_is_missing(node);\n}\n\nuint32_t ts_tree_cursor_current_node_id_wasm(const TSTree *tree) {\n  TSTreeCursor cursor = unmarshal_cursor(TRANSFER_BUFFER, tree);\n  TSNode node = ts_tree_cursor_current_node(&cursor);\n  return (uint32_t)node.id;\n}\n\nvoid ts_tree_cursor_start_position_wasm(const TSTree *tree) {\n  TSTreeCursor cursor = unmarshal_cursor(TRANSFER_BUFFER, tree);\n  TSNode node = ts_tree_cursor_current_node(&cursor);\n  marshal_point(ts_node_start_point(node));\n}\n\nvoid ts_tree_cursor_end_position_wasm(const TSTree *tree) {\n  TSTreeCursor cursor = unmarshal_cursor(TRANSFER_BUFFER, tree);\n  TSNode node = ts_tree_cursor_current_node(&cursor);\n  marshal_point(ts_node_end_point(node));\n}\n\nuint32_t ts_tree_cursor_start_index_wasm(const TSTree *tree) {\n  TSTreeCursor cursor = unmarshal_cursor(TRANSFER_BUFFER, tree);\n  TSNode node = ts_tree_cursor_current_node(&cursor);\n  return byte_to_code_unit(ts_node_start_byte(node));\n}\n\nuint32_t ts_tree_cursor_end_index_wasm(const TSTree *tree) {\n  TSTreeCursor cursor = unmarshal_cursor(TRANSFER_BUFFER, tree);\n  TSNode node = ts_tree_cursor_current_node(&cursor);\n  return byte_to_code_unit(ts_node_end_byte(node));\n}\n\nuint32_t ts_tree_cursor_current_field_id_wasm(const TSTree *tree) {\n  TSTreeCursor cursor = unmarshal_cursor(TRANSFER_BUFFER, tree);\n  return ts_tree_cursor_current_field_id(&cursor);\n}\n\nuint32_t ts_tree_cursor_current_depth_wasm(const TSTree *tree) {\n  TSTreeCursor cursor = unmarshal_cursor(TRANSFER_BUFFER, tree);\n  return ts_tree_cursor_current_depth(&cursor);\n}\n\nuint32_t ts_tree_cursor_current_descendant_index_wasm(const TSTree *tree) {\n  TSTreeCursor cursor = unmarshal_cursor(TRANSFER_BUFFER, tree);\n  return ts_tree_cursor_current_descendant_index(&cursor);\n}\n\nvoid ts_tree_cursor_current_node_wasm(const TSTree *tree) {\n  TSTreeCursor cursor = unmarshal_cursor(TRANSFER_BUFFER, tree);\n  marshal_node(TRANSFER_BUFFER, ts_tree_cursor_current_node(&cursor));\n}\n\n/******************/\n/* Section - Node */\n/******************/\n\nstatic TSTreeCursor scratch_cursor = {0};\nstatic TSQueryCursor *scratch_query_cursor = NULL;\n\nuint16_t ts_node_symbol_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  return ts_node_symbol(node);\n}\n\nconst char *ts_node_field_name_for_child_wasm(const TSTree *tree, uint32_t index) {\n  TSNode node = unmarshal_node(tree);\n  return ts_node_field_name_for_child(node, index);\n}\n\nconst char *ts_node_field_name_for_named_child_wasm(const TSTree *tree, uint32_t index) {\n  TSNode node = unmarshal_node(tree);\n  return ts_node_field_name_for_named_child(node, index);\n}\n\nvoid ts_node_children_by_field_id_wasm(const TSTree *tree, uint32_t field_id) {\n  TSNode node = unmarshal_node(tree);\n  TSTreeCursor cursor = ts_tree_cursor_new(node);\n\n  bool done = field_id == 0;\n  if (!done) {\n    ts_tree_cursor_reset(&cursor, node);\n    ts_tree_cursor_goto_first_child(&cursor);\n  }\n\n  Array(const void*) result = array_new();\n\n  while (!done) {\n    while (ts_tree_cursor_current_field_id(&cursor) != field_id) {\n      if (!ts_tree_cursor_goto_next_sibling(&cursor)) {\n        done = true;\n        break;\n      }\n    }\n    if (done) {\n      break;\n    }\n    TSNode result_node = ts_tree_cursor_current_node(&cursor);\n    if (!ts_tree_cursor_goto_next_sibling(&cursor)) {\n      done = true;\n    }\n    array_grow_by(&result, SIZE_OF_NODE);\n    marshal_node(result.contents + result.size - SIZE_OF_NODE, result_node);\n  }\n  ts_tree_cursor_delete(&cursor);\n\n  TRANSFER_BUFFER[0] = (const void*)(result.size / SIZE_OF_NODE);\n  TRANSFER_BUFFER[1] = (const void*)result.contents;\n}\n\nvoid ts_node_first_child_for_byte_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  const void** address = TRANSFER_BUFFER + SIZE_OF_NODE;\n  uint32_t byte = code_unit_to_byte((uint32_t)address[0]);\n  marshal_node(TRANSFER_BUFFER, ts_node_first_child_for_byte(node, byte));\n}\n\nvoid ts_node_first_named_child_for_byte_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  const void** address = TRANSFER_BUFFER + SIZE_OF_NODE;\n  uint32_t byte = code_unit_to_byte((uint32_t)address[0]);\n  marshal_node(TRANSFER_BUFFER, ts_node_first_named_child_for_byte(node, byte));\n}\n\nuint16_t ts_node_grammar_symbol_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  return ts_node_grammar_symbol(node);\n}\n\nuint32_t ts_node_child_count_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  return ts_node_child_count(node);\n}\n\nuint32_t ts_node_named_child_count_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  return ts_node_named_child_count(node);\n}\n\nvoid ts_node_child_wasm(const TSTree *tree, uint32_t index) {\n  TSNode node = unmarshal_node(tree);\n  marshal_node(TRANSFER_BUFFER, ts_node_child(node, index));\n}\n\nvoid ts_node_named_child_wasm(const TSTree *tree, uint32_t index) {\n  TSNode node = unmarshal_node(tree);\n  marshal_node(TRANSFER_BUFFER, ts_node_named_child(node, index));\n}\n\nvoid ts_node_child_by_field_id_wasm(const TSTree *tree, uint32_t field_id) {\n  TSNode node = unmarshal_node(tree);\n  marshal_node(TRANSFER_BUFFER, ts_node_child_by_field_id(node, field_id));\n}\n\nvoid ts_node_next_sibling_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  marshal_node(TRANSFER_BUFFER, ts_node_next_sibling(node));\n}\n\nvoid ts_node_prev_sibling_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  marshal_node(TRANSFER_BUFFER, ts_node_prev_sibling(node));\n}\n\nvoid ts_node_next_named_sibling_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  marshal_node(TRANSFER_BUFFER, ts_node_next_named_sibling(node));\n}\n\nvoid ts_node_prev_named_sibling_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  marshal_node(TRANSFER_BUFFER, ts_node_prev_named_sibling(node));\n}\n\nuint32_t ts_node_descendant_count_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  return ts_node_descendant_count(node);\n}\n\nvoid ts_node_parent_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  marshal_node(TRANSFER_BUFFER, ts_node_parent(node));\n}\n\nvoid ts_node_child_with_descendant_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  TSNode descendant = unmarshal_node_at(tree, 1);\n  marshal_node(TRANSFER_BUFFER, ts_node_child_with_descendant(node, descendant));\n}\n\nvoid ts_node_descendant_for_index_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  const void **address = TRANSFER_BUFFER + SIZE_OF_NODE;\n  uint32_t start = code_unit_to_byte((uint32_t)address[0]);\n  uint32_t end = code_unit_to_byte((uint32_t)address[1]);\n  marshal_node(TRANSFER_BUFFER, ts_node_descendant_for_byte_range(node, start, end));\n}\n\nvoid ts_node_named_descendant_for_index_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  const void **address = TRANSFER_BUFFER + SIZE_OF_NODE;\n  uint32_t start = code_unit_to_byte((uint32_t)address[0]);\n  uint32_t end = code_unit_to_byte((uint32_t)address[1]);\n  marshal_node(TRANSFER_BUFFER, ts_node_named_descendant_for_byte_range(node, start, end));\n}\n\nvoid ts_node_descendant_for_position_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  const void **address = TRANSFER_BUFFER + SIZE_OF_NODE;\n  TSPoint start = unmarshal_point(address); address += SIZE_OF_POINT;\n  TSPoint end = unmarshal_point(address);\n  marshal_node(TRANSFER_BUFFER, ts_node_descendant_for_point_range(node, start, end));\n}\n\nvoid ts_node_named_descendant_for_position_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  const void **address = TRANSFER_BUFFER + SIZE_OF_NODE;\n  TSPoint start = unmarshal_point(address); address += SIZE_OF_POINT;\n  TSPoint end = unmarshal_point(address);\n  marshal_node(TRANSFER_BUFFER, ts_node_named_descendant_for_point_range(node, start, end));\n}\n\nvoid ts_node_start_point_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  marshal_point(ts_node_start_point(node));\n}\n\nvoid ts_node_end_point_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  marshal_point(ts_node_end_point(node));\n}\n\nuint32_t ts_node_start_index_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  return byte_to_code_unit(ts_node_start_byte(node));\n}\n\nuint32_t ts_node_end_index_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  return byte_to_code_unit(ts_node_end_byte(node));\n}\n\nchar *ts_node_to_string_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  return ts_node_string(node);\n}\n\nvoid ts_node_children_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  uint32_t count = ts_node_child_count(node);\n  const void **result = NULL;\n  if (count > 0) {\n    result = (const void**)calloc(sizeof(void *), SIZE_OF_NODE * count);\n    const void **address = result;\n    ts_tree_cursor_reset(&scratch_cursor, node);\n    ts_tree_cursor_goto_first_child(&scratch_cursor);\n    marshal_node(address, ts_tree_cursor_current_node(&scratch_cursor));\n    for (uint32_t i = 1; i < count; i++) {\n      address += SIZE_OF_NODE;\n      ts_tree_cursor_goto_next_sibling(&scratch_cursor);\n      TSNode child = ts_tree_cursor_current_node(&scratch_cursor);\n      marshal_node(address, child);\n    }\n  }\n  TRANSFER_BUFFER[0] = (const void *)count;\n  TRANSFER_BUFFER[1] = (const void *)result;\n}\n\nvoid ts_node_named_children_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  uint32_t count = ts_node_named_child_count(node);\n  const void **result = NULL;\n  if (count > 0) {\n    result = (const void**)calloc(sizeof(void *), SIZE_OF_NODE * count);\n    const void **address = result;\n    ts_tree_cursor_reset(&scratch_cursor, node);\n    ts_tree_cursor_goto_first_child(&scratch_cursor);\n    uint32_t i = 0;\n    for (;;) {\n      TSNode child = ts_tree_cursor_current_node(&scratch_cursor);\n      if (ts_node_is_named(child)) {\n        marshal_node(address, child);\n        address += SIZE_OF_NODE;\n        i++;\n        if (i == count) {\n          break;\n        }\n      }\n      if (!ts_tree_cursor_goto_next_sibling(&scratch_cursor)) {\n        break;\n      }\n    }\n  }\n  TRANSFER_BUFFER[0] = (const void *)count;\n  TRANSFER_BUFFER[1] = (const void *)result;\n}\n\nbool symbols_contain(const uint32_t *set, uint32_t length, uint32_t value) {\n  for (unsigned i = 0; i < length; i++) {\n    if (set[i] == value) {\n      return true;\n    }\n    if (set[i] > value) {\n      break;\n    }\n  }\n  return false;\n}\n\nvoid ts_node_descendants_of_type_wasm(\n  const TSTree *tree,\n  const uint32_t *symbols,\n  uint32_t symbol_count,\n  uint32_t start_row,\n  uint32_t start_column,\n  uint32_t end_row,\n  uint32_t end_column\n) {\n  TSNode node = unmarshal_node(tree);\n  TSPoint start_point = {start_row, code_unit_to_byte(start_column)};\n  TSPoint end_point = {end_row, code_unit_to_byte(end_column)};\n  if (end_point.row == 0 && end_point.column == 0) {\n    end_point = (TSPoint) {UINT32_MAX, UINT32_MAX};\n  }\n\n  Array(const void *) result = array_new();\n\n  // Walk the tree depth first looking for matching nodes.\n  ts_tree_cursor_reset(&scratch_cursor, node);\n  bool already_visited_children = false;\n  while (true) {\n    TSNode descendant = ts_tree_cursor_current_node(&scratch_cursor);\n\n    if (!already_visited_children) {\n      // If this node is before the selected range, then avoid\n      // descending into it.\n      if (point_lte(ts_node_end_point(descendant), start_point)) {\n        if (ts_tree_cursor_goto_next_sibling(&scratch_cursor)) {\n          already_visited_children = false;\n        } else {\n          if (!ts_tree_cursor_goto_parent(&scratch_cursor)) {\n            break;\n          }\n          already_visited_children = true;\n        }\n        continue;\n      }\n\n      // If this node is after the selected range, then stop walking.\n      if (point_lte(end_point, ts_node_start_point(descendant))) {\n        break;\n      }\n\n      // Add the node to the result if its type matches one of the given\n      // node types.\n      if (symbols_contain(symbols, symbol_count, ts_node_symbol(descendant))) {\n        array_grow_by(&result, SIZE_OF_NODE);\n        marshal_node(result.contents + result.size - SIZE_OF_NODE, descendant);\n      }\n\n      // Continue walking.\n      if (ts_tree_cursor_goto_first_child(&scratch_cursor)) {\n        already_visited_children = false;\n      } else if (ts_tree_cursor_goto_next_sibling(&scratch_cursor)) {\n        already_visited_children = false;\n      } else {\n        if (!ts_tree_cursor_goto_parent(&scratch_cursor)) {\n          break;\n        }\n        already_visited_children = true;\n      }\n    } else {\n      if (ts_tree_cursor_goto_next_sibling(&scratch_cursor)) {\n        already_visited_children = false;\n      } else {\n        if (!ts_tree_cursor_goto_parent(&scratch_cursor)) {\n          break;\n        }\n      }\n    }\n  }\n\n  TRANSFER_BUFFER[0] = (const void *)(result.size / SIZE_OF_NODE);\n  TRANSFER_BUFFER[1] = (const void *)result.contents;\n}\n\nint ts_node_is_named_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  return ts_node_is_named(node);\n}\n\nint ts_node_has_changes_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  return ts_node_has_changes(node);\n}\n\nint ts_node_has_error_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  return ts_node_has_error(node);\n}\n\nint ts_node_is_error_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  return ts_node_is_error(node);\n}\n\nint ts_node_is_missing_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  return ts_node_is_missing(node);\n}\n\nint ts_node_is_extra_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  return ts_node_is_extra(node);\n}\n\nuint16_t ts_node_parse_state_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  return ts_node_parse_state(node);\n}\n\nuint16_t ts_node_next_parse_state_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  return ts_node_next_parse_state(node);\n}\n\n/******************/\n/* Section - Query */\n/******************/\n\nvoid ts_query_matches_wasm(\n  const TSQuery *self,\n  const TSTree *tree,\n  uint32_t start_row,\n  uint32_t start_column,\n  uint32_t end_row,\n  uint32_t end_column,\n  uint32_t start_index,\n  uint32_t end_index,\n  uint32_t start_containing_row,\n  uint32_t start_containing_column,\n  uint32_t end_containing_row,\n  uint32_t end_containing_column,\n  uint32_t start_containing_index,\n  uint32_t end_containing_index,\n  uint32_t match_limit,\n  uint32_t max_start_depth\n) {\n  if (!scratch_query_cursor) {\n    scratch_query_cursor = ts_query_cursor_new();\n  }\n  if (match_limit == 0) {\n    ts_query_cursor_set_match_limit(scratch_query_cursor, UINT32_MAX);\n  } else {\n    ts_query_cursor_set_match_limit(scratch_query_cursor, match_limit);\n  }\n\n  TSNode node = unmarshal_node(tree);\n  TSPoint start_point = {start_row, code_unit_to_byte(start_column)};\n  TSPoint end_point = {end_row, code_unit_to_byte(end_column)};\n  TSPoint start_containing_point = {start_containing_row, code_unit_to_byte(start_containing_column)};\n  TSPoint end_containing_point = {end_containing_row, code_unit_to_byte(end_containing_column)};\n  ts_query_cursor_set_point_range(scratch_query_cursor, start_point, end_point);\n  ts_query_cursor_set_byte_range(scratch_query_cursor, start_index, end_index);\n  ts_query_cursor_set_containing_point_range(\n    scratch_query_cursor,\n    start_containing_point,\n    end_containing_point\n  );\n  ts_query_cursor_set_containing_byte_range(\n    scratch_query_cursor,\n    start_containing_index,\n    end_containing_index\n  );\n  ts_query_cursor_set_match_limit(scratch_query_cursor, match_limit);\n  ts_query_cursor_set_max_start_depth(scratch_query_cursor, max_start_depth);\n\n  TSQueryCursorOptions options = {.payload = NULL, .progress_callback = query_progress_callback};\n\n  ts_query_cursor_exec_with_options(scratch_query_cursor, self, node, &options);\n\n  uint32_t index = 0;\n  uint32_t match_count = 0;\n  Array(const void *) result = array_new();\n\n  TSQueryMatch match;\n  while (ts_query_cursor_next_match(scratch_query_cursor, &match)) {\n    match_count++;\n    array_grow_by(&result, 2 + (SIZE_OF_CAPTURE * match.capture_count));\n    result.contents[index++] = (const void *)(uint32_t)match.pattern_index;\n    result.contents[index++] = (const void *)(uint32_t)match.capture_count;\n    for (unsigned i = 0; i < match.capture_count; i++) {\n      const TSQueryCapture *capture = &match.captures[i];\n      result.contents[index++] = (const void *)capture->index;\n      marshal_node(result.contents + index, capture->node);\n      index += SIZE_OF_NODE;\n    }\n  }\n\n  bool did_exceed_match_limit =\n    ts_query_cursor_did_exceed_match_limit(scratch_query_cursor);\n  TRANSFER_BUFFER[0] = (const void *)(match_count);\n  TRANSFER_BUFFER[1] = (const void *)result.contents;\n  TRANSFER_BUFFER[2] = (const void *)(did_exceed_match_limit);\n}\n\nvoid ts_query_captures_wasm(\n  const TSQuery *self,\n  const TSTree *tree,\n  uint32_t start_row,\n  uint32_t start_column,\n  uint32_t end_row,\n  uint32_t end_column,\n  uint32_t start_index,\n  uint32_t end_index,\n  uint32_t start_containing_row,\n  uint32_t start_containing_column,\n  uint32_t end_containing_row,\n  uint32_t end_containing_column,\n  uint32_t start_containing_index,\n  uint32_t end_containing_index,\n  uint32_t match_limit,\n  uint32_t max_start_depth\n) {\n  if (!scratch_query_cursor) {\n    scratch_query_cursor = ts_query_cursor_new();\n  }\n\n  ts_query_cursor_set_match_limit(scratch_query_cursor, match_limit);\n\n  TSNode node = unmarshal_node(tree);\n  TSPoint start_point = {start_row, code_unit_to_byte(start_column)};\n  TSPoint end_point = {end_row, code_unit_to_byte(end_column)};\n  TSPoint start_containing_point = {start_containing_row, code_unit_to_byte(start_containing_column)};\n  TSPoint end_containing_point = {end_containing_row, code_unit_to_byte(end_containing_column)};\n  ts_query_cursor_set_point_range(scratch_query_cursor, start_point, end_point);\n  ts_query_cursor_set_byte_range(scratch_query_cursor, start_index, end_index);\n  ts_query_cursor_set_containing_point_range(\n    scratch_query_cursor,\n    start_containing_point,\n    end_containing_point\n  );\n  ts_query_cursor_set_containing_byte_range(\n    scratch_query_cursor,\n    start_containing_index,\n    end_containing_index\n  );\n  ts_query_cursor_set_match_limit(scratch_query_cursor, match_limit);\n  ts_query_cursor_set_max_start_depth(scratch_query_cursor, max_start_depth);\n  ts_query_cursor_exec(scratch_query_cursor, self, node);\n\n  unsigned index = 0;\n  unsigned capture_count = 0;\n  Array(const void *) result = array_new();\n\n  TSQueryMatch match;\n  uint32_t capture_index;\n  while (ts_query_cursor_next_capture(\n    scratch_query_cursor,\n    &match,\n    &capture_index\n  )) {\n    capture_count++;\n\n    array_grow_by(&result, 3 + (SIZE_OF_CAPTURE * match.capture_count));\n    result.contents[index++] = (const void *)(uint32_t)match.pattern_index;\n    result.contents[index++] = (const void *)(uint32_t)match.capture_count;\n    result.contents[index++] = (const void *)capture_index;\n    for (unsigned i = 0; i < match.capture_count; i++) {\n      const TSQueryCapture *capture = &match.captures[i];\n      result.contents[index++] = (const void *)capture->index;\n      marshal_node(result.contents + index, capture->node);\n      index += SIZE_OF_NODE;\n    }\n  }\n\n  bool did_exceed_match_limit =\n    ts_query_cursor_did_exceed_match_limit(scratch_query_cursor);\n  TRANSFER_BUFFER[0] = (const void *)(capture_count);\n  TRANSFER_BUFFER[1] = (const void *)result.contents;\n  TRANSFER_BUFFER[2] = (const void *)(did_exceed_match_limit);\n}\n"
  ],
  "names": [],
  "mappings": "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"
}